   Scroll lock is a  |lock_key|Lock_Key|  on most IBM-compatible  |computer_keyboards|Keyboard| .     Depending on the operating system, it may be used for different purposes and applications may assign functions to the key or change their behaviour depending on its toggling state.     The key is not frequently used, and therefore some reduced or specialized keyboards lack  altogether.     Pressing  performs the same function as pressing . This behavior is a remnant of the original  |IBM_PC_keyboards|Ibm_Pc_Keyboard| , which did not have a dedicated  key. Instead, they assigned the Pause function to  and the Break function to .           The  key was meant to lock all scrolling techniques, and is a vestige of the original  |IBM_PC_keyboard|Ibm_Pc_Keyboard| . In the original design,  was intended to modify the behavior of the  |arrow_keys|Arrow_Keys| . When the  mode was on, the arrow keys would  |scroll|Scrolling|  the contents of a text window instead of moving the  |cursor|Cursor| . In this usage,  is a toggling lock key like  |Num_Lock|Num_Lock|  or  |Caps_Lock|Caps_Lock| , which have a state that persists after the key is released.     Today, this particular use of  is rare. Modern programs honoring this behavior include  |IBM_Lotus_Notes|Ibm_Lotus_Notes| ,  |Forté_Agent|Forté_Agent| ,  |Image_Line_FL_Studio|Image_Line_Fl_Studio| ,  |Renoise|Renoise| ,  |Microsoft_Excel|Microsoft_Excel| ,  |Microsoft_Project|Microsoft_Project|   ,  |LibreOffice_Calc|Libreoffice_Calc| , and on occasions  |Microsoft_Word|Microsoft_Word| .     Some text editors  exhibit similar behavior when the arrow keys are used with  pressed.     Most  |GUI|Graphical_User_Interface|  environments neglect , which means scrolling must be accomplished with a  |mouse|Computer_Mouse| , using means such as  |scrollbars|Scrollbar|  or  |scroll_wheels|Scroll_Wheel| . Often, the middle or the wheel mouse button works as a toggle determining if mouse movements will move the mouse cursor or scroll the contents in scroll window.     Some web browsers including  |Firefox|Firefox|  and  |Internet_Explorer|Internet_Explorer|  support a  |Caret_browsing|Caret_Browsing|  mode which can be toggled by . While the window scrolling behaviour with Caret navigation disabled is similar to that suggested for Scroll Lock, enabling Caret navigation will enable a cursor scrolling behaviour as if Scroll Lock were disabled.       Pressing the  key in the  |Linux_console|Linux_Console|  while text is scrolling through the screen freezes the console output during which no further text is sent to the screen, while the program continues running as usual. When  is pressed again, the screen is unfrozen and all text generated during the freeze is displayed at once. This allows the user to pause the display and read long messages that scroll through the screen too quickly to read, such as for example when the system is  |booting_up|Booting_Up|  . If not configured otherwise,  and  can be used instead of Scroll Lock in any terminal in Linux to freeze and unfreeze the terminal output respectively.     This behaviour emulates the Hold Screen key or similar flow control mechanisms on computer terminals.     The behaviour must be distinguished from pressing the  |Pause_key|Pause_Key|  during  |POST|Power_On_Self_Test|  or under  |DOS|Dos| , which, by default, has the effect of temporarily halting the running process.     On the  |FreeBSD|Freebsd|  system console, the  key additionally enables scrolling: after pressing Scroll Lock, one can use  and  to scroll up or down. Pressing Scroll Lock again disables this mode and moves back to the bottom of the output. The Linux console implements this behaviour by using  and , not requiring  to be active.       In  |Multiuser_DOS|Multiuser_Dos| ,  |System_Manager|Datapac_System_Manager| , and  |REAL_32|Real_32| , activating  during boot will always enter a special diagnostic mode, where the operating system and loaded device drivers will display detailed status and debugging information about themselves and their interaction with the operating system, sometimes up to several screenfuls per loaded driver. Automatic scrolling is suspended for as long as  remains activated.       |DR_DOS_7_02|Dr_Dos_7_02|  and higher provides a  |CONFIG_SYS|Config_Sys|  directive named  |SCROLLOCK|Scrollock| ON OFF to change the Scroll Lock status on the fly.   Activating  during boot will enter a DIAG mode as well, wherein some special drivers may display more verbose messages, but in contrast to the situation under the Multiuser DOS family normal DOS drivers do not typically display additional information. The operating system, however, will temporarily suspend any automatic timeouts  in CONFIG.SYS trace  and / single-stepping modes for as long as  is active.       In the  |Microsoft_Windows_NT|Microsoft_Windows_Nt|  family starting with Windows 2000, a debugging feature can be enabled, that allows the user to manually crash the system, generating a memory dump for analysis of the current state of the operating system. This can be accomplished by setting the REGDWORD registry key HKEYLOCALMACHINE  to 1 . Once set, the user can hold the  key and tap the  key twice to trigger a  |Blue_Screen_of_Death|Blue_Screen_Of_Death| .     In  |Microsoft_Visual_Basic_5_0|Microsoft_Visual_Basic_5_0|  and  |6_0|Microsoft_Visual_Basic_6_0| ,  pauses the running program in the integrated development environment, as does its alias .     Copy and paste also served as part of a  |copy_paste|Copy_Paste|  facility between applications. Compared to the standard keyboard driver  |KEYB|Keyb|  these drivers offered a number of extensions including an  |extended_keystroke_buffer|Extended_Keyboard_Buffer|  with key stacking facility, macro recorder and a second cursor called CopyCursor, which could be invoked on demand  and freely moved on the screen using the cursor keys or the mouse, even outside the area reachable by the standard cursor in the running application. Once invoked, pressing  the characters under the CopyCursor could be stuffed, one after another, into the keyboard buffer, from where they would be read by the running application as emulated key  input, thereby typically showing up at the location of the standard cursor. The CopyCursor would move to the next screen position after each  . Normal keyboard input was still possible while the CopyCursor was enabled, and the user could switch between the two cursors by toggling the  hotkey again. Pressing  or  would exit the CopyCursor, so that, on its next invocation, it would show up at the position of the standard cursor again rather than at its previous location. If the screen contents was scrolled, the position of the CopyCursor would move accordingly until reaching the display limits. With  activated, keypresses would still reach the normal keystroke buffer, while CopyCursor input would be stacked up internally for later use in a second queue, dynamically maintained within the extended keystroke buffer. Thereby, it was possible to collect selected screen output from different programs and spool out the data much later while within yet another application by toggling  off again. It was also possible to use this as input into the macro recorder for later use as  |scrap_macro|Scrap_Macro| . Since this was an integral part of these keyboard drivers, it was fully transparent to running software and therefore worked with virtually any DOS programs, including at the command prompt, temporary shelled programs and task switchers.        |IBM_PC|Ibm_Pc|  documentation called  an inactive key . When  PC Magazine  asked an executive of keyboard manufacturer  |Key_Tronic|Key_Tronic|  about the keys purpose in a 1983 interview, he replied I dont know, but we put it on ours, too .     The indicator light is sometimes used for other purposes such as a  |keyboard_layout|Keyboard_Layout|  indicator in some  |Linux_distributions|Gnu_Linux_Distribution|  or other applications, because doing so is less likely to cause problems than manipulating other keys/lights.      |Keyboard_video_mouse_switches|Kvm_Switch|  often use the Scroll Lock key on the keyboard connected to the KVM switch for selecting between computers. On KVM switches with  |On_screen_display|On_Screen_Display|  , a double click of the Scroll Lock key often brings up the OSD, allowing the user to select the desired computer from a list or access the configuration menu of the KVM. Some models, especially those which lack an OSD, switch to the input corresponding to the number key pressed after Scroll Lock, or in the case of some 2-port switches, the up and down arrow keys. Simple models with only two or four inputs may immediately switch to the next input following a double press of the Scroll Lock key.             Some laptops and keyboards do not have a physical  key. Some of these have a second function on another key that acts as if a  key was pressed. Some common methods are:    or  on certain Dell laptops.     or  on certain Lenovo laptops.    on certain HP laptops.      Another way to press the  key is to use an onscreen keyboard. In Windows 8 this can be found through the Control Panel  ref name MicrosoftWindows-8 / code /code  .