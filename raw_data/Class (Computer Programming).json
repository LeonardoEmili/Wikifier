[
    {
        "In ": null
    },
    {
        "object-oriented programming": "Object-Oriented Programming"
    },
    {
        ", a class is an extensible program-code-template for creating ": null
    },
    {
        "objects": "Object"
    },
    {
        ", providing initial values for state  and implementations of behavior . In many languages, the class name is used as the name for the class , the name for the default ": null
    },
    {
        "constructor": "Constructor"
    },
    {
        " of the class , and as the ": null
    },
    {
        "type": "Data Type"
    },
    {
        " of objects generated by ": null
    },
    {
        "instantiating": "Instance"
    },
    {
        " the class; these distinct concepts are easily conflated.     When an object is created by a constructor of the class, the resulting object is called an ": null
    },
    {
        "instance": "Instance"
    },
    {
        " of the class, and the member variables specific to the object are called ": null
    },
    {
        "instance variables": "Instance Variable"
    },
    {
        ", to contrast with the ": null
    },
    {
        "class variables": "Class Variable"
    },
    {
        " shared across the class.     In some languages, classes are only a compile-time feature , while in other languages classes are ": null
    },
    {
        "first-class citizens": "First-Class Citizen"
    },
    {
        ", and are generally themselves objects . In these languages, a class that creates classes is called a ": null
    },
    {
        "metaclass": "Metaclass"
    },
    {
        ".       In casual use, people often refer to the class of an object, but narrowly speaking objects have type": null
    },
    {
        "member functions": "Member Function"
    },
    {
        " , and properties these satisfy. At the same time, a class has an implementation , and can create objects of a given type, with a given implementation. In the terms of type theory, a class is an implementationa concrete ": null
    },
    {
        "data structure": "Data Structure"
    },
    {
        " and collection of subroutineswhile a type is an ": null
    },
    {
        "interface": "Protocol"
    },
    {
        ". Different classes can produce objects of the same type ; for example, the type  might be implemented with two classes  and  . Similarly, a given class may have several different constructors.     Types generally represent nouns, such as a person, place or thing, or something ": null
    },
    {
        "nominalized": "Nominalization"
    },
    {
        ", and a class represents an implementation of these. For example, a  type might represent the properties and functionality of ": null
    },
    {
        "bananas": "Banana"
    },
    {
        " in general, while the  and  classes would represent ways of producing bananas . The  class could then produce particular bananas: instances of the  class would be objects of type . Often only a single implementation of a type is given, in which case the class name is often identical with the type name.       Classes are composed from structural and behavioral constituents. Programming languages that include classes as a programming construct offer support, for various class-related features, and the syntax required to use these features varies greatly from one programming language to another.     Structure      A class contains ": null
    },
    {
        "data": "Data"
    },
    {
        " field descriptions . These are usually field types and names that will be associated with state variables at program run time; these state variables either belong to the class or specific instances of the class. In most languages, the structure defined by the class determines the layout of the memory used by its instances. Other implementations are possible: for example, objects in ": null
    },
    {
        "Python": "Python"
    },
    {
        " use associative key-value containers.      Some programming languages support specification of ": null
    },
    {
        "invariants": "Class Invariant"
    },
    {
        " as part of the definition of the class, and enforce them through the type system. ": null
    },
    {
        "Encapsulation": "Encapsulation"
    },
    {
        " of state is necessary for being able to enforce the invariants of the class.               The behavior of class or its instances is defined using ": null
    },
    {
        "methods": "Method"
    },
    {
        ". Methods are ": null
    },
    {
        "subroutines": "Subroutine"
    },
    {
        " with the ability to operate on objects or classes. These operations may alter the state of an object or simply provide ways of accessing it.  Many kinds of methods exist, but support for them varies across languages. Some types of methods are created and called by programmer code, while other special methods—such as constructors, destructors, and conversion operators—are created and called by compiler-generated code. A language may also allow the programmer to define and call these special methods.              Every class implements  an interface by providing ": null
    },
    {
        "structure": "Structure"
    },
    {
        " and behavior. Structure consists of data and state, and behavior consists of code that specifies how methods are implemented. There is a distinction between the definition of an interface and the implementation of that interface; however, this line is blurred in many programming languages because class declarations both define and implement an interface. Some languages, however, provide features that separate interface and implementation. For example, an ": null
    },
    {
        "abstract class": "Abstractandconcrete"
    },
    {
        " can define an interface without providing implementation.     Languages that support class inheritance also allow classes to inherit interfaces from the classes that they are derived from.     For example,if class A inherits from class B and if class B implements the interface interface B then class A also inherits the functionality provided by interface B .     In languages that support ": null
    },
    {
        "access specifiers": "Information Hiding And Encapsulation"
    },
    {
        ", the interface of a class is considered to be the set of public members of the class, including both methods and attributes ; any private members or internal data structures are not intended to be depended on by external code and thus are not part of the interface.     Object-oriented programming methodology dictates that the operations of any interface of a class are to be independent of each other. It results in a layered design where clients of an interface use the methods declared in the interface. An interface places no requirements for clients to invoke the operations of one interface in any particular order. This approach has the benefit that client code can assume that the operations of an interface are available for use whenever the client has access to the object.         The buttons on the front of your television set are the interface between you and the electrical wiring on the other side of its plastic casing. You press the power button to toggle the television on and off. In this example, your particular television is the instance, each method is represented by a button, and all the buttons together compose the interface . In its most common form, an interface is a specification of a group of related methods without any associated implementation of the methods.     A television set also has a myriad of attributes, such as size and whether it supports colour, which together comprise its structure. A class represents the full description of a television, including its attributes and buttons .     Getting the total number of televisions manufactured could be a static method of the television class. This method is clearly associated with the class, yet is outside the domain of each individual instance of the class. A static method that finds a particular instance out of the set of all television objects is another example.               The following is a common set of ": null
    },
    {
        "access specifiers": "Access Specifiers"
    },
    {
        "     Private  restricts the access to the class itself. Only methods that are part of the same class can access private members.   Protected  allows the class itself and all its subclasses to access the member.   Public means that any code can access the member by its name.     Although many object-oriented languages support the above access specifiers,  their semantics may differ.     Object-oriented design uses the access specifiers in conjunction with careful design of public method implementations to enforce class invariants—constraints on the state of the objects. A common usage of access specifiers is to separate the internal data of a class from its interface: the internal structure is made private, while public ": null
    },
    {
        "accessor methods": "Accessor Method"
    },
    {
        " can be used to inspect or alter such private data.     Access specifiers do not necessarily control visibility, in that even private members may be visible to client external code. In some languages, an inaccessible but visible member may be referred to at run-time , but an attempt to use it by referring to the name of the member from client code will be prevented by the type checker.      The various object-oriented programming languages enforce member accessibility and visibility to various degrees, and depending on the languages ": null
    },
    {
        "type system": "Type System"
    },
    {
        " and compilation policies, enforced at either ": null
    },
    {
        "compile-time": "Compile Time"
    },
    {
        " or ": null
    },
    {
        "run-time": "Run Time"
    },
    {
        ". For example, the ": null
    },
    {
        "Java": "Java"
    },
    {
        " language does not allow client code that accesses the private data of a class to compile.     In the ": null
    },
    {
        "C++": "C++"
    },
    {
        " language, private methods are visible, but not accessible in the interface; however, they may be made invisible by explicitly declaring fully abstract classes that represent the interfaces of the class.      Some languages feature other accessibility schemes:   Instance vs. class accessibility": null
    },
    {
        "Ruby": "Ruby"
    },
    {
        " supports instance-private and instance-protected access specifiers in lieu of class-private and class-protected, respectively. They differ in that they restrict access based on the instance itself, rather than the instances class.      Friend": null
    },
    {
        "friend function": "Friend Function"
    },
    {
        " of the class may access the members designated as private or protected.    Path-based": null
    },
    {
        "Java package": "Java Syntaxaccess Modifiers"
    },
    {
        ", which is the logical path of the file. However, it is a common practice when extending a Java framework to implement classes in the same package as a framework class in order to access protected members. The source file may exist in a completely different location, and may be deployed to a different .jar file, yet still be in the same logical path as far as the JVM is concerned.       In addition to the design of standalone classes, programming languages may support more advanced class design based upon relationships between classes. The inter-class relationship design capabilities commonly provided are compositional and hierarchical.       Classes can be composed of other classes, thereby establishing a compositional relationship between the enclosing class and its embedded classes. Compositional relationship between classes is also commonly known as a  has-a  relationship. For example, a class Car could be composed of and contain a class Engine . Therefore, a Car has an Engine. One aspect of composition is containment, which is the enclosure of component instances by the instance that has them. If an enclosing object contains component instances by value, the components and their enclosing object have a similar ": null
    },
    {
        "lifetime": "Object Lifetime"
    },
    {
        ". If the components are contained by reference, they may not have a similar lifetime. For example, in Objective-C 2.0:       @interface Car : NSObject     @property NSString name;   @property Engine engine   @property NSArray tires;     @end       This  class has an instance of  , , and  .       Classes can be derived from one or more existing classes, thereby establishing a hierarchical relationship between the derived-from classes  and the derived class  . The relationship of the derived class to the derived-from classes is commonly known as an  is-a  relationship. For example, a class Button could be derived from a class Control. Therefore, a Button is a Control. Structural and behavioral members of the parent classes are inherited by the child class. Derived classes can define additional structural members and behavioral members in addition to those that they inherit and are therefore specializations of their superclasses. Also, derived classes can ": null
    },
    {
        "override": "Method Overriding"
    },
    {
        " inherited methods if the language allows.     Not all languages support multiple inheritance. For example, Java allows a class to implement multiple interfaces, but only inherit from one class.  If multiple inheritance is allowed, the hierarchy is a ": null
    },
    {
        "directed acyclic graph": "Directed Acyclic Graph"
    },
    {
        " , otherwise it is a ": null
    },
    {
        "tree": "Tree"
    },
    {
        ". The hierarchy has classes as nodes and inheritance relationships as links. Classes in the same level are more likely to be ": null
    },
    {
        "associated": "Association"
    },
    {
        " than classes in different levels. The levels of this hierarchy are called ": null
    },
    {
        "layers": "Layer"
    },
    {
        " or ": null
    },
    {
        "levels of abstraction": "Level Of Abstraction"
    },
    {
        ".     Example :     @interface UIResponder : NSObject //...   @interface UIView : UIResponder //...   @interface UIScrollView : UIView //...   @interface UITableView : UIScrollView //...     In this example, a UITableView is a UIScrollView is a UIView is a UIResponder is an NSObject.          Conceptually, a superclass is a ": null
    },
    {
        "superset": "Superset"
    },
    {
        " of its subclasses. For example, a common class hierarchy would involve  as a superclass of  and , while  would be a subclass of . These are all ": null
    },
    {
        "subset relations": "Subset"
    },
    {
        " in set theory as well, i.e., all squares are rectangles but not all rectangles are squares.     A common conceptual error is to mistake a part of relation with a subclass. For example, a car and truck are both kinds of vehicles and it would be appropriate to model them as subclasses of a vehicle class. However, it would be an error to model the component parts of the car as subclass relations. For example, a car is composed of an engine and body, but it would not be appropriate to model engine or body as a subclass of car.     In object-oriented modeling these kinds of relations are typically modeled as object properties. In this example, the  class would have a property called .  would be typed to hold a collection of objects, such as instances of , , , etc.   Object modeling languages such as ": null
    },
    {
        "UML": "Unified Modeling Language"
    },
    {
        " include capabilities to model various aspects of part of and other kinds of relations – data such as the cardinality of the objects, constraints on input and output values, etc. This information can be utilized by developer tools to generate additional code beside the basic data definitions for the objects, such as error checking on ": null
    },
    {
        "get and set methods": "Mutator Method"
    },
    {
        ".      One important question when modeling and implementing a system of object classes is whether a class can have one or more superclasses. In the real world with actual sets it would be rare to find sets that didnt intersect with more than one other set. However, while some systems such as Flavors and CLOS provide a capability for more than one parent to do so at run time introduces complexity that many in the object-oriented community consider antithetical to the goals of using object classes in the first place. Understanding which class will be responsible for handling a message can get complex when dealing with more than one superclass. If used carelessly this feature can introduce some of the same system complexity and ambiguity classes were designed to avoid.      Most modern object-oriented languages such as Smalltalk and Java require single inheritance at run time. For these languages, multiple inheritance may be useful for modeling but not for an implementation.     However, ": null
    },
    {
        "semantic web": "Semantic Web"
    },
    {
        " application objects do have multiple superclasses. The volatility of the Internet requires this level of flexibility and the technology standards such as the ": null
    },
    {
        "Web Ontology Language ": "Web Ontology Language"
    },
    {
        " are designed to support it.     A similar issue is whether or not the class hierarchy can be modified at run time. Languages such as Flavors, CLOS, and Smalltalk all support this feature as part of their ": null
    },
    {
        "meta-object protocols": "Meta-Object Protocol"
    },
    {
        ". Since classes are themselves first-class objects, it is possible to have them dynamically alter their structure by sending them the appropriate messages. Other languages that focus more on strong typing such as Java and C++ do not allow the class hierarchy to be modified at run time. Semantic web objects have the capability for run time changes to classes. The rational is similar to the justification for allowing multiple superclasses, that the Internet is so dynamic and flexible that dynamic changes to the hierarchy are required to manage this volatility.        Although class-based languages are commonly assumed to support inheritance, inheritance is not an intrinsic aspect of the concept of classes. Some languages, often referred to as ": null
    },
    {
        "object-based languages": "Object-Based Languages"
    },
    {
        " , support classes yet do not support inheritance. Examples of object-based languages include earlier versions of ": null
    },
    {
        "Visual Basic": "Visual Basic"
    },
    {
        ".             In ": null
    },
    {
        "object-oriented analysis": "Object-Oriented Analysis And Design"
    },
    {
        " and in ": null
    },
    {
        "UML": "Unified Modelling Language"
    },
    {
        ", an association between two classes represents a collaboration between the classes or their corresponding instances. Associations have direction; for example, a bi-directional association between two classes indicates that both of the classes are aware of their relationship.  Associations may be labeled according to their name or purpose.     An association role is given end of an association and describes the role of the corresponding class. For example, a subscriber role describes the way instances of the class Person participate in a subscribes-to association with the class Magazine . Also, a Magazine has the subscribed magazine role in the same association. Association role multiplicity describes how many instances correspond to each instance of the other class of the association. Common multiplicities are 0..1 , 1..1 , 1.. and 0.. , where the specifies any number of instances.       There are many categories of classes, some of which overlap.     Abstract and concrete      In a language that supports inheritance, an abstract class, or abstract base class , is a class that cannot be instantiated because it is either labeled as abstract or it simply specifies ": null
    },
    {
        "abstract methods": "Abstract Method"
    },
    {
        " . An abstract class may provide implementations of some methods, and may also specify virtual methods via ": null
    },
    {
        "signatures": "Type Signature"
    },
    {
        " that are to be implemented by direct or indirect descendants of the abstract class. Before a class derived from an abstract class can be instantiated, all abstract methods of its parent classes must be implemented by some class in the derivation chain.      Most object-oriented programming languages allow the programmer to specify which classes are considered abstract and will not allow these to be instantiated. For example, in ": null
    },
    {
        "Java": "Java"
    },
    {
        ", ": null
    },
    {
        "C": "C Sharp"
    },
    {
        " and ": null
    },
    {
        "PHP": "Php"
    },
    {
        ", the keyword abstract is used.   In ": null
    },
    {
        "C++": "C++"
    },
    {
        ", an abstract class is a class having at least one abstract method given by the appropriate syntax in that language .     A class consisting of only virtual methods is called a Pure Abstract Base Class  in C++ and is also known as an interface by users of the language. Other languages, notably Java and C, support a variant of abstract classes called an ": null
    },
    {
        "interface": "Interface"
    },
    {
        " via a keyword in the language. In these languages, ": null
    },
    {
        "multiple inheritance": "Multiple Inheritance"
    },
    {
        " is not allowed, but a class can implement multiple interfaces. Such a class can only contain abstract publicly accessible methods.              A concrete class is a class that can be ": null
    },
    {
        "instantiated": "Instantiation"
    },
    {
        ", as opposed to abstract classes, which cannot.       In some languages, classes can be declared in ": null
    },
    {
        "scopes": "Scope"
    },
    {
        " other than the global scope. There are various types of such classes.     An  inner class  is a class defined within another class. The relationship between an inner class and its containing class can also be treated as another type of class association. An inner class is typically neither associated with instances of the enclosing class nor instantiated along with its enclosing class. Depending on language, it may or may not be possible to refer to the class from outside the enclosing class. A related concept is inner types, also known as inner data type or nested type, which is a generalization of the concept of inner classes. ": null
    },
    {
        "C++": "C++"
    },
    {
        " is an example of a language that supports both inner classes and inner types .         Another type is a local class, which is a class defined within a procedure or function. This limits references to the class name to within the scope where the class is declared. Depending on the semantic rules of the language, there may be additional restrictions on local classes compared to non-local ones. One common restriction is to disallow local class methods to access local variables of the enclosing function. For example, in C++, a local class may refer to static variables declared within its enclosing function, but may not access the functions automatic variables.               Metaclasses are classes whose instances are classes. A metaclass describes a common structure of a collection of classes and can implement a ": null
    },
    {
        "design pattern": "Design Pattern"
    },
    {
        " or describe particular kinds of classes. Metaclasses are often used to describe ": null
    },
    {
        "frameworks": "Software Framework"
    },
    {
        ".      In some languages, such as ": null
    },
    {
        "Python": "Python"
    },
    {
        ", ": null
    },
    {
        "Ruby": "Ruby"
    },
    {
        " or ": null
    },
    {
        "Smalltalk": "Smalltalk"
    },
    {
        ", a class is also an object; thus each class is an instance of a unique metaclass that is built into the language.             The ": null
    },
    {
        "Common Lisp Object System": "Common Lisp Object System"
    },
    {
        "     metaobject protocols": "Metaobject"
    },
    {
        " to implement those classes and metaclasses.            Non-subclassable classes allow programmers to design classes and hierarchies of classes where at some level in the hierarchy, further derivation is prohibited . Contrast this to abstract classes, which imply, encourage, and require derivation in order to be used at all. A non-subclassable class is implicitly concrete.     A non-subclassable class is created by declaring the class as  in C or as  in Java or PHP.          For example, Javas  class is designated as final.        Non-subclassable classes may allow a compiler to perform optimizations that are not available for subclassable classes.                  An open class is one that can be changed. Typically, an ": null
    },
    {
        "executable program": "Executable Program"
    },
    {
        " cannot be changed by customers. Developers can often change some classes, but typically cannot change standard or built-in ones. In ": null
    },
    {
        "Ruby": "Ruby Open Classes"
    },
    {
        ", all classes are open. In ": null
    },
    {
        "Python": "Python"
    },
    {
        ", classes can be created at runtime, and all can be modified afterwards.  ": null
    },
    {
        "Objective-C categories": "Objective-Ccategories"
    },
    {
        " permit the programmer to add methods to an existing class without the need to recompile that class or even have access to its source code.       Some languages have special support for ": null
    },
    {
        "mixins": "Mixin"
    },
    {
        ", though in any language with multiple inheritance a mixin is simply a class that does not represent an is-a-type-of relationship. Mixins are typically used to add the same methods to multiple classes; for example, a class  might provide a method called  when included in classes  and  that do not share a common parent.            In languages supporting the feature, a partial class is a class whose definition may be split into multiple pieces, within a single ": null
    },
    {
        "source-code": "Source Code"
    },
    {
        " file or across multiple files.  The pieces are merged at compile-time, making compiler output the same as for a non-partial class.     The primary motivation for introduction of partial classes is to facilitate the implementation of ": null
    },
    {
        "code generators": "Code Generator"
    },
    {
        ", such as ": null
    },
    {
        "visual designers": "Visual Designer"
    },
    {
        ". It is otherwise a challenge or compromise to develop code generators that can manage the generated code when it is interleaved within developer-written code. Using partial classes, a code generator can process a separate file or coarse-grained partial class within a file, and is thus alleviated from intricately interjecting generated code via extensive parsing, increasing compiler efficiency and eliminating the potential risk of corrupting developer code. In a simple implementation of partial classes, the compiler can perform a phase of ": null
    },
    {
        "precompilation": "Precompilation"
    },
    {
        " where it unifies all the parts of a partial class. Then, compilation can proceed as usual.     Other benefits and effects of the partial class feature include:     Enables separation of a classs interface and implementation code in a unique way.   Eases navigation through large classes within an ": null
    },
    {
        "editor": "Source Code Editor"
    },
    {
        ".   Enables ": null
    },
    {
        "separation of concerns": "Separation Of Concerns"
    },
    {
        ", in a way similar to ": null
    },
    {
        "aspect-oriented programming": "Aspect-Oriented Programming"
    },
    {
        " but without using any extra tools.   Enables multiple developers to work on a single class concurrently without the need to merge individual code into one file at a later time.     Partial classes have existed in ": null
    },
    {
        "Smalltalk": "Smalltalk"
    },
    {
        " under the name of Class Extensions for considerable time. With the arrival of the ": null
    },
    {
        ".NET framework 2": ".Net Framework"
    },
    {
        ", ": null
    },
    {
        "Microsoft": "Microsoft"
    },
    {
        " introduced partial classes, supported in both ": null
    },
    {
        "C": "C Sharp"
    },
    {
        " 2.0 and ": null
    },
    {
        "Visual Basic 2005": "Visual Basic .Net"
    },
    {
        ". ": null
    },
    {
        "WinRT": "Winrt"
    },
    {
        " also supports partial classes.       This simple example, written in ": null
    },
    {
        "Visual Basic .NET": "Visual Basic .Net"
    },
    {
        ", shows how parts of the same class are defined in two different files.   ;file1.vb:     Partial Class MyClass   Private name As String   End Class     ;file2.vb:     Partial Class MyClass   Public Readonly Property Name As String   Get   Return name   End Get   End Property   End Class     When compiled, the result is the same as if the two files were written as one, like this:     Class MyClass   Private name As String   Public Readonly Property Name As String   Get   Return name   End Get   End Property   End Class         In ": null
    },
    {
        "Objective-C": "Objective-C"
    },
    {
        ", partial classes, also known as categories, may even spread over multiple libraries and executables, like the following example. But a key difference is that Objective-Cs categories can overwrite definitions in another interface declaration, and that categories arent equal to original class definition .  Instead, .NET partial class cant have conflicting definitions, and all partial definitions are equal to the others.     In Foundation, header file NSData.h:     @interface NSData : NSObject     - initWithContentsOfURL:URL;   //...     @end     In user-supplied library, a separate binary from Foundation framework, header file NSData+base64.h:     import     @interface NSData     - base64String;   - initWithBase64String:base64String;     @end     And in an app, yet another separate binary file, source code file main.m:     import   import NSData+base64.h     int main   ": null
    }
]