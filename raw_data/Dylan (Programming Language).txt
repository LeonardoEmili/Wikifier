     Dylan is a multi-paradigm  |programming_language|Programming_Language|  that includes support for  |functional|Functional_Programming|  and  |object_oriented_programming|Object_Oriented_Programming|  , and is  |dynamic|Dynamic_Programming_Language|  and  |reflective|Reflection|  while providing a programming model designed to support generating efficient machine code, including fine-grained control over dynamic and static behaviors. It was created in the early 1990s by a group led by  |Apple_Computer|Apple_Computer| .     A concise and thorough overview of the language may be found in the Dylan Reference Manual.     Dylan derives from  |Scheme|Scheme|  and  |Common_Lisp|Common_Lisp|  and adds an integrated object system derived from the  |Common_Lisp_Object_System|Common_Lisp_Object_System|  . In Dylan, all values  are  |first_class_objects|First_Class_Object| . Dylan supports  |multiple_inheritance|Multiple_Inheritance| ,  |polymorphism|Polymorphism| ,  |multiple_dispatch|Multiple_Dispatch| ,  |keyword_arguments|Keyword_Argument| , object introspection,  |pattern|Pattern_Matching| -based  |syntax_extension_macros|Syntactic_Macro| , and many other advanced features. Programs can express fine-grained control over dynamism, admitting programs that occupy a continuum between dynamic and static programming and supporting evolutionary development .     Dylans main design goal is to be a dynamic language well-suited for developing  |commercial_software|Commercial_Software| . Dylan attempts to address potential performance issues by introducing natural limits to the full flexibility of  |Lisp|Lisp|  systems, allowing the  |compiler|Compiler|  to clearly understand compilable units, such as  |libraries|Library| .     Dylan derives much of its semantics from Scheme and other Lisps; some Dylan implementations were initially built within extant Lisp systems. However, Dylan has an  |ALGOL|Algol| -like syntax instead of a Lisp-like prefix syntax.            Dylan was created in the early 1990s by a group led by  |Apple_Computer|Apple_Computer| . At one time in its development, it was intended for use with the  |Apple_Newton|Apple_Newton|  computer, but the Dylan implementation did not reach sufficient maturity in time, and Newton instead used a mix of C and the  |NewtonScript|Newtonscript|  developed by Walter Smith. Apple ended their Dylan development effort in 1995, though they made a technology release version available that included an advanced  |integrated_development_environment|Integrated_Development_Environment|  .     Two other groups contributed to the design of the language and developed implementations:  |Harlequin|Harlequin|  released a commercial IDE for  |Microsoft_Windows|Microsoft_Windows|  and  |Carnegie_Mellon_University|Carnegie_Mellon_University|  released an  |open_source|Open_Source_Software|  compiler for  |Unix|Unix|  systems called Gwydion Dylan. Both of these implementations are now open source. The Harlequin implementation is now named Open Dylan and is maintained by a group of volunteers, the Dylan Hackers.     The Dylan language was code-named Ralph. James Joaquin chose the name Dylan for DYnamic LANguage.       Many of Dylans syntax features come from its Lisp heritage. Originally, Dylan used a Lisp-like prefix syntax, which was based on  |s_expressions|S_Expression| . By the time the language design was completed, the syntax was changed to an ALGOL-like syntax, with the expectation that it would be more familiar to a wider audience of programmers. The syntax was designed by Michael Kahl. It is described in great detail in the Dylan Reference Manual.       Dylan is not  |case_sensitive|Case_Sensitivity| . Dylans  |lexical_syntax|Lexical_Syntax|  allows the use of a naming convention where  |hyphen_minus|Hyphen_Minus|  signs are used to connect the parts of multiple-word identifiers . This convention is common in Lisp languages but cannot be used in programming languages that treat any hyphen-minus that is not part of a numeric  |literal|Literal|  as a single  |lexical_token|Lexical_Token| , even when not surrounded by  |whitespace_characters|Whitespace_Character| .     Identifiers in Dylan may contain more special characters than most languages. Besides  |alphanumeric|Alphanumeric|  characters and hyphen-minus signs, Dylan allows the following non-alphanumerical characters as part of identifiers:  |underscore|Underscore|   ,  |asterisk|Asterisk|   ,  |ampersand|Ampersand|   ,  |less_than_sign|Less_Than_Sign|   ,  |equals_sign|Equals_Sign|   ,  |greater_than_sign|Greater_Than_Sign|   ,  |vertical_bar|Vertical_Bar|   ,  |caret|Caret|   ,  |dollar_sign|Dollar_Sign|   ,  |percent_sign|Percent_Sign|   , and  |at_sign|At_Sign|   . Identifiers may not consist of these non-alphanumeric characters or numeric characters alone. If there is any ambiguity, whitespace is used.       A simple class with several slots:       define class   slot point-x :: ,   required-init-keyword: x:;   slot point-y :: ,   required-init-keyword: y:;   end class ;       By convention, classes are named with less-than and greater-than signs used as  |angle_brackets|Angle_Bracket| , e.g. the class named  point   in the code example.     In end class  point   both class and  point   are optional. This is true for all end clauses. For example, you may write end if or just end to terminate an if statement.     The same class, rewritten in the most minimal way possible:       define class   slot point-x;   slot point-y;   end;       The slots are now both typed as  object   . The slots must be initialized manually.     By convention, constant names begin with $ :       define constant $pi :: 3.1415927d0;       A factorial function:     define function factorial 0  .