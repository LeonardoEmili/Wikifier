The P-complete problems form a  |complexity_class|Complexity_Class|  in  |computational_complexity_theory|Computational_Complexity_Theory| . The problems in this complexity class are defined by having the following two properties:   The problem is in P, the class of problems that can be defined as counting the number of accepting paths of a  |polynomial-time|Polynomial-Time| |non-deterministic_Turing_machine|Non-Deterministic_Turing_Machine| .   The problem is P-hard, meaning that every other problem in P has a  |Turing_reduction|Turing_Reduction|  or  |polynomial-time_counting_reduction|Polynomial-Time_Counting_Reduction|  to it. A counting reduction is a pair of polynomial-time transformations from inputs of the other problem to inputs of the given problem and from outputs of the given problem to outputs of the other problem, allowing the other problem to be solved using any subroutine for the given problem. A Turing reduction is an algorithm for the other problem that makes a polynomial number of calls to a subroutine for the given problem and, outside of those calls, uses polynomial time. In some cases  |parsimonious_reductions|Parsimonious_Reduction| , a more specific type of reduction that preserves the exact number of solutions, are used.     A polynomial-time algorithm for solving a P-complete problem, if it existed, would solve the  |P_versus_NP_problem|P_Versus_Np_Problem|  by implying that P and NP are equal. No such algorithm is known, nor is a proof known that such an algorithm does not exist.       Examples of P-complete problems include:   How many different variable assignments will satisfy a given general boolean formula?    How many different variable assignments will satisfy a given  |DNF|Disjunctive_Normal_Form|  formula?   How many different variable assignments will satisfy a given  |2-satisfiability|2-Satisfiability|  problem?   How many  |perfect_matchings|Perfect_Matching|  are there for a given bipartite  |graph|Graph_Theory| ?   What is the value of the  |permanent|Permanent|  of a given matrix whose entries are 0 or 1?    How many  |graph_colorings|Graph_Coloring|  using k colors are there for a particular graph G?   How many different  |linear_extensions|Linear_Extension|  are there for a given  |partially_ordered_set|Partially_Ordered_Set| , or, equivalently, how many different  |topological_orderings|Topological_Sorting|  are there for a given  |directed_acyclic_graph|Directed_Acyclic_Graph| ? .         Some P-complete problems correspond to easy  problems. Determining the satisfiability of a boolean formula in DNF is easy: such a formula is satisfiable if and only if it contains a satisfiable conjunction , whereas counting the number of satisfying assignments is P-complete. Furthermore, deciding 2-satisfiability is easy compared to counting the number of satisfying assignments.  |Topologically_sorting|Topological_Sorting|  is easy in contrast to counting the number of topological sortings. A single  |perfect_matching|Matching|  can be found in polynomial time, but counting all perfect matchings is P-complete. The perfect matching counting problem was the first counting problem corresponding to an easy P problem shown to be P-complete, in a 1979 paper by  |Leslie_Valiant|Leslie_Valiant|  which also defined the class P and the P-complete problems for the first time.          There are  |probabilistic_algorithms|Probabilistic_Algorithm|  that return good approximations to some P-complete problems with high probability. This is one of the demonstrations of the power of probabilistic algorithms.     Many P-complete problems have a  |fully_polynomial-time_randomized_approximation_scheme|Polynomial-Time_Approximation_Scheme| , or FPRAS, which, informally, will produce with high probability an approximation to an arbitrary degree of accuracy, in time that is polynomial with respect to both the size of the problem and the degree of accuracy required.  |Jerrum|Mark_Jerrum| ,  |Valiant|Leslie_Valiant| , and  |Vazirani|Vijay_Vazirani|  showed that every P-complete problem either has an FPRAS, or is essentially impossible to approximate; if there is any polynomial-time algorithm which consistently produces an approximation of a P-complete problem which is within a polynomial ratio in the size of the input of the exact answer, then that algorithm can be used to construct an FPRAS. 