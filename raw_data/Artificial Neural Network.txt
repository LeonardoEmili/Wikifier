               Artificial neural networks  or connectionist systems are computing systems that are inspired by, but not identical to,  |biological_neural_networks|Biological_Neural_Network|  that constitute animal  |brains|Brain| . Such systems learn to perform tasks by considering examples, generally without being programmed with task-specific rules. For example, in  |image_recognition|Image_Recognition| , they might learn to identify images that contain cats by analyzing example images that have been manually  |labeled|Labeled_Data|  as cat or no cat and using the results to identify cats in other images. They do this without any prior knowledge of cats, for example, that they have fur, tails, whiskers and cat-like faces. Instead, they automatically generate identifying characteristics from the examples that they process.     An ANN is based on a collection of connected units or nodes called  |artificial_neurons|Artificial_Neuron| , which loosely model the  |neurons|Neuron|  in a biological brain. Each connection, like the  |synapses|Synapse|  in a biological brain, can transmit a signal to other neurons. An artificial neuron that receives a signal then processes it and can signal neurons connected to it.     In ANN implementations, the signal at a connection is a  |real_number|Real_Number| , and the output of each neuron is computed by some non-linear function of the sum of its inputs. The connections are called edges. Neurons and edges typically have a  weight  that adjusts as learning proceeds. The weight increases or decreases the strength of the signal at a connection. Neurons may have a threshold such that a signal is sent only if the aggregate signal crosses that threshold. Typically, neurons are aggregated into layers. Different layers may perform different transformations on their inputs. Signals travel from the first layer , to the last layer , possibly after traversing the layers multiple times.     The original goal of the ANN approach was to solve problems in the same way that a  |human_brain|Human_Brain|  would. However, over time, attention moved to performing specific tasks, leading to deviations from  |biology|Biology| . ANNs have been used on a variety of tasks, including  |computer_vision|Computer_Vision| ,  |speech_recognition|Speech_Recognition| ,  |machine_translation|Machine_Translation| ,  |social_network|Social_Network|  filtering,  |playing_board_and_video_games|General_Game_Playing| ,  |medical_diagnosis|Medical_Diagnosis|  and even in activities that have traditionally been considered as reserved to humans, like painting.               |Warren_McCulloch|Warren_Mcculloch|  and  |Walter_Pitts|Walter_Pitts|   opened the subject by creating a computational model for neural networks.  In the late 1940s,  |D._O._Hebb|Donald_O._Hebb|   created a learning hypothesis based on the mechanism of  |neural_plasticity|Neuroplasticity|  that became known as  |Hebbian_learning|Hebbian_Learning| . Farley and  |Wesley_A._Clark|Wesley_A._Clark|   first used computational machines, then called calculators , to simulate a Hebbian network.  |Rosenblatt|Frank_Rosenblatt|   created the  |perceptron|Perceptron| .  The first functional networks with many layers were published by  |Ivakhnenko|Alexey_Grigorevich_Ivakhnenko|  and Lapa in 1965, as the  |Group_Method_of_Data_Handling|Group_Method_Of_Data_Handling| .    The basics of continuous backpropagation     |control_theory|Control_Theory|  by  |Kelley|Henry_J._Kelley|   in 1960 and by  |Bryson|Arthur_E._Bryson|  in 1961,  using principles of  |dynamic_programming|Dynamic_Programming| .     In 1970,  |Seppo_Linnainmaa|Seppo_Linnainmaa|  published the general method for  |automatic_differentiation|Automatic_Differentiation|  of discrete connected networks of nested  |differentiable|Differentiable_Function|  functions.   In 1973, Dreyfus used backpropagation to adapt  |parameters|Parameter|  of controllers in proportion to error gradients.   |Werboss|Paul_Werbos| |backpropagation|Backpropagation|  algorithm enabled practical training of multi-layer networks. In 1982, he applied Linnainmaas AD method to neural networks in the way that became widely used.  Thereafter research stagnated following  |Minsky|Marvin_Minsky|  and  |Papert|Seymour_Papert|  ,  who discovered that basic perceptrons were incapable of processing the exclusive-or circuit and that computers lacked sufficient power to process useful neural networks. In 1992,  |max-pooling|Convolutional_Neural_Networkpooling_Layer|  was introduced to help with least shift invariance and tolerance to deformation to aid in  |3D_object_recognition|3D_Object_Recognition| . J. Weng, N. Ahuja and T. S. Huang, , Proc. International Joint Conference on Neural Networks, Baltimore, Maryland, vol I, pp. 576–581, June, 1992. J. Weng, N. Ahuja and T. S. Huang, , Proc. 4th International Conf. Computer Vision, Berlin, Germany, pp. 121–128, May, 1993. J. Weng, N. Ahuja and T. S. Huang, , International Journal of Computer Vision, vol. 25, no. 2, pp. 105–139, Nov. 1997.  |Schmidhuber|Jürgen_Schmidhuber|  adopted a multi-level hierarchy of networks pre-trained one level at a time by  |unsupervised_learning|Unsupervised_Learning|  and fine-tuned by  |backpropagation|Backpropagation| . J. Schmidhuber., Learning complex, extended sequences using the principle of history compression, Neural Computation, 4, pp. 234–242, 1992.      |Geoffrey_Hinton|Geoffrey_Hinton|  et al. proposed learning a high-level representation using successive layers of binary or real-valued  |latent_variables|Latent_Variable|  with a  |restricted_Boltzmann_machine|Restricted_Boltzmann_Machine|   to model each layer. In 2012,  |Ng|Andrew_Ng|  and  |Dean|Jeff_Dean|  created a network that learned to recognize higher-level concepts, such as cats, only from watching unlabeled images.  Unsupervised pre-training and increased computing power from  |GPUs|Gpu|  and  |distributed_computing|Distributed_Computing|  allowed the use of larger networks, particularly in image and visual recognition problems, which became known as  |deep_learning|Deep_Learning|  .     Ciresan and colleagues  showed that despite the vanishing gradient problem, GPUs make backpropagation feasible for many-layered feedforward neural networks. Dominik Scherer, Andreas C. Müller, and Sven Behnke: , In 20th International Conference Artificial Neural Networks , pp. 92–101, 2010. . Between 2009 and 2012, ANNs began winning prizes in ANN contests, approaching human level performance on various tasks, initially in  |pattern_recognition|Pattern_Recognition|  and  |machine_learning|Machine_Learning| .   with  |Jürgen_Schmidhuber|Jürgen_Schmidhuber|  on the eight competitions won by his Deep Learning team 2009–2012  For example, the bi-directional and multi-dimensional  |long_short-term_memory|Long_Short-Term_Memory|  Graves, Alex; and Schmidhuber, Jürgen; http://www.idsia.ch/~juergen/nips2009.pdf Offline Handwriting Recognition with Multidimensional Recurrent Neural Networks, in Bengio, Yoshua; Schuurmans, Dale; Lafferty, John; Williams, Chris K. I.; and Culotta, Aron , Advances in Neural Information Processing Systems 22 , 7–10 December 2009, Vancouver, BC, Neural Information Processing Systems Foundation, 2009, pp. 545–552.     of  |Graves|Alex_Graves|  et al. won three competitions in connected handwriting recognition in 2009 without any prior knowledge about the three languages to be learned.      Ciresan and colleagues built the first pattern recognizers to achieve human-competitive/superhuman performance  on benchmarks such as traffic sign recognition .          ANNs began as an attempt to exploit the architecture of the human brain to perform tasks that conventional algorithms had little success with. They soon reoriented towards improving empirical results, mostly abandoning attempts to remain true to their biological precursors. Neurons are connected to each other in various patterns, to allow the output of some neurons to become the input of others. The network forms a  |directed|Directed_Graph| ,  |weighted_graph|Weighted_Graph| .            ANNs retained the biological concept of  |artificial_neurons|Artificial_Neurons| , which receive input, combine the input with their internal state  and an optional threshold using an activation function, and produce output using an output function. The initial inputs are external data, such as images and documents. The ultimate outputs accomplish the task, such as recognizing an object in an image. The important characteristic of the activation function is that it provides a smooth transition as input values change, i.e. a small change in input produces a small change in output.        The network consists of connections, each connection providing the output of one neuron as an input to another neuron. Each connection is assigned a weight that represents its relative importance. A given neuron can have multiple input and output connections.        The propagation function computes the input to a neuron from the outputs of its predecessor neurons and their connections as a weighted sum. A bias term can be added to the result of the propagation.        The neurons are typically organized into multiple layers, especially in  |deep_learning|Deep_Learning| . Neurons of one layer connect only to neurons of the immediately preceding and immediately following layers. The layer that receives external data is the input layer. The layer that produces the ultimate result is the output layer. In between them are zero or more hidden layers. Single layer and unlayered networks are also used. Between two layers, multiple connection patterns are possible. They can be fully connected, with every neuron in one layer connecting to every neuron in the next layer. They can be pooling, where a group of neurons in one layer connect to a single neuron in the next layer, thereby reducing the number of neurons in that layer.  Neurons with only such connections form a  |directed_acyclic_graph|Directed_Acyclic_Graph|  and are known as  |feedforward_networks|Feedforward_Neural_Network| .  Alternatively, networks that allow connections between neurons in the same or previous layers are known as  |recurrent_networks|Recurrent_Neural_Network| .           A hyperparameter is a  |parameter|Parameter|  whose value is set before the learning process begins. The values of parameters are derived via learning. Examples of hyperparameters include  |learning_rate|Learning_Rate| , the number of hidden layers and batch size.  The values of some hyperparameters can be dependent on those of other hyperparameters. For example, the size of some layers can depend on the overall number of layers.            Learning is the adaptation of the network to better handle a task by considering sample observations. Learning involves adjusting the weights of the network to improve the accuracy of the result. This is done by minimizing the observed errors. Learning is complete when examining additional observations does not usefully reduce the error rate. Even after learning, the error rate typically does not reach 0. If after learning, the error rates too high, the network typically must be redesigned. Practically this is done by defining a  |cost_function|Loss_Function|  that is evaluated periodically during learning. As long as its output continues to decline, learning continues. The cost is frequently defined as a  |statistic|Statistic|  whose value can only be approximated. The outputs are actually numbers, so when the error is low, the difference between the output and the correct answer is small. Learning attempts to reduce the total of the differences across the observations. Most learning models can be viewed as a straightforward application of  |optimization|Mathematical_Optimization|  theory and  |statistical_estimation|Statistical_Estimation| .       The learning rate defines the size of the corrective steps that the model takes to adjust for errors in each observation. A high learning rate shortens the training time, but with lower ultimate accuracy, while a lower learning rate takes longer, but with the potential for greater accuracy. Optimizations such as  |Quickprop|Quickprop|  are primarily aimed at speeding up error minimization, while other improvements mainly try to increase reliability. In order to avoid oscillation inside the network such as alternating connection weights, and to improve the rate of convergence, refinements use an  |adaptive_learning_rate|Adaptive_Learning_Rate|  that increases or decreases as appropriate.  The concept of momentum allows the balance between the gradient and the previous change to be weighted such that the weight adjustment depends to some degree on the previous change. A momentum close to 0 emphasizes the gradient, while a value close to 1 emphasizes the last change.       While it is possible to define a cost function  |ad_hoc|Ad_Hoc| , frequently the choice is determined by the functions desirable properties  or because it arises from the model .          Backpropagation is a method to adjust the connection weights to compensate for each error found during learning. The error amount is effectively divided among the connections. Technically, backprop calculates the  |gradient|Gradient|  of the  |cost_function|Loss_Function|  associated with a given state with respect to the weights. The weight updates can be done via  |stochastic_gradient_descent|Stochastic_Gradient_Descent|  or other methods, such as  |Extreme_Learning_Machines|Extreme_Learning_Machines| ,  No-prop networks,  training without backtracking,  weightless networks, ESANN. 2009  and  |non-connectionist_neural_networks|Holographic_Associative_Memory| .          The three major learning paradigms are  |supervised_learning|Supervised_Learning| ,  |unsupervised_learning|Unsupervised_Learning|  and  |reinforcement_learning|Reinforcement_Learning| . They each correspond to a particular learning task        |Supervised_learning|Supervised_Learning|  uses a set of paired inputs and desired outputs. The learning task is to produce the desired output for each input. In this case the cost function is related to eliminating incorrect deductions.  A commonly used cost is the  |mean-squared_error|Mean-Squared_Error| , which tries to minimize the average squared error between the networks output and the desired output. Tasks suited for supervised learning are  |pattern_recognition|Pattern_Recognition|  and  |regression|Regression_Analysis|  . Supervised learning is also applicable to sequential data . This can be thought of as learning with a teacher , in the form of a function that provides continuous feedback on the quality of solutions obtained thus far.       In  |unsupervised_learning|Unsupervised_Learning| , input data is given along with the cost function, some function of the data   x and the networks output. The cost function is dependent on the task and any  a priori  assumptions . As a trivial example, consider the model   f a where   a is a constant and the cost   CE . Minimizing this cost produces a value of   a that is equal to the mean of the data. The cost function can be much more complicated. Its form depends on the application: for example, in  |compression|Data_Compression|  it could be related to the  |mutual_information|Mutual_Information|  between   x and   f , whereas in statistical modeling, it could be related to the  |posterior_probability|Posterior_Probability|  of the model given the data . Tasks that fall within the paradigm of unsupervised learning are in general  |estimation|Approximation|  problems; the applications include  |clustering|Data_Clustering| , the estimation of  |statistical_distributions|Statistical_Distributions| ,  |compression|Data_Compression|  and  |filtering|Bayesian_Spam_Filtering| .               In applications such as playing video games, an actor takes a string of actions, receiving a generally unpredictable response from the environment after each one. The goal is to win the game, i.e., generate the most positive responses. In  |reinforcement_learning|Reinforcement_Learning| , the aim is to weight the network to perform actions that minimize long-term cost. at each point in time the agent performs an action and the environment generates an observation and an instantaneous cost, according to some rules. The rules and the long-term cost usually only can be estimated. At any juncture, the agent decides whether to explore new actions to uncover their costs or to exploit prior learning to proceed more quickly.     Formally the environment is modeled as a  |Markov_decision_process|Markov_Decision_Process|  with states     S and actions     A . Because the state transitions are not known, probability distributions are used instead: the instantaneous cost distribution   P , the observation distribution   P and the transition distribution   P , while a policy is defined as the conditional distribution over actions given the observations. Taken together, the two define a  |Markov_chain|Markov_Chain|  . The aim is to discover the lowest-cost MC.       ANNs serve as the learning component in such applications.    |Dynamic_programming|Dynamic_Programming|  coupled with ANNs  has been applied to problems such as those involved in  |vehicle_routing|Vehicle_Routing| ,  video games,  |natural_resource_management|Natural_Resource_Management|    and  |medicine|Medicine|   because of ANNs ability to mitigate losses of accuracy even when reducing the discretization grid density for numerically approximating the solution of control problems. Tasks that fall within the paradigm of reinforcement learning are control problems,  |games|Game|  and other sequential decision making tasks.         Self learning in neural networks was introduced in 1982 along with a neural network capable of self-learning named Crossbar Adaptive Array . Bozinovski, S. . A self learning system using secondary reinforcement . In R. Trappl Cybernetics and Systems Research: Proceedings of the Sixth European Meeting on Cybernetics and Systems Research. North Holland. pp. 397–402. . It is a system with only one input, situation s, and only one output, action a. It has neither external advice input nor external reinforcement input from the environment. The CAA computes, in a crossbar fashion, both decisions about actions and emotions about encountered situations. The system is driven by the interaction between cognition and emotion. Bozinovski, S. Modeling mechanisms of cognition-emotion interaction in artificial neural networks, since 1981. Procedia Computer Science p. 255-263 Given memory matrix W   w  , the crossbar self learning algorithm in each iteration performs the following computation:   In situation s perform action a;   Receive consequence situation s’;   Compute emotion of being in consequence situation v;   Update crossbar memory w’ w + v.     The backpropagated value is the emotion toward the consequence situation. The CAA exists in two environments, one is behavioral environment where it behaves, and the other is genetic environment, where from it initially and only once receives initial emotions about to be encountered situations in the behavioral environment. Having received the genome vector from the genetic environment, the CAA will learn a goal-seeking behavior, in the behavioral environment that contains both desirable and undesirable situations. Bozinovski, Stevo and Bozinovska, Liljana. Self-learning agents: A connectionist theory of emotion based on crossbar value judgment. Cybernetics and Systems 32 637-667.       In a  |Bayesian|Bayesian_Probability|  framework, a distribution over the set of allowed models is chosen to minimize the cost.  |Evolutionary_methods|Evolutionary_Methods| ,   |gene_expression_programming|Gene_Expression_Programming| ,   |simulated_annealing|Simulated_Annealing| ,   |expectation-maximization|Expectation-Maximization| ,  |non-parametric_methods|Non-Parametric_Methods|  and  |particle_swarm_optimization|Particle_Swarm_Optimization|   are other learning algorithms. Convergent recursion is a learning algorithm for  |cerebellar_model_articulation_controller|Cerebellar_Model_Articulation_Controller|  neural networks. Ting Qin, et al. . Neural Processing Letters 19.1 : 49–61. Ting Qin, et al. . Neural Processing Letters 22.1 : 1–16.          Two modes of learning are available:  |stochastic|Stochastic_Gradient_Descent|  and batch. In stochastic learning, each input creates a weight adjustment. In batch learning weights are adjusted based on a batch of inputs, accumulating errors over the batch. Stochastic learning introduces noise into the process, using the local gradient calculated from one data point; this reduces the chance of the network getting stuck in local minima. However, batch learning typically yields a faster, more stable descent to a local minimum, since each update is performed in the direction of the batchs average error. A common compromise is to use mini-batches , small batches with samples in each batch selected stochastically from the entire data set.               ANNs have evolved into a broad family of techniques that have advanced the state of the art across multiple domains. The simplest types have one or more static components, including number of units, number of layers, unit weights and  |topology|Topology| . Dynamic types allow one or more of these to evolve via learning. The latter are much more complicated, but can shorten learning periods and produce better results. Some types allow/require learning to be supervised by the operator, while others operate independently. Some types operate purely in hardware, while others are purely software and run on general purpose computers.     Some of the main breakthroughs include:  |convolutional_neural_networks|Convolutional_Neural_Network|  that have proven particularly successful in processing visual and other two-dimensional data; LeCun et al., Backpropagation Applied to Handwritten Zip Code Recognition, Neural Computation, 1, pp. 541–551, 1989.  |Yann_LeCun|Yann_Lecun|  . Slides on Deep Learning  long short-term memory avoid the  |vanishing_gradient_problem|Vanishing_Gradient_Problem|   and can handle signals that have a mix of low and high frequency components aiding large-vocabulary speech recognition,   text-to-speech synthesis,   and photo-real talking heads;  competitive networks such as  |generative_adversarial_networks|Generative_Adversarial_Network| |in|Reinforcement_Learning|  which multiple networks compete with each other, on tasks such as winning a game  or on deceiving the opponent about the authenticity of an input.           Neural architecture search uses machine learning to automate ANN design. Various approaches to NAS have designed networks that compare well with hand-designed systems. The basic search algorithm is to propose a candidate model, evaluate it against a dataset and use the results as feedback to teach the NAS network.  Available systems include  |AutoML|Automated_Machine_Learning|  and AutoKeras.      Design issues include deciding the number, type and connectedness of network layers, as well as the size of each and the connection type .      |Hyperparameters|Hyperparameter|  must also be defined as part of the design , governing matters such as how many neurons are in each layer, learning rate, step, stride, depth, receptive field and padding , etc.           Using Artificial neural networks requires an understanding of their characteristics.   Choice of model: This depends on the data representation and the application. Overly complex models slow learning.   Learning algorithm: Numerous trade-offs exist between learning algorithms. Almost any algorithm will work well with the correct  |hyperparameters|Hyperparameter|  for training on a particular data set. However, selecting and tuning an algorithm for training on unseen data requires significant experimentation.   Robustness: If the model, cost function and learning algorithm are selected appropriately, the resulting ANN can become robust.   ANN capabilities fall within the following broad categories:  |Function_approximation|Function_Approximation| , or  |regression_analysis|Regression_Analysis| , including  |time_series_prediction|Time_Seriesprediction_And_Forecasting| ,  |fitness_approximation|Fitness_Approximation|  and modeling.    |Classification|Statistical_Classification| , including  |pattern|Pattern_Recognition|  and sequence recognition,  |novelty_detection|Novelty_Detection|  and sequential decision making.    |Data_processing|Data_Processing| , including filtering, clustering,  |blind_source_separation|Blind_Source_Separation|  and compression.    |Robotics|Robotics| , including directing manipulators and  |prostheses|Prosthesis| .    |Control|Control_Engineering| , including  |computer_numerical_control|Computer_Numerical_Control| .       Because of their ability to reproduce and model nonlinear processes, Artificial neural networks have found applications in many disciplines. Application areas include  |system_identification|System_Identification|  and control ,  |quantum_chemistry|Quantum_Chemistry| ,   |general_game_playing|General_Game_Playing| , Silver, David, et al. . Nature 529.7587 : 484.  |pattern_recognition|Pattern_Recognition|  , sequence recognition ,  |medical_diagnosis|Medical_Diagnosis| , finance  ,  |data_mining|Data_Mining| , visualization,  |machine_translation|Machine_Translation| , social network filtering  and  |e-mail_spam|E-Mail_Spam|  filtering. ANNs have been used to diagnose cancers, including  |lung_cancer|Lung_Cancer| ,   |prostate_cancer|Prostate_Cancer| ,  |colorectal_cancer|Colorectal_Cancer|   and to distinguish highly invasive cancer cell lines from less invasive lines using only cell shape information.       ANNs have been used to accelerate reliability analysis of infrastructures subject to natural disasters   and to predict foundation settlements.  ANNs have also been used for building black-box models in  |geoscience|Geoscience| |hydrology|Hydrology| ,   ocean modelling and  |coastal_engineering|Coastal_Engineering| ,   and  |geomorphology|Geomorphology| .  ANNs have been employed in  |cybersecurity|Computer_Security| , with the objective to discriminate between legitimate activities and malicious ones. For example, machine learning has been used for classifying Android malware,  for identifying domains belonging to threat actors  and for detecting URLs posing a security risk.  Research is underway on ANN systems designed for penetration testing,  for detecting botnets,  credit cards frauds  and network intrusions.     ANNs have been proposed as a tool to simulate the properties of many-body  |open_quantum_systems|Open_Quantum_System| .     In brain research ANNs have studied short-term behavior of  |individual_neurons|Biological_Neuron_Models| ,  /ref  ref  /ref  ref  /ref  math /math section end theory /  ref name Qin1 / ref  /ref  ref  /ref  ref  /ref ref  /ref  ref name VanEssen1991  /ref ref name Weng2012  /ref ref name :0  /ref  ref  /ref  ref  /ref  ref  /ref ref  /ref ref /ref ref  .