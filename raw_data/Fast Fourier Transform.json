[
    {
        "           A fast Fourier transform  is an ": null
    },
    {
        "algorithm": "Algorithm"
    },
    {
        " that computes the ": null
    },
    {
        "discrete Fourier transform": "Discrete Fourier Transform"
    },
    {
        " of a sequence, or its inverse . ": null
    },
    {
        "Fourier analysis": "Fourier Analysis"
    },
    {
        " converts a signal from its original domain to a representation in the ": null
    },
    {
        "frequency domain": "Frequency Domain"
    },
    {
        " and vice versa. The DFT is obtained by decomposing a ": null
    },
    {
        "sequence": "Sequence"
    },
    {
        " of values into components of different frequencies. This operation is useful in many fields, but computing it directly from the definition is often too slow to be practical. An FFT rapidly computes such transformations by ": null
    },
    {
        "factorizing": "Matrix Decomposition"
    },
    {
        " the ": null
    },
    {
        "DFT matrix": "Dft Matrix"
    },
    {
        " into a product of ": null
    },
    {
        "sparse": "Sparse Matrix"
    },
    {
        " factors. As a result, it manages to reduce the ": null
    },
    {
        "complexity": "Computational Complexity Theory"
    },
    {
        " of computing the DFT from O  , which arises if one simply applies the definition of DFT, to O , where N is the data size. The difference in speed can be enormous, especially for long data sets where N may be in the thousands or millions. In the presence of ": null
    },
    {
        "round-off error": "Round-Off Error"
    },
    {
        ", many FFT algorithms are much more accurate than evaluating the DFT definition directly or indirectly. There are many different FFT algorithms based on a wide range of published theories, from simple ": null
    },
    {
        "complex-number arithmetic": "Complex Number"
    },
    {
        " to ": null
    },
    {
        "group theory": "Group Theory"
    },
    {
        " and ": null
    },
    {
        "number theory": "Number Theory"
    },
    {
        ".     Fast Fourier transforms are widely used for ": null
    },
    {
        "applications": "Discrete Fourier Transformapplications"
    },
    {
        " in engineering, music, science, and mathematics. The basic ideas were popularized in 1965, but some algorithms had been derived as early as 1805. In 1994, ": null
    },
    {
        "Gilbert Strang": "Gilbert Strang"
    },
    {
        " described the FFT as the most important ": null
    },
    {
        "numerical algorithm": "Numerical Analysis"
    },
    {
        " of our lifetime , and it was included in Top 10 Algorithms of 20th Century by the ": null
    },
    {
        "IEEE": "Ieee"
    },
    {
        " magazine Computing in Science & Engineering.     The best-known FFT algorithms depend upon the ": null
    },
    {
        "factorization": "Factorization"
    },
    {
        " of N, but there are FFTs with ": null
    },
    {
        "O": "Big O Notation"
    },
    {
        " complexity": "Computational Complexity Theory"
    },
    {
        " for all N, even for ": null
    },
    {
        "prime": "Prime Number"
    },
    {
        "  N. Many FFT algorithms only depend on the fact that e is an N-th ": null
    },
    {
        "primitive root of unity": "Primitive Root Of Unity"
    },
    {
        ", and thus can be applied to analogous transforms over any ": null
    },
    {
        "finite field": "Finite Field"
    },
    {
        ", such as ": null
    },
    {
        "number-theoretic transforms": "Number-Theoretic Transform"
    },
    {
        ". Since the inverse DFT is the same as the DFT, but with the opposite sign in the exponent and a 1/N factor, any FFT algorithm can easily be adapted for it.       The development of fast algorithms for DFT can be traced to ": null
    },
    {
        "Carl Friedrich Gausss": "Carl Friedrich Gauss"
    },
    {
        " unpublished work in 1805 when he needed it to interpolate the orbit of asteroids ": null
    },
    {
        "Pallas": "2 Pallas"
    },
    {
        " and ": null
    },
    {
        "Juno": "3 Juno"
    },
    {
        " from sample observations. His method was very similar to the one published in 1965 by ": null
    },
    {
        "James Cooley": "James Cooley"
    },
    {
        " and ": null
    },
    {
        "John Tukey": "John Tukey"
    },
    {
        ", who are generally credited for the invention of the modern generic FFT algorithm. While Gausss work predated even ": null
    },
    {
        "Joseph Fouriers": "Joseph Fourier"
    },
    {
        " results in 1822, he did not analyze the computation time and eventually used other methods to achieve his goal.     Between 1805 and 1965, some versions of FFT were published by other authors. ": null
    },
    {
        "Frank Yates": "Frank Yates"
    },
    {
        " in 1932 published his version called interaction algorithm, which provided efficient computation of ": null
    },
    {
        "Hadamard and Walsh transforms": "Hadamard Transform"
    },
    {
        ". Yates algorithm is still used in the field of statistical design and analysis of experiments. In 1942, ": null
    },
    {
        "G. C. Danielson": "G. C. Danielson"
    },
    {
        " and ": null
    },
    {
        "Cornelius Lanczos": "Cornelius Lanczos"
    },
    {
        " published their version to compute DFT for ": null
    },
    {
        "x-ray crystallography": "X-Ray Crystallography"
    },
    {
        ", a field where calculation of Fourier transforms presented a formidable bottleneck. While many methods in the past had focused on reducing the constant factor for O  computation by taking advantage of symmetries , Danielson and Lanczos realized that one could use the periodicity and apply a doubling trick to get O runtime.     James Cooley and John Tukey published a ": null
    },
    {
        "more general version of FFT": "Cooley–Tukey Fft Algorithm"
    },
    {
        " in 1965 that is applicable when N is composite and not necessarily a power of 2. Tukey came up with the idea during a meeting of ": null
    },
    {
        "President Kennedys": "President Kennedy"
    },
    {
        " Science Advisory Committee where a discussion topic involved detecting nuclear tests by the Soviet Union by setting up sensors to surround the country from outside. To analyze the output of these sensors, an FFT algorithm would be needed. In discussion with Tukey, ": null
    },
    {
        "Richard Garwin": "Richard Garwin"
    },
    {
        " recognized the general applicability of the algorithm not just to national security problems, but also to a wide range of problems including one of immediate interest to him, determining the periodicities of the spin orientations in a 3-D crystal of Helium-3. Garwin gave Tukeys idea to Cooley  for implementation. Cooley and Tukey published the paper in a relatively short time of six months. As Tukey did not work at IBM, the patentability of the idea was doubted and the algorithm went into the public domain, which, through the computing revolution of the next decade, made FFT one of the indispensable algorithms in digital signal processing.       Let x 0 , …, x N−1 be ": null
    },
    {
        "complex numbers": "Complex Number"
    },
    {
        ". The ": null
    },
    {
        "DFT": "Discrete Fourier Transform"
    },
    {
        " is defined by the formula     : Xk   xn e   k 0,      where e is a ": null
    },
    {
        "primitive": "Primitive Root Of Unity"
    },
    {
        " th root of 1.     Evaluating this definition directly requires O  operations: there are N outputs X k , and each output requires a sum of N terms. An FFT is any method to compute the same results in O operations. All known FFT algorithms require ": null
    },
    {
        "Θ": "Big O Notationuse In Computer Science"
    },
    {
        " operations, although there is no known proof that a lower complexity score is impossible.     To illustrate the savings of an FFT, consider the count of complex multiplications and additions for N4096 data points. Evaluating the DFTs sums directly involves N 2 complex multiplications and N complex additions, of which O operations can be saved by eliminating trivial operations such as multiplications by 1, leaving about 30 million operations. On the other hand, the radix-2 ": null
    },
    {
        "Cooley–Tukey algorithm": "Cooley–Tukey Algorithm"
    },
    {
        ", for N a power of 2, can compute the same result with only log 2  complex multiplications and N  log 2  complex additions, in total about 30,000 operations - a thousand times less than with direct evaluation. In practice, actual performance on modern computers is usually dominated by factors other than the speed of arithmetic operations and the analysis is a complicated subject , but the overall improvement from O  to O remains.                By far the most commonly used FFT is the Cooley–Tukey algorithm. This is a ": null
    },
    {
        "divide and conquer algorithm": "Divide And Conquer Algorithm"
    },
    {
        " that ": null
    },
    {
        "recursively": "Recursion"
    },
    {
        " breaks down a DFT of any ": null
    },
    {
        "composite": "Composite Number"
    },
    {
        " size N N 1 N 2 into many smaller DFTs of sizes N 1 and N 2 , along with O multiplications by complex ": null
    },
    {
        "roots of unity": "Roots Of Unity"
    },
    {
        " traditionally called ": null
    },
    {
        "twiddle factors": "Twiddle Factor"
    },
    {
        " .     This method was popularized by a publication of Cooley and Tukey in 1965, but it was later discovered that those two authors had independently re-invented an algorithm known to ": null
    },
    {
        "Carl Friedrich Gauss": "Carl Friedrich Gauss"
    },
    {
        " around 1805 .     The best known use of the Cooley–Tukey algorithm is to divide the transform into two pieces of size N/2 at each step, and is therefore limited to power-of-two sizes, but any factorization can be used in general . These are called the radix-2 and mixed-radix cases, respectively . Although the basic idea is recursive, most traditional implementations rearrange the algorithm to avoid explicit recursion. Also, because the Cooley–Tukey algorithm breaks the DFT into smaller DFTs, it can be combined arbitrarily with any other algorithm for the DFT, such as those described below.            There are FFT algorithms other than Cooley–Tukey. ": null
    },
    {
        "Cornelius Lanczos": "Cornelius Lanczos"
    },
    {
        " did pioneering work on the FFT and FFS  with ": null
    },
    {
        "G. C. Danielson": "G. C. Danielson"
    },
    {
        " .     For N N 1 N 2 with ": null
    },
    {
        "coprime": "Coprime"
    },
    {
        " N 1 and N 2 , one can use the ": null
    },
    {
        "prime-factor": "Prime-Factor Fft Algorithm"
    },
    {
        " algorithm , based on the ": null
    },
    {
        "Chinese remainder theorem": "Chinese Remainder Theorem"
    },
    {
        ", to factorize the DFT similarly to Cooley–Tukey but without the twiddle factors. The Rader–Brenner algorithm is a Cooley–Tukey-like factorization but with purely imaginary twiddle factors, reducing multiplications at the cost of increased additions and reduced ": null
    },
    {
        "numerical stability": "Numerical Stability"
    },
    {
        "; it was later superseded by the ": null
    },
    {
        "split-radix": "Split-Radix Fft Algorithm"
    },
    {
        " variant of Cooley–Tukey . Algorithms that recursively factorize the DFT into smaller operations other than DFTs include the Bruun and ": null
    },
    {
        "QFT": "Quick Fourier Transform Algorithm"
    },
    {
        " algorithms.  ": null
    },
    {
        "Bruuns algorithm": "Bruuns Fft Algorithm"
    },
    {
        ", in particular, is based on interpreting the FFT as a recursive factorization of the ": null
    },
    {
        "polynomial": "Polynomial"
    },
    {
        " z N  −  1, here into real-coefficient polynomials of the form z M  −  1 and z 2M  +  az M  +  1.     Another polynomial viewpoint is exploited by the Winograd FFT algorithm, which factorizes z N  −  1 into ": null
    },
    {
        "cyclotomic polynomials": "Cyclotomic Polynomial"
    },
    {
        "—these often have coefficients of 1,  0,  or  −1, and therefore require few multiplications, so Winograd can be used to obtain minimal-multiplication FFTs and is often used to find efficient algorithms for small factors. Indeed, Winograd showed that the DFT can be computed with only O irrational multiplications, leading to a proven achievable lower bound on the number of multiplications for power-of-two sizes; unfortunately, this comes at the cost of many more additions, a tradeoff no longer favorable on modern ": null
    },
    {
        "processors": "Central Processing Unit"
    },
    {
        " with ": null
    },
    {
        "hardware multipliers": "Floating-Point Unit"
    },
    {
        ". In particular, Winograd also makes use of the PFA as well as an algorithm by Rader for FFTs of prime sizes.     ": null
    },
    {
        "Raders algorithm": "Raders Fft Algorithm"
    },
    {
        ", exploiting the existence of a ": null
    },
    {
        "generator": "Generating Set Of A Group"
    },
    {
        " for the multiplicative ": null
    },
    {
        "group": "Group"
    },
    {
        " modulo prime N, expresses a DFT of prime size N as a cyclic ": null
    },
    {
        "convolution": "Convolution"
    },
    {
        " of size N − 1, which can then be computed by a pair of ordinary FFTs via the ": null
    },
    {
        "convolution theorem": "Convolution Theorem"
    },
    {
        " . Another prime-size FFT is due to L. I. Bluestein, and is sometimes called the ": null
    },
    {
        "chirp-z algorithm": "Chirp-Z Algorithm"
    },
    {
        "; it also re-expresses a DFT as a convolution, but this time of the same size , via the identity     : nk -  2 +   2 +   2.     ": null
    },
    {
        "Hexagonal Fast Fourier Transform": "Hexagonal Fast Fourier Transform"
    },
    {
        " aims at computing an efficient FFT for the hexagonally sampled data by using a new addressing scheme for hexagonal grids, called Array Set Addressing .       In many applications, the input data for the DFT are purely real, in which case the outputs satisfy the symmetry     : X Xk     and efficient FFT algorithms have been designed for this situation . One approach consists of taking an ordinary algorithm and removing the redundant parts of the computation, saving roughly a factor of two in time and memory. Alternatively, it is possible to express an even-length real-input DFT as a complex DFT of half the length , followed by O post-processing operations.     It was once believed that real-input DFTs could be more efficiently computed by means of the ": null
    },
    {
        "discrete Hartley transform": "Discrete Hartley Transform"
    },
    {
        " , but it was subsequently argued that a specialized real-input DFT algorithm can typically be found that requires fewer operations than the corresponding DHT algorithm for the same number of inputs. Bruuns algorithm is another method that was initially proposed to take advantage of real inputs, but it has not proved popular.     There are further FFT specializations for the cases of real data that have ": null
    },
    {
        "even/odd": "Even And Odd Functions"
    },
    {
        " symmetry, in which case one can gain another factor of roughly two in time and memory and the DFT becomes the ": null
    },
    {
        "discrete cosine": "Discrete Cosine Transform"
    },
    {
        "/": null
    },
    {
        "sine transform": "Discrete Sine Transform"
    },
    {
        " . Instead of directly modifying an FFT algorithm for these cases, DCTs/DSTs can also be computed via FFTs of real data combined with O pre- and post-processing.              A fundamental question of longstanding theoretical interest is to prove lower bounds on the ": null
    },
    {
        "complexity": "Computational Complexity Theory"
    },
    {
        " and exact operation counts of fast Fourier transforms, and many open problems remain. It is not even rigorously proved whether DFTs truly require Ω  operations, even for the simple case of ": null
    },
    {
        "power of two": "Power Of Two"
    },
    {
        " sizes, although no algorithms with lower complexity are known. In particular, the count of arithmetic operations is usually the focus of such questions, although actual performance on modern-day computers is determined by many other factors such as ": null
    },
    {
        "cache": "Cache"
    },
    {
        " or ": null
    },
    {
        "CPU pipeline": "Pipeline"
    },
    {
        " optimization.     Following work by ": null
    },
    {
        "Shmuel Winograd": "Shmuel Winograd"
    },
    {
        " , a tight Θ lower bound is known for the number of real multiplications required by an FFT. It can be shown that only 4N - 2  - 2  - 4 irrational real multiplications are required to compute a DFT of power-of-two length N 2m . Moreover, explicit algorithms that achieve this count are known . However, these algorithms require too many additions to be practical, at least on modern computers with hardware multipliers .     A tight lower bound is not known on the number of required additions, although lower bounds have been proved under some restrictive assumptions on the algorithms. In 1973, Morgenstern proved an Ω lower bound on the addition count for algorithms where the multiplicative constants have bounded magnitudes . This result, however, applies only to the unnormalized Fourier transform , and does not explain why the Fourier matrix is harder to compute than any other unitary matrix under the same scaling. ": null
    },
    {
        "Pan": "Victor Pan"
    },
    {
        " proved an Ω lower bound assuming a bound on a measure of the FFT algorithms asynchronicity , but the generality of this assumption is unclear. For the case of power-of-two N, ": null
    },
    {
        "Papadimitriou": "Christos Papadimitriou"
    },
    {
        " argued that the number N   N of complex-number additions achieved by Cooley–Tukey algorithms is optimal under certain assumptions on the ": null
    },
    {
        "graph": "Graph"
    },
    {
        " of the algorithm . Thus far, no published FFT algorithm has achieved fewer than N   N complex-number additions for power-of-two  N.     A third problem is to minimize the total number of real multiplications and additions, sometimes called the arithmetic complexity . Again, no tight lower bound has been proven. Since 1968, however, the lowest published count for power-of-two N was long achieved by the ": null
    },
    {
        "split-radix FFT algorithm": "Split-Radix Fft Algorithm"
    },
    {
        ", which requires 4N  - 6N + 8 real multiplications and additions for N math /math  ref name Haynal2011 /  ref name DuhamelVetterli1990 /  ref name EdelmanMcCorquodaleToledo1999 /  ref name GuoBurrus1996 / ref name ShentovMitraHeuteHossen1995 /  ": null
    }
]