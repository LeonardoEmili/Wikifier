     A database is an organized collection of  |data|Data| , generally stored and accessed electronically from a computer system. Where databases are more complex they are often developed using formal  |design_and_modeling|Design_And_Modeling|  techniques.     The  |database_management_system|Database_Management_System|  is the  |software|Software|  that interacts with  |end_users|End_User| , applications, and the database itself to capture and analyze the data. The DBMS software additionally encompasses the core facilities provided to administer the database. The sum total of the database, the DBMS and the associated applications can be referred to as a database system . Often the term database is also used to loosely refer to any of the DBMS, the database system or an application associated with the database.     Computer scientists may classify database-management systems according to the  |database_models|Database_Model|  that they support.  |Relational_databases|Relational_Database|  became dominant in the 1980s. These model data as  |rows|Row|  and  |columns|Column|  in a series of  |tables|Table| , and the vast majority use  |SQL|Sql|  for writing and querying data. In the 2000s, non-relational databases became popular, referred to as  |NoSQL|Nosql|  because they use different  |query_languages|Query_Language| .         Formally, a database refers to a set of related data and the way it is organized. Access to this data is usually provided by a database management system consisting of an integrated set of computer software that allows  |users|User|  to interact with one or more databases and provides access to all of the data contained in the database . The DBMS provides various functions that allow entry, storage and retrieval of large quantities of information and provides ways to manage how that information is organized.     Because of the close relationship between them, the term database is often used casually to refer to both a database and the DBMS used to manipulate it.     Outside the world of professional  |information_technology|Information_Technology| , the term database is often used to refer to any collection of related data  as size and usage requirements typically necessitate use of a database management system.     Existing DBMSs provide various functions that allow management of a database and its data which can be classified into four main functional groups:     Data definition – Creation, modification and removal of definitions that define the organization of the data.   Update – Insertion, modification, and deletion of the actual data.    Retrieval – Providing information in a form directly usable or for further processing by other applications. The retrieved data may be made available in a form basically the same as it is stored in the database or in a new form obtained by altering or combining existing data from the database.    Administration – Registering and monitoring users, enforcing data security, monitoring performance, maintaining data integrity, dealing with concurrency control, and recovering information that has been corrupted by some event such as an unexpected system failure.      Both a database and its DBMS conform to the principles of a particular  |database_model|Database_Model| . Database system refers collectively to the database model, database management system, and database.     Physically, database  |servers|Server|  are dedicated computers that hold the actual databases and run only the DBMS and related software. Database servers are usually  |multiprocessor|Multiprocessor|  computers, with generous memory and  |RAID|Redundant_Array_Of_Independent_Disks|  disk arrays used for stable storage. RAID is used for recovery of data if any of the disks fail. Hardware database accelerators, connected to one or more servers via a high-speed channel, are also used in large volume transaction processing environments. DBMSs are found at the heart of most  |database_applications|Database_Application| . DBMSs may be built around a custom  |multitasking|Computer_Multitasking| |_kernel|Kernel|  with built-in  |networking|Computer_Network|  support, but modern DBMSs typically rely on a standard  |operating_system|Operating_System|  to provide these functions.     Since DBMSs comprise a significant  |market|Market| , computer and storage vendors often take into account DBMS requirements in their own development plans.     Databases and DBMSs can be categorized according to the database model that they support , the type of computer they run on , the  |query_language|Query_Language|  used to access the database , and their internal engineering, which affects performance,  |scalability|Scalability| , resilience, and security.         The sizes, capabilities, and performance of databases and their respective DBMSs have grown in orders of magnitude. These performance increases were enabled by the technology progress in the areas of  |processors|Central_Processing_Unit| ,  |computer_memory|Computer_Memory| ,  |computer_storage|Computer_Data_Storage| , and  |computer_networks|Computer_Network| . The development of database technology can be divided into three eras based on data model or structure:  |navigational|Navigational_Database| , SQL/ |relational|Relational_Database| , and post-relational.     The two main early navigational data models were the  |hierarchical_model|Hierarchical_Database_Model|  and the  |CODASYL|Codasyl|  model      The  |relational_model|Relational_Model| , first proposed in 1970 by  |Edgar_F_Codd|Edgar_F_Codd| , departed from this tradition by insisting that applications should search for data by content, rather than by following links. The relational model employs sets of ledger-style tables, each used for a different type of entity. Only in the mid-1980s did computing hardware become powerful enough to allow the wide deployment of relational systems . By the early 1990s, however, relational systems dominated in all large-scale  |data_processing|Data_Processing|  applications, and  they remain dominant:  |IBM_DB2|Ibm_Db2| ,  |Oracle|Oracle_Database| ,  |MySQL|Mysql| , and  |Microsoft_SQL_Server|Microsoft_Sql_Server|  are the most searched  |DBMS|Dbms| .  The dominant database language, standardised SQL for the relational model, has influenced database languages for other data models.      |Object_databases|Object_Database|  were developed in the 1980s to overcome the inconvenience of  |object_relational_impedance_mismatch|Object_Relational_Impedance_Mismatch| , which led to the coining of the term post-relational and also the development of hybrid  |object_relational_databases|Object_Relational_Database| .     The next generation of post-relational databases in the late 2000s became known as  |NoSQL|Nosql|  databases, introducing fast  |key_value_stores|Key_Value_Store|  and  |document_oriented_databases|Document_Oriented_Database| . A competing next generation known as  |NewSQL|Newsql|  databases attempted new implementations that retained the relational/SQL model while aiming to match the high performance of NoSQL compared to commercially available relational DBMSs.               The introduction of the term database coincided with the availability of direct-access storage from the mid-1960s onwards. The term represented a contrast with the tape-based systems of the past, allowing shared interactive use rather than daily  |batch_processing|Batch_Processing| . The  |Oxford_English_Dictionary|Oxford_English_Dictionary|  cites a 1962 report by the System Development Corporation of California as the first to use the term data-base in a specific technical sense.       As computers grew in speed and capability, a number of general-purpose database systems emerged; by the mid-1960s a number of such systems had come into commercial use. Interest in a standard began to grow, and  |Charles_Bachman|Charles_Bachman| , author of one such product, the  |Integrated_Data_Store|Integrated_Data_Store|  , founded the Database Task Group within  |CODASYL|Codasyl| , the group responsible for the creation and standardization of  |COBOL|Cobol| . In 1971, the Database Task Group delivered their standard, which generally became known as the CODASYL approach , and soon a number of commercial products based on this approach entered the market.     The CODASYL approach relied on the manual navigation of a linked data set which was formed into a large network. Applications could find records by one of three methods:   Use of a primary key    Navigating relationships from one record to another   Scanning all the records in a sequential order     Later systems added  |B_trees|B_Tree|  to provide alternate access paths. Many CODASYL databases also added a very straightforward query language. However, in the final tally, CODASYL was very complex and required significant training and effort to produce useful applications.      |IBM|International_Business_Machines|  also had their own DBMS in 1966, known as  |Information_Management_System|Ibm_Information_Management_System|  . IMS was a development of software written for the  |Apollo_program|Apollo_Program|  on the  |System_360|System_360| . IMS was generally similar in concept to CODASYL, but used a strict hierarchy for its model of data navigation instead of CODASYLs network model. Both concepts later became known as navigational databases due to the way data was accessed, and Bachmans 1973  |Turing_Award|Turing_Award|  presentation was The Programmer as Navigator. IMS is classified by IBM as a  |hierarchical_database|Hierarchical_Database| . IDMS and  |Cincom_Systems|Cincom_Systems| |_TOTAL|Cincom_Systems1970S|  database are classified as network databases. IMS remains in use .         |Edgar_F_Codd|Edgar_F_Codd|  worked at IBM in  |San_Jose_California|San_Jose_California| , in one of their offshoot offices that was primarily involved in the development of  |hard_disk|Hard_Disk|  systems. He was unhappy with the navigational model of the CODASYL approach, notably the lack of a search facility. In 1970, he wrote a number of papers that outlined a new approach to database construction that eventually culminated in the groundbreaking A Relational Model of Data for Large Shared Data Banks.     In this paper, he described a new system for storing and working with large databases. Instead of records being stored in some sort of  |linked_list|Linked_List|  of free-form records as in CODASYL, Codds idea was to use a  |table|Table|  of fixed-length records, with each table used for a different type of entity. A linked-list system would be very inefficient when storing sparse databases where some of the data for any one record could be left empty. The relational model solved this by splitting the data into a series of normalized tables , with optional elements being moved out of the main table to where they would take up room only if needed. Data may be freely inserted, deleted and edited in these tables, with the DBMS doing whatever maintenance needed to present a table view to the application/user.        	   The relational model also allowed the content of the database to evolve without constant rewriting of links and pointers. The relational part comes from entities referencing other entities in what is known as one-to-many relationship, like a traditional hierarchical model, and many-to-many relationship, like a navigational model. Thus, a relational model can express both hierarchical and navigational models, as well as its native tabular model, allowing for pure or combined modeling in terms of these three models, as the application requires.     For instance, a common use of a database system is to track information about users, their name, login information, various addresses and phone numbers. In the navigational approach, all of this data would be placed in a single record, and unused items would simply not be placed in the database. In the relational approach, the data would be normalized into a user table, an address table and a phone number table . Records would be created in these optional tables only if the address or phone numbers were actually provided.     Linking the information back together is the key to this system. In the relational model, some bit of information was used as a  |key|Primary_Key|  , uniquely defining a particular record. When information was being collected about a user, information stored in the optional tables would be found by searching for this key. For instance, if the login name of a user is unique, addresses and phone numbers for that user would be recorded with the login name as its key. This simple re-linking of related data back into a single collection is something that traditional computer languages are not designed for.     Just as the navigational approach would require programs to loop in order to collect records, the relational approach would require loops to collect information about any one record. Codds suggestions was a set-oriented language, that would later spawn the ubiquitous  |SQL|Sql| . Using a branch of mathematics known as  |tuple_calculus|Tuple_Calculus| , he demonstrated that such a system could support all the operations of normal databases as well as providing a simple system for finding and returning sets of data in a single operation.     Codds paper was picked up by two people at Berkeley, Eugene Wong and  |Michael_Stonebraker|Michael_Stonebraker| . They started a project known as  |INGRES|Ingres|  using funding that had already been allocated for a geographical database project and student programmers to produce code. Beginning in 1973, INGRES delivered its first test products which were generally ready for widespread use in 1979. INGRES was similar to  |System_R|Ibm_System_R|  in a number of ways, including the use of a language for  |data_access|Data_Access| , known as  |QUEL|Quel_Query_Languages| . Over time, INGRES moved to the emerging SQL standard.     IBM itself did one test implementation of the relational model,  |PRTV|Prtv| , and a production one,  |Business_System_12|Business_System_12| , both now discontinued.  |Honeywell|Honeywell|  wrote  |MRDS|Multics_Relational_Data_Store|  for  |Multics|Multics| , and now there are two new implementations:  |Alphora_Dataphor|Dataphor|  and  |Rel|Rel| . Most other DBMS implementations usually called relational are actually SQL DBMSs.     In 1970, the University of Michigan began development of the  |MICRO_Information_Management_System|Micro_Relational_Database_Management_System|  based on D.L. Childs Set-Theoretic Data model. MICRO was used to manage very large data sets by the  |US_Department_of_Labor|Us_Department_Of_Labor| , the  |U_S_Environmental_Protection_Agency|U_S_Environmental_Protection_Agency| , and researchers from the  |University_of_Alberta|University_Of_Alberta| , the  |University_of_Michigan|University_Of_Michigan| , and  |Wayne_State_University|Wayne_State_University| . It ran on IBM mainframe computers using the  |Michigan_Terminal_System|Michigan_Terminal_System| . , M.A. Kahn, D.L. Rumelhart, and B.L. Bronson, October 1977, Institute of Labor and Industrial Relations , University of Michigan and Wayne State University The system remained in production until 1998.            In the 1970s and 1980s, attempts were made to build database systems with integrated hardware and software. The underlying philosophy was that such integration would provide higher performance at lower cost. Examples were IBM  |System_38|System_38| , the early offering of  |Teradata|Teradata| , and the  |Britton_Lee_Inc_|Britton_Lee_Inc_|  database machine.     Another approach to hardware support for database management was  |ICLs|International_Computers_Limited| |_CAFS|Content_Addressable_File_Store|  accelerator, a hardware disk controller with programmable search capabilities. In the long term, these efforts were generally unsuccessful because specialized database machines could not keep pace with the rapid development and progress of general-purpose computers. Thus most database systems nowadays are software systems running on general-purpose hardware, using general-purpose computer data storage. However this idea is still pursued for certain applications by some companies like  |Netezza|Netezza|  and Oracle .       IBM started working on a prototype system loosely based on Codds concepts as  System R  in the early 1970s. The first version was ready in 1974/5, and work then started on multi-table systems in which the data could be split so that all of the data for a record did not have to be stored in a single large chunk . Subsequent multi-user versions were tested by customers in 1978 and 1979, by which time a standardized  |query_language|Query_Language|  – SQL – had been added. Codds ideas were establishing themselves as both workable and superior to CODASYL, pushing IBM to develop a true production version of System R, known as SQL/DS, and, later, Database 2 .      |Larry_Ellisons|Larry_Ellison|  Oracle Database  started from a different chain, based on IBMs papers on System R. Though Oracle V1 implementations were completed in 1978, it wasnt until Oracle Version 2 when Ellison beat IBM to market in 1979.      Stonebraker went on to apply the lessons from INGRES to develop a new database, Postgres, which is now known as  |PostgreSQL|Postgresql| . PostgreSQL is often used for global mission critical applications .     In Sweden, Codds paper was also read and  |Mimer_SQL|Mimer_Sql|  was developed from the mid-1970s at  |Uppsala_University|Uppsala_University| . In 1984, this project was consolidated into an independent enterprise.     Another data model, the  |entity–relationship_model|Entity–Relationship_Model| , emerged in 1976 and gained popularity for  |database_design|Database_Design|  as it emphasized a more familiar description than the earlier relational model. Later on, entity–relationship constructs were retrofitted as a  |data_modeling|Data_Modeling|  construct for the relational model, and the difference between the two have become irrelevant.       The 1980s ushered in the age of  |desktop_computing|Desktop_Computer| . The new computers empowered their users with spreadsheets like  |Lotus_1_2_3|Lotus_1_2_3|  and database software like  |dBASE|Dbase| . The dBASE product was lightweight and easy for any computer user to understand out of the box.  |C_Wayne_Ratliff|C_Wayne_Ratliff| , the creator of dBASE, stated: dBASE was different from programs like BASIC, C, FORTRAN, and COBOL in that a lot of the dirty work had already been done. The data manipulation is done by dBASE instead of by the user, so the user can concentrate on what he is doing, rather than having to mess with the dirty details of opening, reading, and closing files, and managing space allocation. . The FoxPro History. Retrieved on 2013-07-12. dBASE was one of the top selling software titles in the 1980s and early 1990s.       The 1990s, along with a rise in  |object_oriented_programming|Object_Oriented_Programming| , saw a growth in how data in various databases were handled. Programmers and designers began to treat the data in their databases as  |objects|Object| . That is to say that if a persons data were in a database, that persons attributes, such as their address, phone number, and age, were now considered to belong to that person instead of being extraneous data. This allows for relations between data to be relations to objects and their  |attributes|Property|  and not to individual fields. Development of an object-oriented DBMS; Portland, Oregon, United States; Pages: 472–482; 1986;  The term  |object_relational_impedance_mismatch|Object_Relational_Impedance_Mismatch|  described the inconvenience of translating between programmed objects and database tables.  |Object_databases|Object_Database|  and  |object_relational_databases|Object_Relational_Database|  attempt to solve this problem by providing an object-oriented language that programmers can use as alternative to purely relational SQL. On the programming side, libraries known as  |object_relational_mappings|Object_Relational_Mapping|  attempt to solve the same problem.             |XML_databases|Xml_Databases|  are a type of structured document-oriented database that allows querying based on  |XML|Xml|  document attributes. XML databases are mostly used in applications where the data is conveniently viewed as a collection of documents, with a structure that can vary from the very flexible to the highly rigid: examples include scientific articles, patents, tax filings, and personnel records.      |NoSQL|Nosql|  databases are often very fast, do not require fixed table schemas, avoid join operations by storing  |denormalized|Denormalization|  data, and are designed to  |scale_horizontally|Horizontal_Scaling| .     In recent years, there has been a strong demand for massively distributed databases with high partition tolerance, but according to the  |CAP_theorem|Cap_Theorem|  it is impossible for a  |distributed_system|Distributed_Computing|  to simultaneously provide  |consistency|Consistency_Model| , availability, and partition tolerance guarantees. A distributed system can satisfy any two of these guarantees at the same time, but not all three. For that reason, many NoSQL databases are using what is called  |eventual_consistency|Eventual_Consistency|  to provide both availability and partition tolerance guarantees with a reduced level of data consistency.      |NewSQL|Newsql|  is a class of modern relational databases that aims to provide the same scalable performance of NoSQL systems for online transaction processing workloads while still using SQL and maintaining the  |ACID|Acid|  guarantees of a traditional database system.            Databases are used to support internal operations of organizations and to underpin online interactions with customers and suppliers .     Databases are used to hold administrative information and more specialized data, such as engineering data or economic models. Examples include computerized  |library|Library|  systems,  |flight_reservation_systems|Flight_Reservation_System| , computerized  |parts_inventory_systems|Parts_Inventory_System| , and many  |content_management_systems|Content_Management_System|  that store  |websites|Website|  as collections of webpages in a database.       One way to classify databases involves the type of their contents, for example:  |bibliographic|Bibliographic_Database| , document-text, statistical, or multimedia objects. Another way is by their application area, for example: accounting, music compositions, movies, banking, manufacturing, or insurance. A third way is by some technical aspect, such as the database structure or interface type. This section lists a few of the adjectives used to characterize different kinds of databases.     An  |in_memory_database|In_Memory_Database|  is a database that primarily resides in  |main_memory|Main_Memory| , but is typically backed-up by non-volatile computer data storage. Main memory databases are faster than disk databases, and so are often used where response time is critical, such as in telecommunications network equipment.   An  |active_database|Active_Database|  includes an event-driven architecture which can respond to conditions both inside and outside the database. Possible uses include security monitoring, alerting, statistics gathering and authorization. Many databases provide active database features in the form of  |database_triggers|Database_Trigger| .   A  |cloud_database|Cloud_Database|  relies on  |cloud_technology|Cloud_Computing| . Both the database and most of its DBMS reside remotely, in the cloud , while its applications are both developed by programmers and later maintained and used by end-users through a  |web_browser|Web_Browser|  and  |Open_APIs|Open_Api| .    |Data_warehouses|Data_Warehouse|  archive data from operational databases and often from external sources such as market research firms. The warehouse becomes the central source of data for use by managers and other end-users who may not have access to operational data. For example, sales data might be aggregated to weekly totals and converted from internal product codes to use  |UPCs|Universal_Product_Code|  so that they can be compared with  |ACNielsen|Acnielsen|  data. Some basic and essential components of data warehousing include extracting, analyzing, and  |mining|Data_Mining|  data, transforming, loading, and managing data so as to make them available for further use.   A  |deductive_database|Deductive_Database|  combines  |logic_programming|Logic_Programming|  with a relational database.   A  |distributed_database|Distributed_Database|  is one in which both the data and the DBMS span multiple computers.   A  |document_oriented_database|Document_Oriented_Database|  is designed for storing, retrieving, and managing document-oriented, or semi structured, information. Document-oriented databases are one of the main categories of NoSQL databases.   An  |embedded_database|Embedded_Database|  system is a DBMS which is tightly integrated with an application software that requires access to stored data in such a way that the DBMS is hidden from the applications end-users and requires little or no ongoing maintenance. Graves, Steve.  , Embedded Computing Design magazine, January 2007. Retrieved on August 13, 2008.   End-user databases consist of data developed by individual end-users. Examples of these are collections of documents, spreadsheets, presentations, multimedia, and other files. Several products exist to support such databases. Some of them are much simpler than full-fledged DBMSs, with more elementary DBMS functionality.   A  |federated_database_system|Federated_Database_System|  comprises several distinct databases, each with its own DBMS. It is handled as a single database by a federated database management system , which transparently integrates multiple autonomous DBMSs, possibly of different types , and provides them with an integrated conceptual view.   Sometimes the term multi-database is used as a synonym to federated database, though it may refer to a less integrated group of databases that cooperate in a single application. In this case, typically  |middleware|Middleware|  is used for distribution, which typically includes an atomic commit protocol , e.g., the  |two_phase_commit_protocol|Two_Phase_Commit_Protocol| , to allow  |distributed_transactions|Distributed_Transaction|  across the participating databases.   A  |graph_database|Graph_Database|  is a kind of NoSQL database that uses  |graph_structures|Graph|  with nodes, edges, and properties to represent and store information. General graph databases that can store any graph are distinct from specialized graph databases such as  |triplestores|Triplestore|  and  |network_databases|Network_Database_Model| .   An  |array_DBMS|Array_Dbms|  is a kind of NoSQL DBMS that allows modeling, storage, and retrieval of multi-dimensional  |arrays|Array_Data_Structure|  such as satellite images and climate simulation output.   In a  |hypertext|Hypertext|  or  |hypermedia|Hypermedia|  database, any word or a piece of text representing an object, e.g., another piece of text, an article, a picture, or a film, can be  |hyperlink|Hyperlink| ed to that object. Hypertext databases are particularly useful for organizing large amounts of disparate information. For example, they are useful for organizing  |online_encyclopedias|Online_Encyclopedia| , where users can conveniently jump around the text. The  |World_Wide_Web|World_Wide_Web|  is thus a large distributed hypertext database.   A  |knowledge_base|Knowledge_Base|   is a special kind of database for  |knowledge_management|Knowledge_Management| , providing the means for the computerized collection, organization, and  |retrieval|Information_Retrieval|  of  |knowledge|Knowledge| . Also a collection of data representing problems with their solutions and related experiences.     A  |mobile_database|Mobile_Database|  can be carried on or synchronized from a mobile computing device.    |Operational_databases|Operational_Database|  store detailed data about the operations of an organization. They typically process relatively high volumes of updates using  |transactions|Transaction| . Examples include  |customer_databases|Customer_Relationship_Management|  that record contact, credit, and demographic information about a businesss customers, personnel databases that hold information such as salary, benefits, skills data about employees,  |enterprise_resource_planning|Enterprise_Resource_Planning|  systems that record details about product components, parts inventory, and financial databases that keep track of the organizations money, accounting and financial dealings.   A  |parallel_database|Parallel_Database|  seeks to improve performance through  |parallelization|Parallel_Computing|  for tasks such as loading data, building indexes and evaluating queries.     ::The major parallel DBMS architectures which are induced by the underlying  |hardware|Computer_Hardware|  architecture are:   ::  Shared memory architecture , where multiple processors share the main memory space, as well as other data storage.   :: Shared disk architecture, where each processing unit has its own main memory, but all units share the other storage.   ::  Shared nothing architecture , where each processing unit has its own main memory and other storage.      |Probabilistic_databases|Probabilistic_Database|  employ  |fuzzy_logic|Fuzzy_Logic|  to draw inferences from imprecise data.    |Real_time_databases|Real_Time_Database|  process transactions fast enough for the result to come back and be acted on right away.   A  |spatial_database|Spatial_Database|  can store the data with multidimensional features. The queries on such data include location-based queries, like Where is the closest hotel in my area? .   A  |temporal_database|Temporal_Database|  has built-in time aspects, for example a temporal data model and a temporal version of SQL. More specifically the temporal aspects usually include valid-time and transaction-time.   A  |terminology_oriented_database|Terminology_Oriented_Database|  builds upon an  |object_oriented_database|Object_Oriented_Database| , often customized for a specific field.   An  |unstructured_data|Unstructured_Data|  database is intended to store in a manageable and protected way diverse objects that do not fit naturally and conveniently in common databases. It may include email messages, documents, journals, multimedia objects, etc. The name may be misleading since some objects can be highly structured. However, the entire possible object collection does not fit into a predefined structured framework. Most established DBMSs now support unstructured data in various ways, and new dedicated DBMSs are emerging.             Connolly and Begg define Database Management System as a software system that enables users to define, create, maintain and control access to the database .     The DBMS acronym is sometime extended to indicated the underlying  |database_model|Database_Model| , with RDBMS for  |relational|Relational_Model| , OODBMS or ORDBMS for the  |object_model|Object_Model|  and ORDBMS for  |Object_Relational|Object_Relationaldatabase| . Other extensions can indicate some other characteristic, such as DDBMS for a distributed database management systems.     The functionality provided by a DBMS can vary enormously. The core functionality is the storage, retrieval and update of data.  |Codd|Edgar_F_Codd|  proposed the following functions and services a fully-fledged general purpose DBMS should provide:  The core part of the DBMS interacting between the database and the application interface sometimes referred to as the  |database_engine|Database_Engine| .     Often DBMSs will have configuration parameters that can be statically and dynamically tuned, for example the maximum amount of main memory on a server the database can use. The trend is to minimise the amount of manual configuration, and for cases such as  |embedded_databases|Embedded_Database|  the need to target zero-administration is paramount.     The large major enterprise DBMSs have tended to increase in size and functionality and can have involved thousands of human years of development effort through their lifetime.     Early multi-user DBMS typically only allowed for the application to reside on the same computer with access via  |terminals|Computer_Terminal|  or terminal emulation software. The  |client–server_architecture|Client–Server_Architecture|  was a development where the application resided on a client desktop and the database on a server allowing the processing to be distributed. This evolved into a  |multitier_architecture|Multitier_Architecture|  incorporating  |application_servers|Application_Server|  and  |web_servers|Web_Server|  with the end user interface via a  |web_browser|Web_Browser|  with the database only directly connected to the adjacent tier.     A general-purpose DBMS will provide public  |application_programming_interfaces|Application_Programming_Interface|  and optionally a processor for  |database_languages|Database_Language|  such as  |SQL|Sql|  to allow applications to be written to interact with the database. A special purpose DBMS may use a private API and be specifically customised and linked to a single application. For example, an  |email|Email|  system performing many of the functions of a general-purpose DBMS such as message insertion, message deletion, attachment handling, blocklist lookup, associating messages an email address and so forth however these functions are limited to what is required to handle email.         External interaction with the database will be via an application program that interfaces with the DBMS. This can range from a  |database_tool|Comparison_Of_Database_Tools|  that allows users to execute SQL queries textually or graphically, to a web site that happens to use a database to store and search information.         A  |programmer|Programmer|  will  |code|Computer_Programming|  interactions to the database  via an  |application_program_interface|Application_Program_Interface|  or via a  |database_language|Database_Language| . The particular API or language chosen will need to be supported by DBMS, possible indirectly via a  |pre_processor|Pre_Processor|  or a bridging API. Some APIs aim to be database independent,  |ODBC|Odbc|  being a commonly known example. Other common APIs include  |JDBC|Jdbc|  and  |ADO_NET|Ado_Net| .         Database languages are special-purpose languages, which allow one or more of the following tasks, sometimes distinguished as  |sublanguages|Sublanguage| :      |Data_control_language|Data_Control_Language|  – controls access to data;    |Data_definition_language|Data_Definition_Language|  – defines data types such as creating, altering, or dropping tables and the relationships among them;    |Data_manipulation_language|Data_Manipulation_Language|  – performs tasks such as inserting, updating, or deleting data occurrences;    |Data_query_language|Data_Query_Language|  – allows searching for information and computing derived information.     Database languages are specific to a particular data model. Notable examples include:     SQL combines the roles of data definition, data manipulation, and query in a single language. It was one of the first commercial languages for the relational model, although it departs in some respects from  |the_relational_model_as_described_by_Codd|Codds_12_Rules|  . SQL became a standard of the  |American_National_Standards_Institute|American_National_Standards_Institute|  in 1986, and of the  |International_Organization_for_Standardization|International_Organization_For_Standardization|  in 1987. The standards have been regularly enhanced since and is supported by all mainstream commercial relational DBMSs.     |OQL|Oql|  is an object model language standard . It has influenced the design of some of the newer query languages like  |JDOQL|Jdoql|  and  |EJB_QL|Ejb_Ql| .    |XQuery|Xquery|  is a standard XML query language implemented by XML database systems such as  |MarkLogic|Marklogic|  and  |eXist|Exist| , by relational databases with XML capability such as Oracle and DB2, and also by in-memory XML processors such as  |Saxon|Saxon_Xslt| .    |SQL_XML|Sql_Xml|  combines  |XQuery|Xquery|  with SQL.     A database language may also incorporate features like:   DBMS-specific configuration and storage engine management   Computations to modify query results, like counting, summing, averaging, sorting, grouping, and cross-referencing   Constraint enforcement   Application programming interface version of the query language, for programmer convenience            Database storage is the container of the physical materialization of a database. It comprises the internal level in the database architecture. It also contains all the information needed  to reconstruct the conceptual level and external level from the internal level when needed. Putting data into permanent storage is generally the responsibility of the  |database_engine|Database_Engine|  a.k.a. storage engine . Though typically accessed by a DBMS through the underlying operating system , storage properties and configuration setting are extremely important for the efficient operation of the DBMS, and thus are closely maintained by database administrators. A DBMS, while in operation, always has its database residing in several types of storage . The database data and the additional needed information, possibly in very large amounts, are coded into bits. Data typically reside in the storage in structures that look completely different from the way the data look in the conceptual and external levels, but in ways that attempt to optimize these levels reconstruction when needed by users and programs, as well as for computing additional types of needed information from the data .     Some DBMSs support specifying which  |character_encoding|Character_Encoding|  was used to store data, so multiple encodings can be used in the same database.     Various low-level  |database_storage_structures|Database_Storage_Structures|  are used by the storage engine to serialize the data model so it can be written to the medium of choice. Techniques such as indexing may be used to improve performance. Conventional storage is row-oriented, but there are also  |column_oriented|Column_Oriented_Dbms|  and  |correlation_databases|Correlation_Database| .            Often storage redundancy is employed to increase performance. A common example is storing materialized views, which consist of frequently needed external views or query results. Storing such views saves the expensive computing of them each time they are needed. The downsides of materialized views are the overhead incurred when updating them to keep them synchronized with their original updated database data, and the cost of storage redundancy.            Occasionally a database employs storage redundancy by database objects replication to increase data availability . Updates of a replicated object need to be synchronized across the object copies. In many cases, the entire database is replicated.                |Database_security|Database_Security|  deals with all various aspects of protecting the database content, its owners, and its users. It ranges from protection from intentional unauthorized database uses to unintentional database accesses by unauthorized entities .     Database access control deals with controlling who is allowed to access what information in the database. The information may comprise specific database objects , certain computations over certain objects , or using specific access paths to the former . Database access controls are set by special authorized personnel that uses dedicated protected security DBMS interfaces.     This may be managed directly on an individual basis, or by the assignment of individuals and  |privileges|Privilege|  to groups, or through the assignment of individuals and groups to roles which are then granted entitlements. Data security prevents unauthorized users from viewing or updating the database. Using passwords, users are allowed access to the entire database or subsets of it called subschemas . For example, an employee database can contain all the data about an individual employee, but one group of users may be authorized to view only payroll data, while others are allowed access to only work history and medical data. If the DBMS provides a way to interactively enter and update the database, as well as interrogate it, this capability allows for managing personal databases.      |Data_security|Data_Security|  in general deals with protecting specific chunks of data, both physically , or the interpretation of them, or parts of them to meaningful information .     Change and access logging records who accessed which attributes, what was changed, and when it was changed. Logging services allow for a forensic  |database_audit|Database_Audit|  later by keeping a record of access occurrences and changes. Sometimes application-level code is used to record changes rather than leaving this to the database. Monitoring can be set up to attempt to detect security breaches.             |Database_transactions|Database_Transactions|  can be used to introduce some level of  |fault_tolerance|Fault_Tolerance|  and  |data_integrity|Data_Integrity|  after recovery from a  |crash|Crash| . A database transaction is a unit of work, typically encapsulating a number of operations over a database , an abstraction supported in database and also other systems. Each transaction has well defined boundaries in terms of which program/code executions are included in that transaction .     The acronym  |ACID|Acid|  describes some ideal properties of a database transaction:  |atomicity|Atomicity| ,  |consistency|Consistency| ,  |isolation|Isolation| , and  |durability|Durability| .            A database built with one DBMS is not portable to another DBMS . However, in some situations, it is desirable to migrate a database from one DBMS to another. The reasons are primarily economical , functional, and operational . The migration involves the databases transformation from one DBMS type to another. The transformation should maintain the database related application intact. Thus, the databases conceptual and external architectural levels should be maintained in the transformation. It may be desired that also some aspects of the architecture internal level are maintained. A complex or large database migration may be a complicated and costly project by itself, which should be factored into the decision to migrate. This in spite of the fact that tools may exist to help migration between specific DBMSs. Typically, a DBMS vendor provides tools to help importing databases from other popular DBMSs.            After designing a database for an application, the next stage is building the database. Typically, an appropriate general-purpose DBMS can be selected to be used for this purpose. A DBMS provides the needed  |user_interfaces|User_Interface|  to be used by database administrators to define the needed applications data structures within the DBMSs respective data model. Other user interfaces are used to select needed DBMS parameters .     When the database is ready , it is typically populated with initial applications data before making it operational. In some cases, the database becomes operational while empty of application data, and data are accumulated during its operation.     After the database is created, initialised and populated it needs to be maintained. Various database parameters may need changing and the database may need to be tuned  for better performance; applications data structures may be changed or added, new related application programs may be written to add to the applications functionality, etc.          Sometimes it is desired to bring a database back to a previous state . To achieve this, a backup operation is done occasionally or continuously, where each desired database state is kept within dedicated backup files . When it is decided by a database administrator to bring the database back to this state , these files are used to restore that state.       Static analysis techniques for software verification can be applied also in the scenario of query languages. In particular, the  |Abstract_interpretation|Abstract_Interpretation|  framework has been extended to the field of query languages for relational databases as a way to support sound approximation techniques. The semantics of query languages can be tuned according to suitable abstractions of the concrete domain of data. The abstraction of relational database system has many interesting applications, in particular, for security purposes, such as fine grained access control, watermarking, etc.         Other DBMS features might include:    |Database_logs|Database_Log|  – This helps in keeping a history of the executed functions.   Graphics component for producing graphs and charts, especially in a data warehouse system.    |Query_optimizer|Query_Optimizer|  – Performs query optimization on every query to choose an efficient  query plan  to be executed to compute the query result. May be specific to a particular storage engine.   Tools or hooks for database design, application programming, application program maintenance, database performance analysis and monitoring, database configuration monitoring, DBMS hardware configuration and related database mapping , storage allocation and database layout monitoring, storage migration, etc.     Increasingly, there are calls for a single system that incorporates all of these core functionalities into the same build, test, and deployment framework for database management and source control. Borrowing from other developments in the software industry, some market such offerings as  |DevOps|Devops|  for database .                The first task of a database designer is to produce a  |conceptual_data_model|Conceptual_Data_Model|  that reflects the structure of the information to be held in the database. A common approach to this is to develop an  |entity_relationship_model|Entity_Relationship_Model| , often with the aid of drawing tools. Another popular approach is the  |Unified_Modeling_Language|Unified_Modeling_Language| . A successful data model will accurately reflect the possible state of the external world being modeled: for example, if people can have more than one phone number, it will allow this information to be captured. Designing a good conceptual data model requires a good understanding of the application domain; it typically involves asking deep questions about the things of interest to an organization, like can a customer also be a supplier? , or if a product is sold with two different forms of packaging, are those the same product or different products? , or if a plane flies from New York to Dubai via Frankfurt, is that one flight or two ? . The answers to these questions establish definitions of the terminology used for entities and their relationships and attributes.     Producing the conceptual data model sometimes involves input from  |business_processes|Business_Process_Modeling| , or the analysis of  |workflow|Workflow|  in the organization. This can help to establish what information is needed in the database, and what can be left out. For example, it can help when deciding whether the database needs to hold historic data as well as current data.     Having produced a conceptual data model that users are happy with, the next stage is to translate this into a  |schema|Database_Schema|  that implements the relevant data structures within the database. This process is often called logical database design, and the output is a  |logical_data_model|Logical_Data_Model|  expressed in the form of a schema. Whereas the conceptual data model is independent of the choice of database technology, the logical data model will be expressed in terms of a particular database model supported by the chosen DBMS. .     The most popular database model for general-purpose databases is the relational model, or more precisely, the relational model as represented by the SQL language. The process of creating a logical database design using this model uses a methodical approach known as  |normalization|Database_Normalization| . The goal of normalization is to ensure that each elementary fact is only recorded in one place, so that insertions, updates, and deletions automatically maintain consistency.     The final stage of database design is to make the decisions that affect performance, scalability, recovery, security, and the like, which depend on the particular DBMS. This is often called physical database design, and the output is the  |physical_data_model|Physical_Data_Model| . A key goal during this stage is  |data_independence|Data_Independence| , meaning that the decisions made for performance optimization purposes should be invisible to end-users and applications. There are two types of data independence: Physical data independence and logical data independence. Physical design is driven mainly by performance requirements, and requires a good knowledge of the expected workload and access patterns, and a deep understanding of the features offered by the chosen DBMS.     Another aspect of physical database design is security. It involves both defining  |access_control|Access_Control|  to database objects as well as defining security levels and methods for the data itself.               A database model is a type of data model that determines the logical structure of a database and fundamentally determines in which manner  |data|Data|  can be stored, organized, and manipulated. The most popular example of a database model is the relational model , which uses a table-based format.     Common logical data models for databases include:    |Navigational_databases|Navigational_Database| |_Hierarchical_database_model|Hierarchical_Database_Model| |_Network_model|Network_Model| |_Graph_database|Graph_Database| |_Relational_model|Relational_Model| |_Entity–relationship_model|Entity–Relationship_Model| |_Enhanced_entity–relationship_model|Enhanced_Entity–Relationship_Model| |_Object_model|Object_Database| |_Document_model|Document_Oriented_Database| |_Entity–attribute–value_model|Entity–Attribute–Value_Model| |_Star_schema|Star_Schema|      An object-relational database combines the two related structures.      |Physical_data_models|Physical_Data_Model|  include:    |Inverted_index|Inverted_Index| |_Flat_file|Flat_File_Database|      Other models include:    |Associative_model|Associative_Model_Of_Data| |_Multidimensional_model|Multidimensional_Database| |_Array_model|Array_Dbms| |_Multivalue_model|Multivalue_Model|      Specialized models are optimized for particular types of data:    |XML_database|Xml_Database| |_Semantic_model|Semantic_Data_Model| |_Content_store|Content_Store| |_Event_store|Event_Store| |_Time_series_model|Time_Series_Database|               A database management system provides three views of the database data:     The external level defines how each group of end-users sees the organization of data in the database. A single database can have any number of views at the external level.   The conceptual level unifies the various external views into a compatible global view. It provides the synthesis of all the external views. It is out of the scope of the various database end-users, and is rather of interest to database application developers and database administrators.   The internal level  is the internal organization of data inside a DBMS. It is concerned with cost, performance, scalability and other operational matters. It deals with storage layout of the data, using storage structures such as  |indexes|Index|  to enhance performance. Occasionally it stores data of individual views , computed from generic data, if performance justification exists for such redundancy. It balances all the external views performance requirements, possibly conflicting, in an attempt to optimize overall performance across all activities.     While there is typically only one conceptual and physical view of the data, there can be any number of different external views. This allows users to see database information in a more business-related way rather than from a technical, processing viewpoint. For example, a financial department of a company needs the payment details of all employees as part of the companys expenses, but does not need details about employees that are the interest of the  |human_resources|Human_Resources|  department. Thus different departments need different views of the companys database.     The three-level database architecture relates to the concept of data independence which was one of the major initial driving forces of the relational model. The idea is that changes made at a certain level do not affect the view at a higher level. For example, changes in the internal level do not affect application programs written using conceptual level interfaces, which reduces the impact of making physical changes to improve performance.     The conceptual view provides a level of indirection between internal and external. On one hand it provides a common view of the database, independent of different external view structures, and on the other hand it abstracts away details of how the data are stored or managed . In principle every level, and even every external view, can be presented by a different data model. In practice usually a given DBMS uses the same data model for both the external and the conceptual levels . The internal level, which is hidden inside the DBMS and depends on its implementation, requires a different level of detail and uses its own types of data structure types.     Separating the external, conceptual and internal levels was a major feature of the relational database model implementations that dominate 21st century databases.         Database technology has been an active research topic since the 1960s, both in  |academia|Academia|  and in the research and development groups of companies . Research activity includes  |theory|Database_Theory|  and development of  |prototypes|Prototype| . Notable research topics have included  |models|Data_Model| , the atomic transaction concept, and related  |concurrency_control|Concurrency_Control|  techniques, query languages and  |query_optimization|Query_Optimization|  methods,  |RAID|Raid| , and more.     The database research area has several dedicated  |academic_journals|Academic_Journal|   and annual  |conferences|Academic_Conference|   .