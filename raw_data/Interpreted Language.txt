   An interpreted language is a type of  |programming_language|Programming_Language|  for which most of its implementations execute instructions directly and freely, without previously  |compiling|Compiler|  a  |program|Computer_Program|  into  |machine_language|Machine_Language|  instructions. The  |interpreter|Interpreter|  executes the program directly, translating each statement into a sequence of one or more  |subroutines|Subroutines| , and then into another language .     The terms interpreted language and  compiled language  are not well defined because, in theory, any programming language can be either interpreted or compiled. In modern programming language implementation, it is increasingly popular for a platform to provide both options.     Interpreted languages can also be contrasted with machine languages. Functionally, both execution and interpretation mean the same thing â€” fetching the next instruction/statement from the program and executing it. Although interpreted  |byte_code|Byte_Code|  is additionally identical to machine code in form and has an  |assembler|Assembly_Language|  representation, the term interpreted is sometimes reserved for software processed languages  on top of the native  processor.     In principle, programs in many languages may be compiled or interpreted, emulated or executed natively, so this designation is applied solely based on common implementation practice, rather than representing an essential property of a language.     Many languages have been implemented using both compilers and interpreters, including  |BASIC|Basic| ,  |C|C| ,  |Lisp|Lisp| , and  |Pascal|Pascal| .  |Java|Java|  and  |C|C_Sharp|  are compiled into  |bytecode|Bytecode| , the  |virtual_machine_friendly_interpreted_language|Interpreted_Languagelanguages_Usually_Compiled_To_A_Bytecode| .  |Lisp_implementations|List_Of_Lisp_Family_Programming_Languages|  can freely mix interpreted and compiled code.     The distinction between a compiler and an interpreter is not always well defined, and many language processors do a combination of both.       In the early days of computing, language design was heavily influenced by the decision to use compiling or interpreting as a mode of execution. For example,  |Smalltalk|Smalltalk|  , which was designed to be interpreted at run-time, allows generic objects to dynamically interact with each other.     Initially, interpreted languages were compiled line-by-line; that is, each line was compiled as it was about to be executed, and if a loop or subroutine caused certain lines to be executed multiple times, they would be recompiled every time. This has become much less common. Most so-called interpreted languages use an  |intermediate_representation|Intermediate_Representation| , which combines compiling and interpreting.     Examples include:    |JavaScript|Javascript| |_Perl|Perl| |_Python|Python| |_BASIC|Basic| |_Forth|Forth|      The intermediate representation can be compiled once and for all , each time before execution , or each time a change in the source is detected before execution .       Interpreting a language gives implementations some additional flexibility over compiled implementations. Features that are often easier to implement in interpreters than in compilers include:    |platform_independence|Platform_Independent| |_reflection|Reflection|  and reflective use of the evaluator     |dynamic_typing|Dynamic_Typing| |_dynamic_scoping|Scope_Dynamic_Scoping|      Furthermore, source code can be read and copied, giving users more freedom.            Disadvantages of interpreted languages are:   Without  |static_type_checking|Static_Type_Checking| , which is usually performed by a compiler, programs can be less reliable, because type checking eliminates a class of programming errors    Interpreters can be susceptible to  |Code_injection|Code_Injection|  attacks.   Slower execution compared to direct native  |machine_code|Machine_Code|  execution on the host  |CPU|Cpu| . A technique used to improve performance is  |just_in_time_compilation|Just_In_Time_Compilation|  which converts frequently executed sequences of interpreted instruction to host machine code. JIT is most often combined with compilation to byte-code as in  |Java|Java| .   Source code can be read and copied , or more easily reverse engineered through  |reflection|Reflection|  in applications where intellectual property has a commercial advantage. In some cases,  |obfuscation|Obfuscation|  is used as a partial defense against this.            Several criteria can be used to determine whether a particular language is likely to be called compiled or interpreted by its users:     If a subroutine can be invoked prior to where its defined in the source code, the entire source is likely being compiled to an intermediate representation before execution. Examples:  |Perl|Perl| ,  |Java|Java| |_Java|Java| ,  |C|C| |_Unix_shell|Unix_Shell|  languages     These are not definitive. Compiled languages can have interpreter-like properties and vice versa.        |APL|Apl|  A vector oriented language using an unusual character set    |J|J|  An APL variant in which tacit definition provides some of the benefits of compiling    |BASIC|Basic|    Equation manipulation and solving systems    |GNU_Octave|Gnu_Octave| |_Interactive_Data_Language|Idl| |_TK_Solver|Tk_Solver| |_Mathematica|Mathematica| |_MATLAB|Matlab| |_Euphoria|Euphoria|  Interpreted or compiled.    |GameMaker_Language|Gamemaker_Studio|  Bytecode after GameMaker: Studio.    |JavaScript|Javascript| |_Forth|Forth| |_Lava|Lava| |_Lisp|Lisp| |_Logo|Logo| |_Scheme|Scheme| |_MUMPS|Mumps| |_PHP|Php| |_PostScript|Postscript| |_PowerShell|Powershell| |_Ruby|Ruby| |_REXX|Rexx| |_Seed7|Seed7| |_Smalltalk|Smalltalk| |Spreadsheets|Spreadsheet| |_Excel|Microsoft_Excel| |_S|S| |_R|R| |_Tcl|Tcl| |_Unix_shell|Unix_Shell| |_XOTcl|Xotcl| |_VBScript|Vbscript|         Many languages are first compiled to  |bytecode|Bytecode| . Sometimes, bytecode can also be compiled to a native binary using an  |AOT_compiler|Aot_Compiler|  or executed natively, by hardware processor.    |AppleScript|Applescript| |_Erlang|Erlang| |_Elixir|Elixir| |_Java|Java| |_Clojure|Clojure| |_Groovy|Groovy| |_Kotlin|Kotlin| |_ColdFusion|Coldfusion| |_Scala|Scala| |_NET_Framework|_Net_Framework|  languages .    |C_CLI|C_Cli| |_C|C_Sharp| |_Visual_Basic_NET|Visual_Basic_Net| |_F|F_Sharp| |_Lisp|Lisp| |_Lua|Lua| |_Perl|Perl| |_Pike|Pike| |_Python|Python| |_Squeak_Smalltalk|Squeak_Smalltalk| |_Visual_FoxPro|Visual_Foxpro| .