In  |computer_science|Computer_Science| , string-searching algorithms, sometimes called string-matching algorithms, are an important class of  |string_algorithms|String_Algorithms|  that try to find a place where one or several  |strings|String|  are found within a larger string or text.     A basic example of string searching is when the pattern and the searched text are  |arrays|Array_Data_Structure|  of elements of an  |alphabet|Alphabet|   Σ. Σ may be a human language alphabet, for example, the letters A through Z and other applications may use a binary alphabet or a DNA alphabet in  |bioinformatics|Bioinformatics| .     In practice, the method of feasible string-search algorithm may be affected by the string encoding. In particular, if a  |variable_width_encoding|Variable_Width_Encoding|  is in use, then it may be slower to find the Nth character, perhaps requiring time proportional to N. This may significantly slow some search algorithms. One of many possible solutions is to search for the sequence of code units instead, but doing so may produce false matches unless the encoding is specifically designed to avoid it.       The most basic case of string searching involves one string, sometimes called the haystack, and one string, sometimes called the needle. The goal is to find one or more occurrences of the needle within the haystack. For example, one might search for to within:     Some books are to be tasted, others to be swallowed, and some few to be chewed and digested.     One might request the first occurrence of to , which is the fourth word; or all occurrences, of which there are 3; or the last, which is the fifth word from the end.     Very commonly, however, various constraints are added. For example, one might want to match needle only where it consists of one complete words—perhaps defined as not having other letters immediately adjacent on either side. In that case a search for hew or low should fail for the example sentence above, even though those literal strings do occur.     Another common example involves normalization . For many purposes, a search for a phrase such as to be should succeed even in places where there is something else intervening between the to and the be :   More than one space   Other whitespace characters such as tabs, non-breaking spaces, line-breaks, etc.   Less commonly, a hyphen or soft hyphen   In structured texts,  |tags|Markup_Language|  or even arbitrarily large but parenthetical things such as footnotes, list-numbers or other markers, embedded images, and so on.     Many symbol systems include characters that are synonymous :   Latin-based alphabets distinguish lower-case from upper-case, but for many purposes string search is expected to ignore the distinction.   Many languages include  |ligatures|Typographic_Ligature| , where one composite character is equivalent to two or more other characters.   Many writing systems involve  |diacritical_marks|Diacritical_Marks|  such as accents or  |vowel_points|Vowel_Points| , which may vary in their usage, or be of varying importance in matching.   DNA sequences can involve  |non_coding|Non_Coding|  segments which may be ignored for some purposes, or polymorphisms that lead to no change in the encoded proteins, which may not count as a true difference for some other purposes.   Some languages have rules where a different character or form of character must be used at the start, middle, or end of words.     Finally, for strings that represent natural language, aspects of the language itself become involved. For example, one might wish to find all occurrences of a word despite it having alternate spellings, prefixes or suffixes, etc.     Another more complex type of search is  |regular_expression|Regular_Expression|  searching, where the user constructs a pattern of characters or other symbols, and any match to the pattern should fulfill the search. For example, to catch both the American English word color and the British equivalent colour , instead of searching for two different literal strings, one might use a regular expression such as:     colou?r     where the ? conventionally makes the preceding character optional.     This article mainly discusses algorithms for the simpler kinds of string searching.     A similar problem introduced in the field of bioinformatics and genomics is the maximal exact matching .  Given two strings, MEMs are common substrings that cannot be extended left or right without causing a mismatch.        The various  |algorithms|Algorithm|  can be classified by the number of patterns each uses.       Let m be the length of the pattern, n be the length of the searchable text and k & x7c;Σ & x7c; be the size of the alphabet.        :1.Asymptotic times are expressed using  |O_Ω_and_Θ_notation|Big_O_Notation| .     The  Boyer–Moore string-search algorithm  has been the standard benchmark for the practical string-search literature.         |Aho–Corasick_string_matching_algorithm|Aho–Corasick_String_Matching_Algorithm| |_Commentz_Walter_algorithm|Commentz_Walter_Algorithm|    Set-BOM    |Rabin–Karp_string_search_algorithm|Rabin–Karp_String_Search_Algorithm|        Naturally, the patterns can not be enumerated finitely in this case. They are represented usually by a  |regular_grammar|Regular_Grammar|  or  |regular_expression|Regular_Expression| .       Other classification approaches are possible. One of the most common uses preprocessing as main criteria.          Another one classifies the algorithms by their matching strategy:    Match the prefix first   Match the suffix first   Match the best factor first   Other strategy       A simple and inefficient way to see where one string occurs inside another is to check each place it could be, one by one, to see if its there. So first we see if theres a copy of the needle in the first character of the haystack; if not, we look to see if theres a copy of the needle starting at the second character of the haystack; if not, we look starting at the third character, and so forth. In the normal case, we only have to look at one or two characters for each wrong position to see that it is a wrong position, so in the average case, this takes  |O|Big_O_Notation|  steps, where n is the length of the haystack and m is the length of the needle; but in the worst case, searching for a string like aaaab in a string like aaaaaaaaab , it takes  |O|Big_O_Notation|           In this approach, we avoid backtracking by constructing a  |deterministic_finite_automaton|Deterministic_Finite_Automaton|  that recognizes stored search string. These are expensive to construct—they are usually created using the  |powerset_construction|Powerset_Construction| —but are very quick to use. For example, the  |DFA|Deterministic_Finite_Automaton|  shown to the right recognizes the word MOMMY . This approach is frequently generalized in practice to search for arbitrary  |regular_expressions|Regular_Expression| .        |Knuth–Morris–Pratt|Knuth–Morris–Pratt_Algorithm|  computes a  |DFA|Deterministic_Finite_Automaton|  that recognizes inputs with the string to search for as a suffix,  |Boyer–Moore|Boyer–Moore_String_Search_Algorithm|  starts searching from the end of the needle, so it can usually jump ahead a whole needle-length at each step. Baeza–Yates keeps track of whether the previous j characters were a prefix of the search string, and is therefore adaptable to  |fuzzy_string_searching|Fuzzy_String_Searching| . The  |bitap_algorithm|Bitap_Algorithm|  is an application of Baeza–Yates approach.       Faster search algorithms preprocess the text. After building a  |substring_index|Substring_Index| , for example a  |suffix_tree|Suffix_Tree|  or  |suffix_array|Suffix_Array| , the occurrences of a pattern can be found quickly. As an example, a suffix tree can be built in   time, and all z occurrences of a pattern can be found in O time under the assumption that the alphabet has a constant size and all inner nodes in the suffix tree know what leaves are underneath them. The latter can be accomplished by running a  |DFS_algorithm|Depth_First_Search|  from the root of the suffix tree.       Some search methods, for instance  |trigram_search|Trigram_Search| , are intended to find a closeness score between the search string and the text rather than a match/non-match . These are sometimes called  |_fuzzy_searches|Approximate_String_Matching| .