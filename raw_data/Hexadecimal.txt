         In  |mathematics|Mathematics|  and  |computing|Computing| , hexadecimal  is a  |positional_system|Numeral_Systempositional_Systems_In_Detail|  that represents numbers using a  |base|Radix|  of 16. Unlike the  |common_way|Decimal|  of representing numbers with ten symbols, it uses sixteen distinct symbols, most often the symbols 0 – 9 to represent values zero to nine, and A – F to represent values ten to fifteen.     Hexadecimal numerals are widely used by computer system designers and programmers, as they provide a human-friendly representation of  |binary-coded|Binary_Code|  values. Each hexadecimal digit represents four  |binary_digits|Bit| , also known as a  |nibble|Nibble| , which is half a  |byte|Byte| . For example, a single byte can have values ranging from 00000000 to 11111111 in binary form, which can be conveniently represented as 00 to FF in hexadecimal.     In mathematics, a subscript is typically used to specify the base, also known as the  |radix|Radix| . For example, the decimal value  would be expressed in hexadecimal as . In programming, a number of notations are used to support hexadecimal representation, usually involving a prefix or suffix. The prefix 0x is used in  |C|C|  and related languages, which would denote this value by 0x .     Hexadecimal is used in the transfer encoding Base16, in which each byte of the  |plaintext|Plaintext|  is broken into two 4-bit values and represented by two hexadecimal digits.                Almost all modern use uses the letters A-F to represent the digits with values 10-15. There is no universal convention to use lowercase or uppercase, each is prevalent or preferred in particular environments by community standards or convention, and mixed case is often used.  |Seven-segment_displays|Seven-Segment_Display|  use mixed-case AbCdEF to make digits that can be distinguished from each other.       In contexts where the  |base|Radix|  is not clear, hexadecimal numbers can be ambiguous and confused with numbers expressed in other bases. There are several conventions for expressing values unambiguously. A numerical subscript can give the base explicitly: 159 10 is decimal 159; 159 16 is hexadecimal 159, which is equal to 345 10 . Some authors prefer a text subscript, such as 159 decimal and 159 hex , or 159 d and 159 h .      |Donald_Knuth|Donald_Knuth|  introduced the use of a particular typeface to represent a particular radix in his book The TeXbook. Donald E. Knuth. The TeXbook . Reading, Massachusetts: Addison–Wesley, 1984. . The    is available online on  |CTAN|Ctan| . Hexadecimal representations are written there in a typewriter typeface: 5A3     In linear text systems, such as those used in most computer programming environments, a variety of methods have arisen:    |Unix|Nix|  shells,  |AT_&_T|At_&_T_Corporation|  assembly language and likewise the  |C_programming_language|C|   use the prefix 0x for numeric constants represented in hex: 0x5A3 . Character and string constants may express character codes in hexadecimal with the prefix   followed by two hex digits:   represents the  |Esc|Escape_Character|  control character;   is a string containing 11 characters with two embedded Esc characters. The string   specifies the character sequence Esc 0 m Esc 2 5 ; 1 H Nul . These are the escape sequences used on an  |ANSI_terminal|Ansi_Escape_Code|  that reset the character set and color, and then move the cursor to line 25. To output an integer as hexadecimal with the  |printf|Printf|  function family, the format conversion code %X or %x is used.   In  |URIs|Uri|  ,  |character_codes|Character_Encoding|  are written as hexadecimal pairs prefixed with % :  where %20 is the code for the  |space|Space_Space_Characters_And_Digital_Typography|  character,  |ASCII|Ascii|  code point 20 in hex, 32 in decimal.   In  |XML|Xml|  and  |XHTML|Xhtml| , characters can be expressed as hexadecimal  |numeric_character_references|Numeric_Character_Reference|  using the notation & amp;xcode; , for instance & amp;x2019; represents the character U+2019 . If there is no  the number is decimal .    In the  |Unicode|Unicode|  standard, a character value is represented with U+ followed by the hex value, e.g. U+20AC is the  |Euro_sign|Euro_Sign|  .    |Color_references|Web_Colors|  in HTML,  |CSS|Cascading_Style_Sheets|  and  |X_Window|X_Window_System|  can be expressed with six hexadecimal digits prefixed with : white, for example, is represented as FFFFFF .  CSS also allows 3-hexdigit abbreviations with one hexdigit per component: FA3 abbreviates FFAA33 .   In  |MIME|Mime| |quoted-printable|Quoted-Printable|  encoding, character codes are written as hexadecimal pairs prefixed with : EspaF1a is España .   |6502|Mos_Technology_6502| ,  |Motorola|Motorola| |ogramming_langua|Ogramming_Langua| |Commodore|Commodore_Basic| |me_engi|Me_Engi| |ogramming_langua|Ogramming_Langua| Microchipfor ABCD 16  |ogramming_langua|Ogramming_Langua| such as image  |pixels|Pixel|  without modificationMicrosoft BASIC primarily uses & amp;O to prefix octal, and it uses & amp;H to prefix hexadecimal, but the ampersand alone yields a default interpretation as an octal prefix.    |TI-89|Ti-89|  and 92 series uses a 0h prefix: 0h5A3    |ALGOL_68|Algol_68|  uses the prefix 16r to denote hexadecimal numbers: 16r5a3 . Binary, quaternary and octal numbers can be specified similarly.   The most common format for hexadecimal on IBM mainframes  and midrange computers  running the traditional OSs  is X5A3 , and is used in Assembler,  |PL/I|Pl/I| ,  |COBOL|Cobol| ,  |JCL|Job_Control_Language| , scripts, commands and other places. This format was common on other IBM systems as well. Occasionally quotation marks were used instead of apostrophes.   Any  |IPv6_address|Ipv6_Address|  can be written as eight groups of four hexadecimal digits , where each group is separated by a colon . This, for example, is a valid IPv6 address:  or abbreviated by removing zeros as  .    |Globally_unique_identifiers|Globally_Unique_Identifier|  are written as thirty-two hexadecimal digits, often in unequal hyphen-separated groupings, for example .         The use of the letters A through F to represent the digits above 9 was not universal in the early history of computers.   During the 1950s, some installations favored using the digits 0 through 5 with an  |overline|Overline|  to denote the values 10–15 as , , , ,  and .   The  |SWAC|Swac|  and  |Bendix_G-15|Bendix_G-15|  computers used the lowercase letters u, v, w, x, y and z for the values 10 to 15.   The  |ILLIAC_I|Illiac_I|  computer used the uppercase letters K, S, N, J, F and L for the values 10 to 15.   The Librascope  |LGP-30|Lgp-30|  used the letters F, G, J, K, Q and W for the values 10 to 15.   The  |Honeywell|Honeywell| |Datamatic_D-1000|Datamatic_D-1000|  used the lowercase letters b, c, d, e, f, and g whereas the  |Elbit|Elbit|   100 used the uppercase letters B, C, D, E, F and G for the values 10 to 15.   The  |Monrobot_XI|Monrobot_Xi|  used the letters S, T, U, V, W and X for the values 10 to 15.   The  |NEC|Nec| |parametron|Parametron|  computer NEAC 1103 used the letters D, G, H, J, K  for values 10–15.    The Pacific Data Systems  1020 used the letters L, C, A, S, M and D for the values 10 to 15.   New numeric symbols and names were introduced in the  |Bibi-binary|Bibi-Binary|  notation by  |Boby_Lapointe|Boby_Lapointe|  in 1968. This notation did not become very popular.     |Brookhaven_National_Laboratory|Brookhaven_National_Laboratory|  considered the choice of A–F ridiculous . In a 1968 letter to the editor of the  |CACM|Communications_Of_The_Acm| , he proposed an entirely new set of symbols based on the bit locations, which did not gain much acceptance.    Some  |seven-segment_display|Seven-Segment_Display|  decoder chips show the random result of logic designed only to produce 0-9 correctly.       There are no traditional numerals to represent the quantities from ten to fifteen – letters are used as a substitute – and most  |Europe|Europe| an languages lack non-decimal names for the numerals above ten. Even though English has names for several non-decimal powers , no English name describes the hexadecimal powers . Some people read hexadecimal numbers digit by digit like a phone number, or using the  |NATO_phonetic_alphabet|Icao_Spelling_Alphabet| , the  |Joint_Army/Navy_Phonetic_Alphabet|Joint_Army/Navy_Phonetic_Alphabet| , or a similar ad hoc system. In the wake of the adoption of hexadecimal among  |IBM_System/360|Ibm_System/360|  programmers, Robert A. Magnuson suggested in 1968 in  |Datamation|Datamation|  Magazine a pronunciation guide that gave short names to the letters of hexadecimal - for instance, A was pronounced ann , B bet , C chris , etc.  Another naming system was invented independently by Tim Babb in 2015.  An additional naming system has been published online by S. R. Rogers in 2007  that tries to make the verbal representation distiguishable in any case, even when the actual number does not contain numbers A-F. Examples are listed in the tables below.        Systems of counting on  |digits|Digit|  have been devised for both binary and hexadecimal.    |Arthur_C._Clarke|Arthur_C._Clarke|  suggested using each finger as an on/off bit, allowing finger counting from zero to 1023 10 on ten fingers.  Another system for counting up to FF 16 is illustrated on the right.                  The hexadecimal system can express negative numbers the same way as in decimal: −2A to represent −42 10 and so on.     Hexadecimal can also be used to express the exact bit patterns used in the  |processor|Central_Processing_Unit| , so a sequence of hexadecimal digits may represent a  |signed|Signedness|  or even a  |floating_point|Floating_Point|  value. This way, the negative number −42 10 can be written as FFFF  FFD6 in a 32-bit  |CPU_register|Processor_Register|  , as C228  0000 in a 32-bit  |FPU|Floating_Point_Unit|  register or C045  0000  0000  0000 in a 64-bit FPU register .       Just as decimal numbers can be represented in  |exponential_notation|Exponential_Notation| , so too can hexadecimal numbers. By convention, the letter P  represents times two raised to the power of, whereas E  serves a similar purpose in decimal as part of the  |E_notation|E_Notation| . The number after the P is decimal and represents the binary exponent. Increasing the exponent by 1 multiplies by 2, not 16. 10.0p1 8.0p2 4.0p3 2.0p4 1.0p5. Usually, the number is normalized so that the leading hexadecimal digit is 1 .     Example: 1.3DEp42 represents .     Hexadecimal exponential notation is required by the  |IEEE_754-2008|Ieee_754-2008|  binary floating-point standard.   This notation can be used for floating-point literals in the  |C99|C99|  edition of the  |C_programming_language|C| .    Using the %a or %A conversion specifiers, this notation can be produced by implementations of the  printf  family of functions following the C99 specification  and    |Single_Unix_Specification|Single_Unix_Specification| |POSIX|Posix|  standard.            Most computers manipulate binary data, but it is difficult for humans to work with a large number of digits for even a relatively small binary number. Although most humans are familiar with the base 10 system, it is much easier to map binary to hexadecimal than to decimal because each hexadecimal digit maps to a whole number of bits .   This example converts 1111 2 to base ten. Since each  |position|Positional_Notation|  in a binary numeral can contain either a 1 or a 0, its value may be easily determined by its position from the right:   0001 2 1 10   0010 2 2 10   0100 2 4 10   1000 2 8 10   Therefore:      With little practice, mapping 1111 2 to F 16 in one step becomes easy: see table in  |written_representation|Written_Representation| . The advantage of using hexadecimal rather than decimal increases rapidly with the size of the number. When the number becomes large, conversion to decimal is very tedious. However, when mapping to hexadecimal, it is trivial to regard the binary string as 4-digit groups and map each to a single hexadecimal digit.     This example shows the conversion of a binary number to decimal, mapping each digit to the decimal value, and adding the results.      Compare this to the conversion to hexadecimal, where each group of four digits can be considered independently, and converted directly:      The conversion from hexadecimal to binary is equally direct.         Although  |quaternary|Quaternary_Numeral_System|  is little used, it can easily be converted to and from hexadecimal or binary. Each hexadecimal digit corresponds to a pair of quaternary digits and each quaternary digit corresponds to a pair of binary digits. In the above example 5  E  B  5  2 16 11  32  23  11  02 4 .     The  |octal|Octal|  system can also be converted with relative ease, although not quite as trivially as with bases 2 and 4. Each octal digit corresponds to three binary digits, rather than four. Therefore we can convert between octal and hexadecimal via an intermediate conversion to binary followed by regrouping the binary digits in groups of either three or four.       As with all bases there is a simple  |algorithm|Algorithm|  for converting a representation of a number to hexadecimal by doing integer division and remainder operations in the source base. In theory, this is possible from any base, but for most humans only decimal and for most computers only binary can be easily handled with this method.     Let d be the number to represent in hexadecimal, and the series h i h i−1 ...h 2 h 1 be the hexadecimal digits representing the number.     i ← 1   h i ← d mod 16   d ← / 16   If d 0 else increment i and go to step 2     16 may be replaced with any other base that may be desired.     The following is a  |JavaScript|Javascript|  implementation of the above algorithm for converting any number to a hexadecimal in String representation. Its purpose is to illustrate the above algorithm. To work with data seriously, however, it is much more advisable to work with  |bitwise_operators|Bitwise_Operators| .       function toHex .