      In  |computing|Computing| , a plug-in  is a  |software_component|Software_Component|  that adds a specific feature to an existing  |computer_program|Computer_Program| . When a program supports plug-ins, it enables customization.      |Web_browsers|Web_Browser|  have historically allowed  |executables|Executable|  as plug-ins, though they are now mostly  |deprecated|Deprecation| .  Two plug-in examples are the  |Adobe_Flash_Player|Adobe_Flash_Player|  for playing videos and a  |Java_virtual_machine|Java_Virtual_Machine|  for running  |applets|Java_Applet| .     A  |theme|Theme|  or  |skin|Skin|  is a preset package containing additional or changed graphical appearance details, achieved by the use of a graphical user interface that can be applied to specific software and websites to suit the purpose, topic, or tastes of different users to customize the look and feel of a piece of computer software or an operating system front-end GUI .       Applications support plug-ins for many reasons. Some of the main reasons include:   to enable  |third-party_developers|Third-Party_Developer|  to create abilities which extend an application   to support easily adding new features   to reduce the size of an application   to separate  |source_code|Source_Code|  from an application because of incompatible  |software_licenses|Software_License| .     Types of applications and why they use plug-ins:      |Audio_editors|Digital_Audio_Editor|  use plug-ins to generate, process or analyze sound.  |Ardour|Ardour|  and  |Audacity|Audacity|  are examples of such editors.    |Digital_audio_workstations|Digital_Audio_Workstation|  use plug-ins to generate sound or process it. Examples include  |Logic_Pro_X|Logic_Pro|  and  |Pro_Tools|Pro_Tools| .    |Email_clients|Email_Client|  use plug-ins to decrypt and encrypt email.  |Pretty_Good_Privacy|Pretty_Good_Privacy|  is an example of such plug-ins.    |Video_game_console_emulators|Video_Game_Console_Emulator|  often use plug-ins to modularize the separate subsystems of the devices they seek to emulate.          For example, the  |PCSX2|Pcsx2|  emulator makes use of video, audio, optical, etc. plug-ins for those respective components of the  |PlayStation_2|Playstation_2| .    |Graphics_software|Graphics_Software|  use plug-ins to support file formats and process images.     |Media_players|Media_Player|  use plug-ins to support file formats and apply filters.  |foobar2000|Foobar2000| ,  |GStreamer|Gstreamer| ,  |Quintessential|Quintessential_Media_Player| ,  |VST|Virtual_Studio_Technology| ,  |Winamp|Winamp| ,  |XMMS|Xmms|  are examples of such media players.    |Packet_sniffers|Packet_Sniffer|  use plug-ins to decode packet formats.  |OmniPeek|Omnipeek|  is an example of such packet sniffers.    |Remote_sensing_applications|Remote_Sensing_Application|  use plug-ins to process data from different sensor types; e.g.,  |Opticks|Opticks| .    |Text_editors|Text_Editors|  and  |Integrated_development_environments|Integrated_Development_Environment|  use plug-ins to support  |programming_languages|Programming_Languages|  or enhance development process e.g.,  |Visual_Studio|Microsoft_Visual_Studio| ,  |RAD_Studio|Rad_Studio| ,  |Eclipse|Eclipse| ,  |IntelliJ_IDEA|Intellij_Idea| ,  |jEdit|Jedit|  and  |MonoDevelop|Monodevelop|  support plug-ins. Visual Studio itself can be plugged into other applications via  |Visual_Studio_Tools_for_Office|Visual_Studio_Tools_For_Office|  and  |Visual_Studio_Tools_for_Applications|Visual_Studio_Tools_For_Applications| .    |Web_browsers|Web_Browser|  have historically used  |executables|Executable|  as plug-ins, though they are now mostly  |deprecated|Deprecation| . Examples include  |Adobe_Flash_Player|Adobe_Flash_Player| ,  |Java_SE|Java_Se| ,  |QuickTime|Quicktime| ,  |Microsoft_Silverlight|Microsoft_Silverlight|  and  |Unity|Unity| .               The host application provides services which the plug-in can use, including a way for plug-ins to register themselves with the host application and a  |protocol|Protocol|  for the exchange of data with plug-ins. Plug-ins depend on the services provided by the host application and do not usually work by themselves. Conversely, the host application operates independently of the plug-ins, making it possible for end-users to add and update plug-ins dynamically without needing to make changes to the host application.  – Description of the difference between Mozilla Firefox plugins and extensions under the general term add-on.  – Description of the Wordpress Plug-in architecture.     Programmers typically implement plug-in functionality using  |shared_libraries|Shared_Library| , which get  |dynamically_loaded|Dynamic_Loading|  at run time, installed in a place prescribed by the host application.  |HyperCard|Hypercard|  supported a similar facility, but more commonly included the plug-in code in the HyperCard documents  themselves. Thus the HyperCard stack became a self-contained application in its own right, distributable as a single entity that end-users could run without the need for additional installation-steps. Programs may also implement plugins by loading a directory of simple  |script|Script|  files written in a  |scripting_language|Scripting_Language|  like  |Python|Python|  or  |Lua|Lua| .          In  |Mozilla_Foundation|Mozilla_Foundation|  definitions, the words add-on ,  |extension|Browser_Extension|  and plug-in are not synonyms. Add-on can refer to anything that extends the functions of a Mozilla application. Extensions comprise a subtype, albeit the most common and the most powerful one. Mozilla applications come with integrated add-on managers that, similar to  |package_managers|Package_Manager| , install, update and manage extensions. The term, Plug-in , however, strictly refers to  |NPAPI|Npapi| -based web content renderers. Plug-ins are being deprecated.        Plug-ins appeared as early as the mid 1970s, when the  |EDT|Edt| |text_editor|Text_Editor|  running on the  |Unisys|Unisys| |VS/9|Vs/9| |operating_system|Operating_System|  using the  |UNIVAC_Series_90|Univac_Series_90| |mainframe_computers|Mainframe_Computer|  provided the ability to run a program from the editor and to allow such a program to access the editor buffer, thus allowing an external program to access an edit session in memory. EDT Text Editor Reference Manual,  |Cinnaminson,_New_Jersey|Cinnaminson,_New_Jersey| |Unisys_Corporation|Unisys_Corporation| , 1975 The plug-in program could make calls to the editor to have it perform text-editing services upon the buffer that the editor shared with the plug-in. The  |Waterloo|University_Of_Waterloo|  Fortran  |compiler|Compiler|  used this feature to allow interactive compilation of  |Fortran|Fortran|  programs edited by EDT.     Very early  |PC|Personal_Computer|  software applications to incorporate plug-in functionality included HyperCard and  |QuarkXPress|Quarkxpress|  on the  |Macintosh|Apple_Macintosh| , both released in 1987. In 1988,  |Silicon_Beach_Software|Silicon_Beach_Software|  included plug-in functionality in  |Digital_Darkroom|Digital_Darkroom|  and  |SuperPaint|Superpaint| , and Ed Bomke coined the term plug-in.