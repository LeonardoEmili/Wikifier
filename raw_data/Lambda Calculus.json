[
    {
        "Lambda calculus  is a ": null
    },
    {
        "formal system": "Formal System"
    },
    {
        " in ": null
    },
    {
        "mathematical logic": "Mathematical Logic"
    },
    {
        " for expressing ": null
    },
    {
        "computation": "Computability"
    },
    {
        " based on function ": null
    },
    {
        "abstraction": "Abstraction"
    },
    {
        " and ": null
    },
    {
        "application": "Function Application"
    },
    {
        " using variable ": null
    },
    {
        "binding": "Name Binding"
    },
    {
        " and ": null
    },
    {
        "substitution": "Substitution"
    },
    {
        ". It is a universal ": null
    },
    {
        "model of computation": "Model Of Computation"
    },
    {
        " that can be used to simulate any ": null
    },
    {
        "Turing machine": "Turing Machine"
    },
    {
        ". It was introduced by the mathematician ": null
    },
    {
        "Alonzo Church": "Alonzo Church"
    },
    {
        " in the 1930s as part of his research into the ": null
    },
    {
        "foundations of mathematics": "Foundations Of Mathematics"
    },
    {
        ".     Lambda calculus consists of constructing lambda terms and performing reduction operations on them. In the simplest form of lambda calculus, terms are built using only the following rules:        producing expressions such as: . Parentheses can be dropped if the expression is unambiguous. For some applications, terms for logical and mathematical constants and operations may be included.     The reduction operations include:          If ": null
    },
    {
        "De Bruijn index": "De Bruijn Index"
    },
    {
        "ing is used, then α-conversion is no longer required as there will be no name collisions. If ": null
    },
    {
        "repeated application": "Reduction Strategy"
    },
    {
        " of the reduction steps eventually terminates, then by the ": null
    },
    {
        "Church–Rosser theorem": "Church–Rosser Theorem"
    },
    {
        " it will produce a ": null
    },
    {
        "β-normal form": "Beta Normal Form"
    },
    {
        ".       Lambda calculus is ": null
    },
    {
        "Turing complete": "Turing Completeness"
    },
    {
        ", that is, it is a universal ": null
    },
    {
        "model of computation": "Model Of Computation"
    },
    {
        " that can be used to simulate any ": null
    },
    {
        "Turing machine": "Turing Machine"
    },
    {
        ".  Its namesake, the Greek letter lambda , is used in lambda expressions and lambda terms to denote ": null
    },
    {
        "binding": "Free Variables And Bound Variables"
    },
    {
        " a variable in a ": null
    },
    {
        "function": "Function"
    },
    {
        ".     Lambda calculus may be untyped or typed. In typed lambda calculus, functions can be applied only if they are capable of accepting the given inputs type of data. Typed lambda calculi are weaker than the untyped lambda calculus, which is the primary subject of this article, in the sense that typed lambda calculi can express less than the untyped calculus can, but on the other hand typed lambda calculi allow more things to be proved; in the ": null
    },
    {
        "simply typed lambda calculus": "Simply Typed Lambda Calculus"
    },
    {
        " it is, for example, a theorem that every evaluation strategy terminates for every simply typed lambda-term, whereas evaluation of untyped lambda-terms need not terminate. One reason there are many different typed lambda calculi has been the desire to do more without giving up on being able to prove strong theorems about the calculus.     Lambda calculus has applications in many different areas in ": null
    },
    {
        "mathematics": "Mathematics"
    },
    {
        ", ": null
    },
    {
        "philosophy": "Philosophy"
    },
    {
        ", ": null
    },
    {
        "Coquand, Thierry": "Thierry Coquand"
    },
    {
        ", , The Stanford Encyclopedia of Philosophy , Edward N. Zalta . ": null
    },
    {
        "linguistics": "Linguistics"
    },
    {
        ",   and ": null
    },
    {
        "computer science": "Computer Science"
    },
    {
        ". . Lambda calculus has played an important role in the development of the ": null
    },
    {
        "theory of programming languages": "Programming Language Theory"
    },
    {
        ". ": null
    },
    {
        "Functional programming languages": "Functional Programming Language"
    },
    {
        "implement the lambda calculus. Lambda calculus is also a current research topic in ": null
    },
    {
        "Category theory": "Category Theory"
    },
    {
        ".        The lambda calculus was introduced by mathematician ": null
    },
    {
        "Alonzo Church": "Alonzo Church"
    },
    {
        " in the 1930s as part of an investigation into the ": null
    },
    {
        "foundations of mathematics": "Foundations Of Mathematics"
    },
    {
        ".  For a full history, see Cardone and Hindleys History of Lambda-calculus and Combinatory Logic . The original system was shown to be ": null
    },
    {
        "logically inconsistent": "Consistency"
    },
    {
        " in 1935 when ": null
    },
    {
        "Stephen Kleene": "Stephen Kleene"
    },
    {
        " and ": null
    },
    {
        "J. B. Rosser": "J. B. Rosser"
    },
    {
        " developed the ": null
    },
    {
        "Kleene–Rosser paradox": "Kleene–Rosser Paradox"
    },
    {
        ".       Subsequently, in 1936 Church isolated and published just the portion relevant to computation, what is now called the untyped lambda calculus.  In 1940, he also introduced a computationally weaker, but logically consistent system, known as the ": null
    },
    {
        "simply typed lambda calculus": "Simply Typed Lambda Calculus"
    },
    {
        ".      Until the 1960s when its relation to programming languages was clarified, the lambda calculus was only a formalism. Thanks to ": null
    },
    {
        "Richard Montague": "Richard Montague"
    },
    {
        " and other linguists applications in the semantics of natural language, the lambda calculus has begun to enjoy a respectable place in both linguistics  and computer science. Alama, Jesse , The Stanford Encyclopedia of Philosophy , Edward N. Zalta .       There is a bit of controversy over the reason for Churchs use of the Greek letter ": null
    },
    {
        "lambda": "Lambda"
    },
    {
        " as the notation for function-abstraction in the lambda calculus, perhaps in part due to conflicting explanations by Church himself. According to Cardone and Hindley :     By the way, why did Church choose the notation “λ”? In he stated clearly that it came from the notation “   ” used for class-abstraction by ": null
    },
    {
        "Whitehead and Russell": "Principia Mathematica"
    },
    {
        ", by first modifying “   ” to “∧ x ” to distinguish function-abstraction from class-abstraction, and then changing “∧” to “λ” for ease of printing.     This origin was also reported in On the other hand, in his later years Church told two enquirers that the choice was more accidental: a symbol was needed and λ just happened to be chosen.     ": null
    },
    {
        "Dana Scott": "Dana Scott"
    },
    {
        " has also addressed this controversy in various public lectures. Dana Scott,  , Invited Talk at the Workshop in honour of Dana Scott’s 85th birthday and 50 years of domain theory, 7-8 July, FLoC 2018 . The relevant passage begins at .    Scott recounts that he once posed a question about the origin of the lambda symbol to Churchs son-in-law John Addison, who then wrote his father-in-law a postcard:     Dear Professor Church,     Russell had the iota operator, Hilbert had the epsilon operator. Why did you choose lambda for your operator?     According to Scott, Churchs entire response consisted of returning the postcard with the following annotation: ": null
    },
    {
        "eeny, meeny, miny, moe": "Eeny, Meeny, Miny, Moe"
    },
    {
        " .              ": null
    },
    {
        "Computable functions": "Computable Function"
    },
    {
        "are a fundamental concept within computer science and mathematics. The lambda calculus provides a simple ": null
    },
    {
        "semantics": "Semanticscomputer Science"
    },
    {
        " for computation, enabling properties of computation to be studied formally. The lambda calculus incorporates two simplifications that make this semantics simple.   The first simplification is that the lambda calculus treats functions anonymously , without giving them explicit names. For example, the function   :   x2 + y2   can be rewritten in anonymous form as   :   x2 + y2   . Similarly,   :   x   can be rewritten in anonymous form as   : x   x   where the input is simply mapped to itself.     The second simplification is that the lambda calculus only uses functions of a single input. An ordinary function that requires two inputs, for instance the   function, can be reworked into an equivalent function that accepts a single input, and as output returns another function, that in turn accepts a single input. For example,   :   x2 + y2   can be reworked into   : x     This method, known as ": null
    },
    {
        "currying": "Currying"
    },
    {
        ", transforms a function that takes multiple arguments into a chain of functions each with a single argument.     ": null
    },
    {
        "Function application": "Function Application"
    },
    {
        " of the   function to the arguments , yields at once   :   : 52 + 22   : 29 ,   whereas evaluation of the curried version requires one more step   :     : // the definition of x has been used with 5 in the inner expression. This is like β-reduction.   : 52 + 22 // the definition of y has been used with 2 . Again, similar to β-reduction.   : 29   to arrive at the same result.       The lambda calculus consists of a language of lambda terms, which is defined by a certain formal syntax, and a set of transformation rules, which allow manipulation of the lambda terms. These transformation rules can be viewed as an ": null
    },
    {
        "equational theory": "Equational Theory"
    },
    {
        " or as an ": null
    },
    {
        "operational definition": "Operational Definition"
    },
    {
        ".     As described above, all functions in the lambda calculus are anonymous functions, having no names. They only accept one input variable, with ": null
    },
    {
        "currying": "Currying"
    },
    {
        " used to implement functions with several variables.       The syntax of the lambda calculus defines some expressions as valid lambda calculus expressions and some as invalid, just as some strings of characters are valid ": null
    },
    {
        "C": "C"
    },
    {
        " programs and some are not. A valid lambda calculus expression is called a lambda term .     The following three rules give an ": null
    },
    {
        "inductive definition": "Inductive Definition"
    },
    {
        " that can be applied to build all syntactically valid lambda terms:   a variable, x , is itself a valid lambda term   if t is a lambda term, and x is a variable, then is a lambda term ;   if t and s are lambda terms, then is a lambda term .   Nothing else is a lambda term. Thus a lambda term is valid if and only if it can be obtained by repeated application of these three rules. However, some parentheses can be omitted according to certain rules. For example, the outermost parentheses are usually not written. See  Notation , below.     An abstraction   x.t is a definition of an anonymous function that is capable of taking a single input x and substituting it into the expression t .   It thus defines an anonymous function that takes x and returns t . For example,   x.x2+2 is an abstraction for the function f x2 + 2 using the term x2+2 for t . The definition of a function with an abstraction merely sets up the function but does not invoke it. The abstraction ": null
    },
    {
        "binds": "Free Variables And Bound Variables"
    },
    {
        " the variable x in the term t .     An application ts represents the application of a function t to an input s , that is, it represents the act of calling function t on input s to produce t .     There is no concept in lambda calculus of variable declaration. In a definition such as   x.x+y , the lambda calculus treats y as a variable that is not yet defined. The abstraction   x.x+y is syntactically valid, and represents a function that adds its input to the yet-unknown y .     Bracketing may be used and may be needed to disambiguate terms. For example,   x. and x denote different terms . Here, the first example defines a function whose lambda term is the result of applying x to the child function, while the second example is the application of the outermost function to the input x, which returns the child function. Therefore, both examples evaluate to the ": null
    },
    {
        "identity function": "Identity Function"
    },
    {
        "   x.x .       In lambda calculus, functions are taken to be ": null
    },
    {
        "first class values": "First-Class Object"
    },
    {
        ", so functions may be used as the inputs, or be returned as outputs from other functions.     For example,   x.x represents the ": null
    },
    {
        "identity function": "Identity Function"
    },
    {
        ", x   x , and y represents the identity function applied to y . Further, represents the constant function x   y , the function that always returns y , no matter the input. In lambda calculus, function application is regarded as ": null
    },
    {
        "left-associative": "Operator Associativity"
    },
    {
        ", so that stx means x .     There are several notions of equivalence and reduction that allow lambda terms to be reduced to equivalent lambda terms.       A basic form of equivalence, definable on lambda terms, is alpha equivalence. It captures the intuition that the particular choice of a bound variable, in an abstraction, does not matter.   For instance,   x.x and   y.y are alpha-equivalent lambda terms, and they both represent the same function .   The terms x and y are not alpha-equivalent, because they are not bound in an abstraction.   In many presentations, it is usual to identify alpha-equivalent lambda terms.     The following definitions are necessary in order to be able to define β-reduction:       The free variables of a term are those variables not bound by an abstraction. The set of free variables of an expression is defined inductively:   The free variables of x are just x   The set of free variables of   x.t is the set of free variables of t , but with x removed   The set of free variables of ts is the union of the set of free variables of t and the set of free variables of s .     For example, the lambda term representing the identity   x.x has no free variables, but the function   x. yx has a single free variable, y .       Suppose t , s and r are lambda terms and x and y are variables.   The notation t indicates substitution of r for x in t in a capture-avoiding manner. This is defined so that:   x r ;   y y if x   y ;   ;     x.t ;     y. if x   y and y is not in the free variables of r . The variable y is said to be fresh for r .     For example,   x.   x.x , and y .     The freshness condition is crucial in order to ensure that substitution does not change the meaning of functions.   For example, a substitution is made that ignores the freshness condition:   x.   x.x . This substitution turns the constant function   x.y into the identity   x.x by substitution.     In general, failure to meet the freshness condition can be remedied by alpha-renaming with a suitable fresh variable.   For example, switching back to our correct notion of substitution, in the abstraction can be renamed with a fresh variable z , to obtain   z.   z.x , and the meaning of the function is preserved by substitution.       The β-reduction rule states that an application of the form s reduces to the term t . The notation s   t is used to indicate that s β-reduces to t .   For example, for every s , s   x s . This demonstrates that   x . x really is the identity.   Similarly, s   y y , which demonstrates that   x . y is a constant function.     The lambda calculus may be seen as an idealised version of a functional programming language, like ": null
    },
    {
        "Haskell": "Haskell"
    },
    {
        " or ": null
    },
    {
        "Standard ML": "Standard Ml"
    },
    {
        ".   Under this view, β-reduction corresponds to a computational step. This step can be repeated by additional β-reductions until there are no more applications left to reduce. In the untyped lambda calculus, as presented here, this reduction process may not terminate.   For instance, consider the term   .   Here   .   That is, the term reduces to itself in a single β-reduction, and therefore the reduction process will never terminate.     Another aspect of the untyped lambda calculus is that it does not distinguish between different kinds of data.   For instance, it may be desirable to write a function that only operates on numbers. However, in the untyped lambda calculus, there is no way to prevent a function from being applied to ": null
    },
    {
        "truth value": "Truth Value"
    },
    {
        "s, strings, or other non-number objects.              Lambda expressions are composed of:     variables v 1 , v 2 , …;   the abstraction symbols λ and . ;   parentheses .     The set of lambda expressions, Λ, can be ": null
    },
    {
        "defined inductively": "Recursive Definition"
    },
    {
        "x is a variable, then x ∈ Λ.   If x is a variable and M ∈ Λ, then  ∈ Λ.   If M, N ∈ Λ, then  ∈ Λ.     Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications.  .       To keep the notation of lambda expressions uncluttered, the following conventions are usually applied:   Outermost parentheses are dropped: M N instead of .   Applications are assumed to be left associative: M N P may be written instead of .    The body of an abstraction extends ": null
    },
    {
        "as far right as possible": "Regular Expressionlazy Matching"
    },
    {
        "x.M N means λx. and not  N.   A sequence of abstractions is contracted: λx.λy.λz.N is abbreviated as λxyz.N.          The abstraction operator, λ, is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be bound. In an expression λx.M, the part λx is often called binder, as a hint that the variable x is getting bound by appending λx to M. All other variables are called free. For example, in the expression λy.x x y, y is a bound variable and x is a free variable. Also a variable is bound by its nearest abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: λx.y .     The set of free variables of a lambda expression, M, is denoted as FV and is defined by recursion on the structure of the terms, as follows:   FV , where x is a variable.   FV FV   .   FV FV ∪ FV.      An expression that contains no free variables is said to be closed. Closed lambda expressions are also known as combinators and are equivalent to terms in ": null
    },
    {
        "combinatory logic": "Combinatory Logic"
    },
    {
        ".       The meaning of lambda expressions is defined by how expressions can be reduced.      There are three kinds of reduction:   α-conversionβ-reductionη-reductionα-equivalent, if they can be α-converted into the same expression. β-equivalence and η-equivalence are defined similarly.     The term redex, short for reducible expression, refers to subterms that can be reduced by one of the reduction rules. For example,  N is a β-redex in expressing the substitution of N for x in M. The expression to which a redex reduces is called its reduct; the reduct of  N is Mx : N.     If x is not free in M, λx.M x is also an η-redex, with a reduct of M.       α-conversion, sometimes known as α-renaming,  allows bound variable names to be changed. For example, α-conversion of λx.x might yield λy.y. Terms that differ only by α-conversion are called α-equivalent. Frequently, in uses of lambda calculus, α-equivalent terms are considered to be equivalent.     The precise rules for α-conversion are not completely trivial. First, when α-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an α-conversion of λx.λx.x could result in λy.λx.x, but it could not result in λy.λx.y. The latter has a different meaning from the original. This is analogous to the programming notion of ": null
    },
    {
        "variable shadowing": "Variable Shadowing"
    },
    {
        ".     Second, α-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace x with y in λx.λy.x, we get λy.λy.y, which is not at all the same.     In programming languages with static scope, α-conversion can be used to make ": null
    },
    {
        "name resolution": "Name Resolution"
    },
    {
        " simpler by ensuring that no variable name ": null
    },
    {
        "masks": "Variable Shadowing"
    },
    {
        " a name in a containing ": null
    },
    {
        "scope": "Scope"
    },
    {
        " .     In the ": null
    },
    {
        "De Bruijn index": "De Bruijn Index"
    },
    {
        " notation, any two α-equivalent terms are syntactically identical.       Substitution, written MV : N, is the process of replacing all free occurrences of the variable V in the expression M with expression N. Substitution on terms of the lambda calculus is defined by recursion on the structure of terms, as follows :     : xx : N N   : yx : N y, if x ≠ y   : x : N     : x : N λx.M   : x : N λy., if x ≠ y and y ∉ FV     To substitute into an abstraction, it is sometimes necessary to α-convert the expression. For example, it is not correct for y : x to result in λx.x, because the substituted x was supposed to be free but ended up being bound. The correct substitution in this case is λz.x, up to α-equivalence. Substitution is defined uniquely up to α-equivalence.       β-reduction captures the idea of function application. β-reduction is defined in terms of substitution: the β-reduction of  N is MV : N.     For example, assuming some encoding of 2, 7, ×, we have the following β-reduction:  7 → 7 × 2.     β-reduction can be seen to be the same as the concept of local reducibility in ": null
    },
    {
        "natural deduction": "Natural Deduction"
    },
    {
        ", via the ": null
    },
    {
        "Curry–Howard isomorphism": "Curry–Howard Isomorphism"
    },
    {
        ".       η-reduction expresses the idea of ": null
    },
    {
        "extensionality": "Extensionality"
    },
    {
        ", which in this context is that two functions are the same ": null
    },
    {
        "if and only if": "If And Only If"
    },
    {
        " they give the same result for all arguments. η-reduction converts between λx.f x and f whenever x does not appear free in f.     η-reduction can be seen to be the same as the concept of local completeness in ": null
    },
    {
        "natural deduction": "Natural Deduction"
    },
    {
        ", via the ": null
    },
    {
        "Curry–Howard isomorphism": "Curry–Howard Isomorphism"
    },
    {
        ".          For the untyped lambda calculus, β-reduction as a ": null
    },
    {
        "rewriting rule": "Rewrite System"
    },
    {
        " is neither ": null
    },
    {
        "strongly normalising": "Strongly Normalising"
    },
    {
        " nor ": null
    },
    {
        "weakly normalising": "Weakly Normalising"
    },
    {
        ".     However, it can be shown that β-reduction is ": null
    },
    {
        "confluent": "Confluence"
    },
    {
        " when working up to α-conversion .     Therefore, both strongly normalising terms and weakly normalising terms have a unique normal form. For strongly normalising terms, any reduction strategy is guaranteed to yield the normal form, whereas for weakly normalising terms, some reduction strategies may fail to find it.          The basic lambda calculus may be used to model booleans, ": null
    },
    {
        "arithmetic": "Arithmetic"
    },
    {
        ", data structures and recursion, as illustrated in the following sub-sections.       There are several possible ways to define the ": null
    },
    {
        "natural numbers": "Natural Number"
    },
    {
        "in lambda calculus, but by far the most common are the ": null
    },
    {
        "Church numeral": "Church Numeral"
    },
    {
        "s, which can be defined as follows:   : 0 : λf.λx.x   : 1 : λf.λx.f x   : 2 : λf.λx.f    : 3 : λf.λx.f    and so on. Or using the alternative syntax presented above in  Notation fx.x   : 1 : λfx.f x   : 2 : λfx.f    : 3 : λfx.f      A Church numeral is a ": null
    },
    {
        "higher-order function": "Higher-Order Function"
    },
    {
        "—it takes a single-argument function f , and returns another single-argument function. The Church numeral n is a function that takes a function f as argument and returns the n -th composition of f , i.e. the function f composed with itself n times. This is denoted f  and is in fact the n -th power of f ; f is defined to be the identity function. Such repeated compositions  obey the ": null
    },
    {
        "laws of exponents": "Laws Of Exponents"
    },
    {
        ", which is why these numerals can be used for arithmetic.     One way of thinking about the Church numeral n , which is often useful when analysing programs, is as an instruction repeat n times. For example, using the PAIR and NIL functions defined below, one can define a function that constructs a list of n elements all equal to x by repeating prepend another x element n times, starting from an empty list. The lambda term is   : λn.λx.n  NIL   By varying what is being repeated, and varying what argument that function being repeated is applied to, a great many different effects can be achieved.     We can define a successor function, which takes a Church numeral n and returns n + 1 by adding another application of f , where x means the function f is applied m times on x:   : SUCC : λn.λf.λx.f    Because the m -th composition of f composed with the n -th composition of f gives the m+n -th composition of f , addition can be defined as follows:   : PLUS : λm.λn.λf.λx.m f    PLUS can be thought of as a function taking two natural numbers as arguments and returning a natural number; it can be verified that   : PLUS 2 3   and   : 5   are β-equivalent lambda expressions. Since adding m to a number n can be accomplished by adding 1 m times, an alternative definition is:   : PLUS : λm.λn.m SUCC n & thinsp; ; a note at the original location suggests that the authors consider the work originally referenced to have been superseded by a book.   Similarly, multiplication can be defined as   : MULT : λm.λn.λf.m    Alternatively   : MULT : λm.λn.m  0   since multiplying m and n is the same as repeating the add n function m times and then applying it to zero.   Exponentiation has a rather simple rendering in Church numerals, namely   : POW : λb.λe.e b   The predecessor function defined by PRED n n − 1 for a positive integer n and PRED 0 0 is considerably more difficult. The formula   : PRED : λn.λf.λx.n      can be validated by showing inductively that if T denotes  , then T    for n /tt tt /tt  tt  /tt tt  /tt tt  /tt tt ": null
    }
]