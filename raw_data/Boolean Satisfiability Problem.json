[
    {
        "     In ": null
    },
    {
        "computer science": "Computer Science"
    },
    {
        ", the Boolean satisfiability problem  is the problem of determining if there exists an ": null
    },
    {
        "interpretation": "Interpretation"
    },
    {
        " that ": null
    },
    {
        "satisfies": "Satisfiability"
    },
    {
        " a given ": null
    },
    {
        "Boolean": "Boolean Logic"
    },
    {
        " formula": "Formula"
    },
    {
        ". In other words, it asks whether the variables of a given Boolean formula can be consistently replaced by the values TRUE or FALSE in such a way that the formula ": null
    },
    {
        "evaluates to TRUE": "Validity"
    },
    {
        ". If this is the case, the formula is called satisfiable. On the other hand, if no such assignment exists, the function expressed by the formula is ": null
    },
    {
        "FALSE": "Contradictioncontradiction In Formal Logic"
    },
    {
        " for all possible variable assignments and the formula is unsatisfiable. For example, the formula a AND NOT b is satisfiable because one can find the values a    TRUE and b    FALSE, which make     TRUE. In contrast, a AND NOT a is unsatisfiable.     SAT is the first problem that was proven to be ": null
    },
    {
        "NP-complete": "Np-Complete"
    },
    {
        "; see ": null
    },
    {
        "Cook–Levin theorem": "Cook–Levin Theorem"
    },
    {
        ". This means that all problems in the complexity class ": null
    },
    {
        "NP": "Np"
    },
    {
        ", which includes a wide range of natural decision and optimization problems, are at most as difficult to solve as SAT. There is no known algorithm that efficiently solves each SAT problem, and it is generally believed that no such algorithm exists; yet this belief has not been proven mathematically, and resolving the question of whether SAT has a ": null
    },
    {
        "polynomial-time": "Polynomial-Time"
    },
    {
        " algorithm is equivalent to the ": null
    },
    {
        "P versus NP problem": "P Versus Np Problem"
    },
    {
        ", which is a famous open problem in the theory of computing.     Nevertheless, as of 2007, heuristic SAT-algorithms are able to solve problem instances involving tens of thousands of variables and formulas consisting of millions of symbols, which is sufficient for many practical SAT problems from, e.g., ": null
    },
    {
        "artificial intelligence": "Artificial Intelligence"
    },
    {
        ", ": null
    },
    {
        "circuit design": "Circuit Design"
    },
    {
        ", and ": null
    },
    {
        "automatic theorem proving": "Automatic Theorem Proving"
    },
    {
        ".       A  propositional logic formula, also called Boolean expression, is built from ": null
    },
    {
        "variables": "Variable"
    },
    {
        ", operators AND , OR , NOT , and parentheses.   A formula is said to be satisfiable if it can be made TRUE by assigning appropriate ": null
    },
    {
        "logical values": "Logical Value"
    },
    {
        " to its variables.   The Boolean satisfiability problem is, given a formula, to check whether it is satisfiable.   This ": null
    },
    {
        "decision problem": "Decision Problem"
    },
    {
        " is of central importance in many areas of ": null
    },
    {
        "computer science": "Computer Science"
    },
    {
        ", including ": null
    },
    {
        "theoretical computer science": "Theoretical Computer Science"
    },
    {
        ", ": null
    },
    {
        "complexity theory": "Computational Complexity Theory"
    },
    {
        ", ": null
    },
    {
        "algorithmics": "Algorithmics"
    },
    {
        ", ": null
    },
    {
        "cryptography": "Cryptography"
    },
    {
        " and ": null
    },
    {
        "artificial intelligence": "Artificial Intelligence"
    },
    {
        ".     There are several special cases of the Boolean satisfiability problem in which the formulas are required to have a particular structure. A literal is either a variable, called positive literal, or the negation of a variable, called negative literal.   A clause is a disjunction of literals . A clause is called a  Horn clause  if it contains at most one positive literal.   A formula is in  conjunctive normal form  if it is a conjunction of clauses .   For example,  is a positive literal,  is a negative literal,  is a clause. The formula  is in conjunctive normal form; its first and third clauses are Horn clauses, but its second clause is not. The formula is satisfiable, by choosing x 1    FALSE, x 2    FALSE, and x 3 arbitrarily, since ∧  ∧ ¬FALSE evaluates to ∧  ∧ TRUE, and in turn to TRUE ∧ TRUE ∧ TRUE . In contrast, the CNF formula a ∧ ¬a, consisting of two clauses of one literal, is unsatisfiable, since for aTRUE or aFALSE it evaluates to TRUE ∧ ¬TRUE or FALSE ∧ ¬FALSE , respectively.     For some versions of the SAT problem,  it is useful to define the notion of a generalized conjunctive normal form formula, viz. as a conjunction of arbitrarily many generalized clauses, the latter being of the form  for some boolean operator R and literals . Different sets of allowed boolean operators lead to different problem versions.  As an example, R is a generalized clause, and R ∧ R ∧ R is a generalized conjunctive normal form. This formula is used ": null
    },
    {
        "below": "Exactly-1 3-Satisfiability"
    },
    {
        ", with R being the ternary operator that is TRUE just when exactly one of its arguments is.        Using the laws of ": null
    },
    {
        "Boolean algebra": "Boolean Algebra"
    },
    {
        ", every propositional logic formula can be transformed into an equivalent conjunctive normal form, which may, however, be exponentially longer. For example, transforming the formula    ∨  ∨ ... ∨    into conjunctive normal form yields   :   :   :   :   :   :   :   :;   while the former is a disjunction of n conjunctions of 2 variables, the latter consists of 2 n clauses of n variables.                SAT was the first known ": null
    },
    {
        "NP-complete": "Np-Complete"
    },
    {
        " problem, as proved by ": null
    },
    {
        "Stephen Cook": "Stephen Cook"
    },
    {
        " at the ": null
    },
    {
        "University of Toronto": "University Of Toronto"
    },
    {
        " in 1971  and independently by ": null
    },
    {
        "Leonid Levin": "Leonid Levin"
    },
    {
        " at the ": null
    },
    {
        "National Academy of Sciences": "Russian Academy Of Sciencesthe Academy Of Sciences Of The Ussr"
    },
    {
        " in 1973.   , translated into English by  Until that time, the concept of an NP-complete problem did not even exist.   The proof shows how every decision problem in the ": null
    },
    {
        "complexity class": "Complexity Class"
    },
    {
        " NP": "Np"
    },
    {
        " can be ": null
    },
    {
        "reduced": "Reduction"
    },
    {
        " to the SAT problem for CNF The SAT problem for arbitrary formulas is NP-complete, too, since it is easily shown to be in NP, and it cannot be easier than SAT for CNF formulas. formulas, sometimes called CNFSAT.   A useful property of Cooks reduction is that it preserves the number of accepting answers. For example, deciding whether a given ": null
    },
    {
        "graph": "Graph"
    },
    {
        " has a ": null
    },
    {
        "3-coloring": "Graph Coloringvertex Coloring"
    },
    {
        " is another problem in NP; if a graph has 17 valid 3-colorings, the SAT formula produced by the Cook–Levin reduction will have 17 satisfying assignments.     NP-completeness only refers to the run-time of the worst case instances. Many of the instances that occur in practical applications can be solved much more quickly. See ": null
    },
    {
        "Algorithms for solving SAT": "Algorithms For Solving Sat"
    },
    {
        " below.     SAT is trivial if the formulas are restricted to those in  disjunctive normal form , that is, they are disjunction of conjunctions of literals. Such a formula is indeed satisfiable if and only if at least one of its conjunctions is satisfiable, and a conjunction is satisfiable if and only if it does not contain both x and NOT x for some variable x. This can be checked in linear time. Furthermore, if they are restricted to being in full disjunctive normal form, in which every variable appears exactly once in every conjunction, they can be checked in constant time . But it can take exponential time and space to convert a general SAT problem to disjunctive normal form; for an example exchange ∧ and ∨ in the ": null
    },
    {
        "above": "Basic Definitions And Terminology"
    },
    {
        " exponential blow-up example for conjunctive normal forms.          Like the satisfiability problem for arbitrary formulas, determining the satisfiability of a formula in conjunctive normal form where each clause is limited to at most three literals is NP-complete also; this problem is called 3-SAT, 3CNFSAT, or 3-satisfiability.   To reduce the unrestricted SAT problem to 3-SAT, transform each clause  to a conjunction of n − 2 clauses   :   :   :   :   :   where  are fresh variables not occurring elsewhere.   Although the two formulas are not ": null
    },
    {
        "logically equivalent": "Logically Equivalent"
    },
    {
        ", they are ": null
    },
    {
        "equisatisfiable": "Equisatisfiable"
    },
    {
        ". The formula resulting from transforming all clauses is at most 3 times as long as its original, i.e. the length growth is polynomial. ; here: Thm.10.4     3-SAT is one of ": null
    },
    {
        "Karps 21 NP-complete problems": "Karps 21 Np-Complete Problems"
    },
    {
        ", and it is used as a starting point for proving that other problems are also ": null
    },
    {
        "NP-hard": "Np-Hard"
    },
    {
        ". i.e. at least as hard as every other problem in NP. A decision problem is NP-complete if and only if it is in NP and is NP-hard. This is done by ": null
    },
    {
        "polynomial-time reduction": "Polynomial-Time Reduction"
    },
    {
        " from 3-SAT to the other problem. An example of a problem where this method has been used is the ": null
    },
    {
        "clique problem": "Clique Problem"
    },
    {
        "c clauses, the corresponding ": null
    },
    {
        "graph": "Graph"
    },
    {
        " consists of a vertex for each literal, and an edge between each two non-contradicting i.e. such that one literal is not the negation of the other literals from different clauses, cf. picture. The graph has a c-clique if and only if the formula is satisfiable.     There is a simple randomized algorithm due to Schöning that runs in time n where n is the number of variables in the 3-SAT proposition, and succeeds with high probability to correctly decide 3-SAT.      The ": null
    },
    {
        "exponential time hypothesis": "Exponential Time Hypothesis"
    },
    {
        " asserts that no algorithm can solve 3-SAT  ref  /ref  k literals can be padded with fixed dummy variables to   .   After padding all clauses, 2 k -1 extra clauses viz. all ": null
    },
    {
        "maxterms": "Canonical Form Maxterms"
    },
    {
        " that can be built with , except  have to be appended to ensure that only  can lead to a satisfying assignment. Since k doesnt depend on the formula length, the extra clauses lead to a constant increase in length. For the same reason, it does not matter whether duplicate literals are allowed in clauses , or not.          A variant of the 3-satisfiability problem is the one-in-three 3-SAT .   Given a conjunctive normal form with three literals per clause, the problem is to determine whether there exists a truth assignment to the variables so that each clause has exactly one TRUE literal . In contrast, ordinary 3-SAT requires that every clause has at least one TRUE literal.   Formally, a one-in-three 3-SAT problem is given as a generalized conjunctive normal form with all generalized clauses using a ternary operator R that is TRUE just if exactly one of its arguments is. When all literals of a one-in-three 3-SAT formula are positive, the satisfiability problem is called one-in-three positive 3-SAT.     One-in-three 3-SAT, together with its positive case, is listed as NP-complete problem LO4 in the standard reference, Computers and Intractability: A Guide to the Theory of NP-Completeness   by ": null
    },
    {
        "Michael R. Garey": "Michael R. Garey"
    },
    {
        " and ": null
    },
    {
        "David S. Johnson": "David S. Johnson"
    },
    {
        ". One-in-three 3-SAT was proved to be NP-complete by ": null
    },
    {
        "Thomas Jerome Schaefer": "Thomas Jerome Schaefer"
    },
    {
        " as a special case of ": null
    },
    {
        "Schaefers dichotomy theorem": "Schaefers Dichotomy Theorem"
    },
    {
        ", which asserts that any problem generalizing Boolean satisfiability in a certain way is either in the class P or is NP-complete.      Schaefer gives a construction allowing an easy polynomial-time reduction from 3-SAT to one-in-three 3-SAT. Let  be a clause in a 3CNF formula. Add six fresh boolean variables a, b, c, d, e, and f, to be used to simulate this clause and no other.      Then the formula R ∧ R ∧ R ∧ R ∧ R is satisfiable by some setting of the fresh variables if and only if at least one of x, y, or z is TRUE, see picture . Thus any 3-SAT instance with m clauses and n variables may be converted into an ": null
    },
    {
        "equisatisfiable": "Equisatisfiable"
    },
    {
        " one-in-three 3-SAT instance with 5m clauses and n+6m variables. , p.222, Lemma 3.5   Another reduction involves only four fresh variables and three clauses: R ∧ R ∧ R, see picture .          Another variant is the not-all-equal 3-satisfiability problem .   Given a conjunctive normal form with three literals per clause, the problem is to determine if an assignment to the variables exists such that in no clause all three literals have the same truth value. This problem is NP-complete, too, even if no negation symbols are admitted, by Schaefers dichotomy theorem.            SAT is easier if the number of literals in a clause is limited to at most 2, in which case the problem is called  2-SAT . This problem can be solved in polynomial time, and in fact is ": null
    },
    {
        "complete": "Nl-Complete"
    },
    {
        " for the complexity class ": null
    },
    {
        "NL": "Nl"
    },
    {
        ". If additionally all OR operations in literals are changed to ": null
    },
    {
        "XOR": "Exclusive Or"
    },
    {
        " operations, the result is called exclusive-or 2-satisfiability, which is a problem complete for the complexity class ": null
    },
    {
        "SL": "Sl"
    },
    {
        " L": "L"
    },
    {
        ".            The problem of deciding the satisfiability of a given conjunction of ": null
    },
    {
        "Horn clauses": "Horn Clause"
    },
    {
        " is called Horn-satisfiability, or HORN-SAT.   It can be solved in polynomial time by a single step of the ": null
    },
    {
        "Unit propagation": "Unit Propagation"
    },
    {
        " algorithm, which produces the single minimal model of the set of Horn clauses .   Horn-satisfiability is ": null
    },
    {
        "P-complete": "P-Complete"
    },
    {
        ". It can be seen as ": null
    },
    {
        "Ps": "P"
    },
    {
        " version of the Boolean satisfiability problem.   Also, deciding the truth of quantified Horn formulas can be done in polynomial time.        Horn clauses are of interest because they are able to express ": null
    },
    {
        "implication": "Entailment"
    },
    {
        " of one variable from a set of other variables. Indeed, one such clause ¬x 1 ∨ ... ∨ ¬x n ∨ y can be rewritten as x 1 ∧ ... ∧ x n → y, that is, if x 1 ,...,x n are all TRUE, then y needs to be TRUE as well.     A generalization of the class of Horn formulae is that of renameable-Horn formulae, which is the set of formulae that can be placed in Horn form by replacing some variables with their respective negation.   For example,  ∧  ∧ ¬x 1 is not a Horn formula, but can be renamed to the Horn formula  ∧  ∧ ¬x 1 by introducing y 3 as negation of x 3 .   In contrast, no renaming of  ∧  ∧ ¬x 1 leads to a Horn formula.   Checking the existence of such a replacement can be done in linear time; therefore, the satisfiability of such formulae is in P as it can be solved by first performing this replacement and then checking the satisfiability of the resulting Horn formula.                   Another special case is the class of problems where each clause contains XOR  rather than OR operators. Formally, generalized conjunctive normal forms with a ternary boolean operator R are employed, which is TRUE just if 1 or 3 of its arguments is. An input clause with more than 3 literals can be transformed into an equisatisfiable conjunction of clauses á 3 literals similar to ": null
    },
    {
        "above": "3-Satisfiability"
    },
    {
        "; i.e. XOR-SAT can be reduced to XOR-3-SAT.   This is in ": null
    },
    {
        "P": "P"
    },
    {
        ", since an XOR-SAT formula can also be viewed as a system of linear equations mod 2, and can be solved in cubic time by ": null
    },
    {
        "Gaussian elimination": "Gaussian Elimination"
    },
    {
        "; . see the box for an example. This recast is based on the ": null
    },
    {
        "kinship between Boolean algebras and Boolean rings": "Boolean Algebra Boolean Rings"
    },
    {
        ", and the fact that arithmetic modulo two forms a ": null
    },
    {
        "finite field": "Finite Field"
    },
    {
        ". Since a XOR b XOR c evaluates to TRUE if and only if exactly 1 or 3 members of  are TRUE, each solution of the 1-in-3-SAT problem for a given CNF formula is also a solution of the XOR-3-SAT problem, and in turn each solution of XOR-3-SAT is a solution of 3-SAT, cf. picture. As a consequence, for each CNF formula, it is possible to solve the XOR-3-SAT problem defined by the formula, and based on the result infer either that the 3-SAT problem is solvable or that the 1-in-3-SAT problem is unsolvable.     Provided that the ": null
    },
    {
        "complexity classes P and NP are not equal": "P  Np Problem"
    },
    {
        ", neither 2-, nor Horn-, nor XOR-satisfiability is NP-complete, unlike SAT.          The restrictions above bound the considered formulae to be conjunctions of subformulae; each restriction states a specific form for all subformulae: for example, only binary clauses can be subformulae in 2CNF.     Schaefers dichotomy theorem states that, for any restriction to Boolean operators that can be used to form these subformulae, the corresponding satisfiability problem is in P or NP-complete. The membership in P of the satisfiability of 2CNF, Horn, and XOR-SAT formulae are special cases of this theorem.       An extension that has gained significant popularity since 2003 is  satisfiability modulo theories   that can enrich CNF formulas with linear constraints, arrays, all-different constraints, ": null
    },
    {
        "uninterpreted functions": "Uninterpreted Function"
    },
    {
        ", R. E. Bryant, S. M. German, and M. N. Velev, , in Analytic Tableaux and Related Methods, pp.  1–13, 1999. etc. Such extensions typically remain NP-complete, but very efficient solvers are now available that can handle many such kinds of constraints.     The satisfiability problem becomes more difficult if both for all  and there exists  ": null
    },
    {
        "quantifiers": "Quantifier"
    },
    {
        " are allowed to bind the Boolean variables.   An example of such an expression would be ; it is valid, since for all values of x and y, an appropriate value of z can be found, viz. zTRUE if both x and y are FALSE, and zFALSE else.   SAT itself uses only ∃ quantifiers.   If only ∀ quantifiers are allowed instead, the so-called  tautology problem is obtained, which is ": null
    },
    {
        "co-NP-complete": "Co-Np-Complete"
    },
    {
        ".   If both quantifiers are allowed, the problem is called the  quantified Boolean formula problem  , which can be shown to be ": null
    },
    {
        "PSPACE-complete": "Pspace-Complete"
    },
    {
        ". It is widely believed that PSPACE-complete problems are strictly harder than any problem in NP, although this has not yet been proved. Using highly parallel  P system s, QBF-SAT problems can be solved in linear time.      Ordinary SAT asks if there is at least one variable assignment that makes the formula true. A variety of variants deal with the number of such assignments:   MAJ-SAT asks if the majority of all assignments make the formula TRUE. It is known to be complete for ": null
    },
    {
        "PP": "Pp"
    },
    {
        ", a probabilistic class.    SAT , the problem of counting how many variable assignments satisfy a formula, is a counting problem, not a decision problem, and is ": null
    },
    {
        "P-complete": "Sharp-P-Complete"
    },
    {
        ".   UNIQUE-SAT is the problem of determining whether a formula has exactly one assignment. It is complete for ": null
    },
    {
        "US": "Us"
    },
    {
        ", the ": null
    },
    {
        "complexity class": "Complexity Class"
    },
    {
        " describing problems solvable by a non-deterministic polynomial time ": null
    },
    {
        "Turing machine": "Turing Machine"
    },
    {
        " that accepts when there is exactly one nondeterministic accepting path and rejects otherwise.   UNAMBIGUOUS-SAT is the name given to the satisfiability problem when the input is ": null
    },
    {
        "restricted": "Promise Problem"
    },
    {
        " to formulas having at most one satisfying assignment. The problem is also called USAT  . A solving algorithm for UNAMBIGUOUS-SAT is allowed to exhibit any behavior, including endless looping, on a formula having several satisfying assignments. Although this problem seems easier, Valiant and Vazirani have ": null
    },
    {
        "shown": "Valiant-Vazirani Theorem"
    },
    {
        "  that if there is a practical  algorithm to solve it, then all problems in ": null
    },
    {
        "NP": "Np"
    },
    {
        " can be solved just as easily.   MAX-SAT, the ": null
    },
    {
        "maximum satisfiability problem": "Maximum Satisfiability Problem"
    },
    {
        ", is an ": null
    },
    {
        "FNP": "Fnp"
    },
    {
        " generalization of SAT. It asks for the maximum number of clauses, which can be satisfied by any assignment. It has efficient ": null
    },
    {
        "approximation algorithms": "Approximation Algorithm"
    },
    {
        ", but is NP-hard to solve exactly. Worse still, it is ": null
    },
    {
        "APX": "Apx"
    },
    {
        "-complete, meaning there is no ": null
    },
    {
        "polynomial-time approximation scheme": "Polynomial-Time Approximation Scheme"
    },
    {
        " for this problem unless PNP.   WMSAT is the problem of finding an assignment of minimum weight that satisfy a monotone Boolean formula . Weights of propositional variables are given in the input of the problem. The weight of an assignment is the sum of weights of true variables. That problem is NP-complete .     Other generalizations include satisfiability for ": null
    },
    {
        "first": "First-Order Predicate Calculus"
    },
    {
        "- and ": null
    },
    {
        "second-order logic": "Second-Order Logic"
    },
    {
        ", ": null
    },
    {
        "constraint satisfaction problems": "Constraint Satisfaction Problem"
    },
    {
        ", ": null
    },
    {
        "0-1 integer programming": "0-1 Integer Programming"
    },
    {
        ".       The SAT problem is self-reducible, that is, each algorithm which correctly answers if an instance of SAT is solvable can be used to find a satisfying assignment. First, the question is asked on the given formula Φ. If the answer is no , the formula is unsatisfiable. Otherwise, the question is asked on the partly instantiated formula Φ, i.e. Φ with the first variable x 1 replaced by TRUE, and simplified accordingly. If the answer is yes , then x 1 TRUE, otherwise x 1 FALSE. Values of other variables can be found subsequently in the same way. In total, n+1 runs of the algorithm are required, where n is the number of distinct variables in Φ.     This property of self-reducibility is used in several theorems in complexity theory:     : ": null
    },
    {
        "NP": "Np"
    },
    {
        " ⊆ ": null
    },
    {
        "P/poly": "P/Poly"
    },
    {
        " ⇒ ": null
    },
    {
        "PH": "Ph"
    },
    {
        " Σ 2 ": "Polynomial Hierarchydefinitions"
    },
    {
        "      : ": null
    },
    {
        "NP": "Np"
    },
    {
        " ⊆ ": null
    },
    {
        "BPP": "Bpp"
    },
    {
        " ⇒ ": null
    },
    {
        "NP": "Np"
    },
    {
        " RP": "Rp"
    },
    {
        "   : ": null
    },
    {
        "P": "P"
    },
    {
        " NP": "Np"
    },
    {
        " ⇒ ": null
    },
    {
        "FP": "Fp"
    },
    {
        " FNP": "Fnp"
    },
    {
        "         Since the SAT problem is NP-complete, only algorithms with exponential worst-case complexity are known for it. In spite of this, efficient and scalable algorithms for SAT were developed during the 2000s and have contributed to dramatic advances in our ability to automatically solve problem instances involving tens of thousands of variables and millions of constraints . . Examples of such problems in ": null
    },
    {
        "electronic design automation": "Electronic Design Automation"
    },
    {
        " include ": null
    },
    {
        "formal equivalence checking": "Formal Equivalence Checking"
    },
    {
        ", ": null
    },
    {
        "model checking": "Model Checking"
    },
    {
        ", ": null
    },
    {
        "formal verification": "Formal Verification"
    },
    {
        " of ": null
    },
    {
        "pipelined microprocessors": "Microprocessor"
    },
    {
        ", ": null
    },
    {
        "automatic test pattern generation": "Automatic Test Pattern Generation"
    },
    {
        ", ": null
    },
    {
        "routing": "Routing"
    },
    {
        " of ": null
    },
    {
        "FPGAs": "Fpga"
    },
    {
        ",  ": null
    },
    {
        "planning": "Automated Planning And Scheduling"
    },
    {
        ", and ": null
    },
    {
        "scheduling problems": "Scheduling Algorithm"
    },
    {
        ", and so on. A SAT-solving engine is now considered to be an essential component in the ": null
    },
    {
        "EDA": "Electronic Design Automation"
    },
    {
        " toolbox.     There are two classes of high-performance ": null
    },
    {
        "algorithms": "Algorithms"
    },
    {
        " for solving instances of SAT in practice: the ": null
    },
    {
        "conflict-driven clause learning": "Conflict-Driven Clause Learning"
    },
    {
        " algorithm, which can be viewed as a modern variant of the ": null
    },
    {
        "DPLL algorithm": "Dpll Algorithm"
    },
    {
        "  and ": null
    },
    {
        "stochastic": "Stochastic"
    },
    {
        " local search": "Local Search"
    },
    {
        " algorithms, such as ": null
    },
    {
        "WalkSAT": "Walksat"
    },
    {
        ".     A DPLL SAT solver employs a systematic backtracking search procedure to explore the space of variable assignments looking for satisfying assignments. The basic search procedure was proposed in two seminal papers in the early 1960s and is now commonly referred to as the ": null
    },
    {
        "Davis–Putnam–Logemann–Loveland algorithm": "Davis–Putnam–Logemann–Loveland Algorithm"
    },
    {
        " .   Theoretically, exponential lower bounds have been proved for the DPLL family of algorithms.     In contrast, randomized algorithms like the PPSZ algorithm by Paturi, Pudlak, Saks, and Zane set variables in a random order according to some heuristics, for example bounded-width ": null
    },
    {
        "resolution": "Resolution"
    },
    {
        ". If the heuristic cant find the correct setting, the variable is assigned randomly. The PPSZ algorithm has a runtime of O for 3-SAT. This was the best-known runtime for this problem until a recent improvement by Hansen, Kaplan, Zamir and Zwick that has a runtime of O for 3-SAT and currently the best known runtime for k-SAT, for all values of k. In the setting with many satisfying assignments the randomized algorithm by Schöning has a better bound. , Paturi, Pudlak, Saks, Zani , Hansen, Kaplan, Zamir, Zwick     Modern SAT solvers come in two flavors: conflict-driven and look-ahead . Conflict-driven solvers augment the basic DPLL search algorithm with efficient conflict analysis, clause learning, non-": null
    },
    {
        "chronological backtracking": "Chronological Backtracking"
    },
    {
        " , as well as ": null
    },
    {
        " two-watched-literals unit propagation": "Two-Watched-Literals   Unit Propagation"
    },
    {
        ", adaptive branching, and random restarts. These extras to the basic systematic search have been empirically shown to be essential for handling the large SAT instances that arise in ": null
    },
    {
        "electronic design automation": "Electronic Design Automation"
    },
    {
        " .  Look-ahead solvers have especially strengthened reductions and the heuristics, and they are generally stronger than conflict-driven solvers on hard instances .     Modern SAT solvers are also having significant impact on the fields of software verification, constraint solving in artificial intelligence, and operations research, among others. Powerful solvers are readily available as ": null
    },
    {
        "free and open source software": "Free And Open Source Software"
    },
    {
        ". In particular, the conflict-driven , which was relatively successful at the , only has about 600 lines of code. A modern Parallel SAT solver is ManySAT  . It can achieve super linear speed-ups on important classes of problems. An example for look-ahead solvers is , which won a prize at the .     Certain types of large random satisfiable instances of SAT can be solved by ": null
    },
    {
        "survey propagation": "Survey Propagation"
    },
    {
        " . Particularly in ": null
    },
    {
        "hardware design": "Hardware Design"
    },
    {
        " and ": null
    },
    {
        "verification": "Hardware Verification"
    },
    {
        " applications, satisfiability and other logical properties of a given propositional formula are sometimes decided based on a representation of the formula as a ": null
    },
    {
        "binary decision diagram": "Binary Decision Diagram"
    },
    {
        " .     Almost all SAT solvers include time-outs, so they will terminate in reasonable time even if they cannot find a solution.   Different SAT solvers will find different instances easy or hard, and some excel at proving unsatisfiability, and others at finding solutions.   All of these behaviors can be seen in the SAT solving contests. ": null
    }
]