In  |computational_complexity_theory|Computational_Complexity_Theory| , the complexity class P is the set of the  |counting_problems|Counting_Problem|  associated with the  |decision_problems|Decision_Problem|  in the set  NP . More formally, P is the class of function problems of the form compute f , where f is the number of accepting paths of a  |nondeterministic_Turing_machine|Nondeterministic_Turing_Machine|  running in  |polynomial_time|Time_Complexitypolynomial_Time| . Unlike most well-known complexity classes, it is not a class of  |decision_problems|Decision_Problem|  but a class of  |function_problems|Function_Problem| .       An NP decision problem is often of the form Are there any solutions that satisfy certain constraints? For example:   Are there any subsets of a list of integers that add up to zero?    Are there any  |Hamiltonian_cycles|Hamiltonian_Cycle|  in a given  |graph|Graph_Theory|  with cost less than 100?    Are there any variable assignments that satisfy a given  |CNF_|Conjunctive_Normal_Form|  formula?      The corresponding P function problems ask how many rather than are there any . For example:   How many subsets of a list of integers add up to zero?   How many Hamiltonian cycles in a given graph have cost less than 100?   How many variable assignments satisfy a given CNF formula?       Clearly, a P problem must be at least as hard as the corresponding NP problem. If its easy to count answers, then it must be easy to tell whether there are any answers—just count them and see whether the count is greater than zero.     One consequence of  |Todas_theorem|Todas_Theorem|  is that a  |polynomial_time|Time_Complexitypolynomial_Time|  machine with a P  |oracle|Oracle_Machine|   can solve all problems in  PH , the entire  |polynomial_hierarchy|Polynomial_Hierarchy| . In fact, the polynomial-time machine only needs to make one P query to solve any problem in PH. This is an indication of the extreme difficulty of solving P-complete problems exactly.     Surprisingly, some P problems that are believed to be difficult correspond to easy  P  problems. For more information on this, see  |P_complete|Sharp_P_Complete| .     The closest decision problem class to P is  PP , which asks whether a majority of the computation paths accept. This finds the most significant bit in the P problem answer. The decision problem class  & oplus;P  instead asks for the least significant bit of the P answer.       The complexity class P was first defined by  |Leslie_Valiant|Leslie_Valiant|  in a 1979 article on the computation of the  |permanent|Permanent| , in which he proved that  |permanent_is_P_complete|Permanent_Is_Sharp_P_Complete| .       |Larry_Stockmeyer|Larry_Stockmeyer|  has proved that for every P problem P there exists a randomized algorithm using an oracle for SAT, which given an instance a of P and ε  math /math ref  /ref  .