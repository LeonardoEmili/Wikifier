[
    {
        "     In ": null
    },
    {
        "theoretical computer science": "Theoretical Computer Science"
    },
    {
        ", a nondeterministic Turing machine is a theoretical model of computation. They are used in ": null
    },
    {
        "thought experiments": "Thought Experiment"
    },
    {
        "to examine the abilities and limitations of computers. One of the most important open problems in theoretical computer science is the ": null
    },
    {
        "P vs. NP problem": "P Vs. Np Problem"
    },
    {
        ", which concerns the question of how difficult it is to simulate nondeterministic computation with a deterministic computer.       In essence, a Turing machine is imagined to be a simple computer that reads and writes symbols one at a time on an endless tape by strictly following a set of rules. It determines what action it should perform next according to its internal state and what symbol it currently sees. An example of one of a Turing Machines rules might thus be: If you are in state 2 and you see an A, change it to B, move left, and change to state 3.       In a ": null
    },
    {
        "deterministic Turing machine": "Deterministic Turing Machine"
    },
    {
        " , the set of rules prescribes at most one action to be performed for any given situation.     A deterministic Turing machine has a transition function that, for a given state and symbol under the tape head, specifies three things:   the symbol to be written to the tape,   the direction in which the head should move, and   the subsequent state of the finite control.   For example, an X on the tape in state 3 might make the DTM write a Y on the tape, move the head one position to the right, and switch to state 5.       By contrast, in a nondeterministic Turing machine , the set of rules may prescribe more than one action to be performed for any given situation. For example, an X on the tape in state 3 might allow the NTM to:   Write a Y, move right, and switch to state 5   or ": null
    },
    {
        "branches": "Many-Worlds Theory"
    },
    {
        " into many copies, each of which follows one of the possible transitions. Whereas a DTM has a single computation path that it follows, an NTM has a computation tree . If at least one branch of the tree halts with an accept condition, we say that the NTM accepts the input.       A nondeterministic Turing machine can be formally defined as a 6-tuple M , where   Q is a finite set of states     is a finite set of symbols       Q is the initial state         is the blank symbol   A   Q is the set of accepting states             is a relation on states and symbols called the transition relation. L is the movement to the left, S is no movement, and R is the movement to the right.     The difference with a standard ": null
    },
    {
        "Turing machine": "Turing Machine"
    },
    {
        " is that for those, the transition relation is a function .     Configurations and the yields relation on configurations, which describes the possible actions of the Turing machine given any possible contents of the tape, are as for standard Turing machines, except that the yields relation is no longer single-valued.     The input for an NTM is provided in the same manner as for a deterministic Turing machine: the machine is started in the configuration in which the tape head is on the first character of the string , and the tape is all blank otherwise.     An NTM accepts an input string if and only if at least one of the possible computational paths starting from that string puts the machine into an accepting state. When simulating the many branching paths of an NTM on a deterministic machine, we can stop the entire simulation as soon as any branch reaches an accepting state.       As a mathematical construction used primarily in proofs, there are a variety of minor variations on the definition of an NTM, but these variations all accept equivalent languages.     The head movement in the output of the transition relation is often encoded numerically instead of using letters to represent moving the head Left , Stationary , and Right ; giving a transition function output of   . It is common to omit the stationary output,  and instead insert the transitive closure of any desired stationary transitions.     Some authors add an explicit reject state,    which causes the NTM to halt without accepting. This definition still retains the asymmetry that any nondeterministic branch can accept, but every branch must reject for the string to be rejected.       Any computational problem that can be solved by a DTM can also be solved by a NTM, and vice versa. However, it is believed that in general the ": null
    },
    {
        "time complexity": "Time Complexity"
    },
    {
        " may not be the same.       NTMs include DTMs as special cases, so every computation that can be carried out by a DTM can also be carried out by the equivalent NTM.       It might seem that NTMs are more powerful than DTMs, since they can allow trees of possible computations arising from the same initial configuration, accepting a string if any one branch in the tree accepts it. However, it is possible to simulate NTMs with DTMs, and in fact this can be done in more than one way.       One approach is to use a DTM of which the configurations represent multiple configurations of the NTM, and the DTMs operation consists of visiting each of them in turn, executing a single step at each visit, and spawning new configurations whenever the transition relation defines multiple continuations.       Another construction simulates NTMs with 3-tape DTMs, of which the first tape always holds the original input string, the second is used to simulate a particular computation of the NTM, and the third encodes a path in the NTMs computation tree. Elements of the Theory of Computation, by Harry R. Lewis and Christos H. Papadimitriou, Prentice-Hall, Englewood Cliffs, New Jersey, 1981, , pp. 206â€“211 The 3-tape DTMs are easily simulated with a normal single-tape DTM.          In the second construction, the constructed DTM effectively performs a ": null
    },
    {
        "breadth-first search": "Breadth-First Search"
    },
    {
        " of the NTMs computation tree, visiting all possible computations of the NTM in order of increasing length until it finds an accepting one. Therefore, the length of an accepting computation of the DTM is, in general, exponential in the length of the shortest accepting computation of the NTM. This is believed to be a general property of simulations of NTMs by DTMs. The ": null
    },
    {
        "P NP problem": "P  Np Problem"
    },
    {
        ", the most famous unresolved question in computer science, concerns one case of this issue: whether or not every problem solvable by a NTM in polynomial time is necessarily also solvable by a DTM in polynomial time.       An NTM has the property of bounded nondeterminism. That is, if an NTM always halts on a given input tape T then it halts in a bounded number of steps, and therefore can only have a bounded number of possible configurations.          Because ": null
    },
    {
        "quantum computers": "Quantum Computer"
    },
    {
        "use ": null
    },
    {
        "quantum bit": "Quantum Bit"
    },
    {
        "s, which can be in ": null
    },
    {
        "superpositions": "Quantum Superposition"
    },
    {
        "of states, rather than conventional bits, there is a misconception that ": null
    },
    {
        "quantum computers": "Quantum Computer"
    },
    {
        "are NTMs. , ": null
    },
    {
        "Scott Aaronson": "Scott Aaronson"
    },
    {
        ". It is believed by experts that instead, the power of quantum computers is incomparable to that of NTMs, that is, problems likely exist that an NTM could efficiently solve that a quantum computer cannot and vice versa. .  In particular, it is likely that ": null
    },
    {
        "NP-complete": "Np-Complete"
    }
]