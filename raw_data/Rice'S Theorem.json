[
    {
        "In ": null
    },
    {
        "computability theory": "Computability Theory"
    },
    {
        ", Rices theorem states that all non-trivial, ": null
    },
    {
        "semantic": "Semantics"
    },
    {
        " properties of programs are ": null
    },
    {
        "undecidable": "Decision Problem"
    },
    {
        ". A semantic property is one about the programs behavior , unlike a syntactic property . A property is non-trivial if it is neither true for every computable function, nor false for every computable function.     Rices theorem can also be put in terms of functions: for any non-trivial property of ": null
    },
    {
        "partial functions": "Partial Functions"
    },
    {
        ", no general and effective method can decide whether an ": null
    },
    {
        "algorithm": "Algorithm"
    },
    {
        " computes a partial function with that property. Here, a property of partial functions is called trivial if it holds for all ": null
    },
    {
        "partial computable functions": "Partial Computable Function"
    },
    {
        " or for none, and an effective decision method is called general if it decides correctly for every algorithm.   The theorem is named after ": null
    },
    {
        "Henry Gordon Rice": "Henry Gordon Rice"
    },
    {
        ", who proved it in his doctoral dissertation of 1951 at ": null
    },
    {
        "Syracuse University": "Syracuse University"
    },
    {
        ".       Another way of stating Rices theorem that is more useful in ": null
    },
    {
        "computability theory": "Computability Theory"
    },
    {
        " follows.     Let S be a set of ": null
    },
    {
        "languages": "Formal Language"
    },
    {
        " that is nontrivial, meaning   there exists a Turing machine that recognizes a language in S,   there exists a Turing machine that recognizes a language not in S.   Then it is ": null
    },
    {
        "undecidable": "Decision Problem"
    },
    {
        " to determine whether the language recognized by an arbitrary ": null
    },
    {
        "Turing machine": "Turing Machine"
    },
    {
        " lies in S.     In practice, this means that there is no machine that can always decide whether the language of a given Turing machine has a particular nontrivial property. Special cases include the undecidability of whether a Turing machine accepts a particular string, whether a Turing machine recognizes a particular recognizable language, and whether the language recognized by a Turing machine could be recognized by a nontrivial simpler machine, such as a ": null
    },
    {
        "finite automaton": "Finite Automaton"
    },
    {
        ".     It is important to note that Rices theorem does not say anything about those properties of machines or programs that are not also properties of functions and languages. For example, whether a machine runs for more than 100 steps on a particular input is a decidable property, even though it is non-trivial. Implementing exactly the same language, two different machines might require a different number of steps to recognize the same input. Similarly, whether a machine has more than 5 states is a decidable property of the machine, as the number of states can simply be counted. Where a property is of the kind that either of the two machines may or may not have it, while still implementing exactly the same language, the property is of the machines and not of the language, and Rices Theorem does not apply.     Using ": null
    },
    {
        "Rogers": "Hartley Rogers, Jr"
    },
    {
        " characterization of ": null
    },
    {
        "acceptable programming systems": "Rogers Equivalence Theorem"
    },
    {
        ", Rices Theorem may essentially be generalized from Turing machines to most computer ": null
    },
    {
        "programming languages": "Programming Language"
    },
    {
        ": there exists no automatic method that decides with generality non-trivial questions on the behavior of computer programs.     As an example, consider the following variant of the ": null
    },
    {
        "halting problem": "Halting Problem"
    },
    {
        ". Let P be the following property of partial functions F of one argument: P means that F is defined for the argument 1. It is obviously non-trivial, since there are partial functions that are defined at 1, and others that are undefined at 1. The 1-halting problem is the problem of deciding of any algorithm whether it defines a function with this property,   i.e., whether the algorithm halts on input 1. By Rices theorem, the 1-halting problem is undecidable. Similarly the question of whether a Turing machine T terminates on an initially empty tape  is still undecidable.       Let   N denote the ": null
    },
    {
        "natural numbers": "Natural Numbers"
    },
    {
        ", and let   denote the class of unary computable functions. Let         be an ": null
    },
    {
        "admissible numbering": "Admissible Numbering"
    },
    {
        " of the ": null
    },
    {
        "computable functions": "Computable Function"
    },
    {
        ". Denote by   the th computable function.     We identify each property that a computable function may have with the subset of   consisting of the functions with that property. Thus, given a set F     , a computable function   has property F if and only if     F . For each property F     there is an associated ": null
    },
    {
        "decision problem": "Decision Problem"
    },
    {
        " DF of determining, given , whether     F .     Rices theorem states that the decision problem DF is ": null
    },
    {
        "decidable": "Recursive Set"
    },
    {
        "  if and only if F   or F   .       According to Rices theorem, if there is at least one computable function in a particular class C of computable functions and another computable function not in C then the problem of deciding whether a particular program computes a function in C is undecidable. For example, Rices theorem shows that each of the following sets of computable functions is undecidable:   The class of computable functions that return 0 for every input, and its complement.   The class of computable functions that return 0 for at least one input, and its complement.   The class of computable functions that are constant, and its complement.   The class of indices for computable functions that are total.    The class of indices for ": null
    },
    {
        "recursively enumerable sets": "Recursively Enumerable Set"
    },
    {
        " that are cofinite.   The class of indices for recursively enumerable sets that are recursive.       ": null
    },
    {
        "A corollary": "Kleenes Recursion Theoremapplication To Quines"
    },
    {
        " to ": null
    },
    {
        "Kleenes recursion theorem": "Kleenes Recursion Theorem"
    },
    {
        " states that for every ": null
    },
    {
        "Gödel number": "Gödel Number"
    },
    {
        "ing         of the ": null
    },
    {
        "computable functions": "Computable Function"
    },
    {
        " and every computable function Q , there is an index e such that   returns Q . Intuitively,   is a ": null
    },
    {
        "quine": "Quine"
    },
    {
        ", a function that returns its own source code , except that rather than returning it directly,   passes its Gödel number to Q and returns the result.     Let F be a set of computable functions such that     F     . Then there are computable functions f   F and g   F . Suppose that the set of indices x such that     F is decidable; then, there exists a function Q that returns g if     F , and f otherwise. By the corollary to the recursion theorem, there is an index e such that   returns Q . But then, if     F , then   is the same function as g , and therefore     F ; and if     F , then   is f , and therefore     F . In both cases, we have a contradiction.           Suppose, for concreteness, that we have an algorithm for examining a program p and determining infallibly whether p is an implementation of the squaring function, which takes an integer d and returns d 2 . The proof works just as well if we have an algorithm for deciding any other nontrivial property of program behavior , and is given in general below.     The claim is that we can convert our algorithm for identifying squaring programs into one that identifies functions that halt. We will describe an algorithm that takes inputs a and i and determines whether program a halts when given input i.     The algorithm for deciding this is conceptually simple: it constructs a new program t taking an argument n, which first executes program a on input i , and then returns the square of n. If a runs forever, then t never gets to step , regardless of n. Then clearly, t is a function for computing squares if and only if step terminates. Since weve assumed that we can infallibly identify programs for computing squares, we can determine whether t, which depends on a and i, is such a program, and that for every a and i; thus we have obtained a program that decides whether program a halts on input i. Note that our halting-decision algorithm never executes t, but only passes its description to the squaring-identification program, which by assumption always terminates; since the construction of the description of t can also be done in a way that always terminates, the halting-decision cannot fail to halt either.     halts      This method doesnt depend specifically on being able to recognize functions that compute squares; as long as some program can do what were trying to recognize, we can add a call to a to obtain our t. We could have had a method for recognizing programs for computing square roots, or programs for computing the monthly payroll, or programs that halt when given the input Abraxas ; in each case, we would be able to solve the halting problem similarly.            For the formal proof, algorithms are presumed to define partial functions over ": null
    },
    {
        "strings": "String"
    },
    {
        " and are themselves represented by strings. The partial function computed by the algorithm represented by a string a is denoted F a . This proof proceeds by ": null
    },
    {
        "reductio ad absurdum": "Reductio Ad Absurdum"
    },
    {
        "halting problem": "Halting Problem"
    },
    {
        ", which is not possible, and therefore a contradiction.     Let us now assume that P is an algorithm that decides some non-trivial property of F a . Without loss of   generality we may assume that P no , with no-halt being the representation of an algorithm that never halts. If this is not true, then this holds for the negation of the property. Since P decides a non-trivial property, it follows that there is a string b that represents an algorithm and P yes . We can then define an algorithm H as follows:     :1. construct a string t that represents an algorithm T such that   : T first simulates the computation of F a ,   : then T simulates the computation of F b  and returns its result.   :2. return P.     We can now show that H decides the halting problem:   Assume that the algorithm represented by a halts on input i. In this case F t F b and, because P yes and the output of P depends only on F x , it follows that P yes and, therefore H yes .   Assume that the algorithm represented by a does not halt on input i. In this case F t F no-halt , i.e., the partial function that is never defined. Since P no and the output of P depends only on F x , it follows that P no and, therefore H no .     Since the halting problem is known to be undecidable, this is a contradiction and the assumption that there is an algorithm P that decides a non-trivial property for the function represented by a must be false.       Rices theorem can be succinctly stated in terms of index sets:     Let   be a class of partial recursive functions with ": null
    },
    {
        "index set": "Index Set"
    },
    {
        " C . Then C is recursive if and only if C   or C   .       Here   is the set of ": null
    },
    {
        "natural numbers": "Natural Numbers"
    },
    {
        ", including ": null
    },
    {
        "zero": "Zero"
    },
    {
        ".       One can regard Rices theorem as asserting the impossibility of effectively deciding for any recursively enumerable set   whether it has a certain nontrivial property. A set S    is  recursively enumerable  if   SWe:      for some e , where We is the domain       of   .   The result for recursively enumerable sets can be obtained from that for computable functions by   considering the class   , where C is a class of   recursively enumerable sets.   In this section, we give an analogue of Rices theorem for ": null
    },
    {
        "recursive sets": "Recursive Set"
    },
    {
        " , instead of recursively enumerable sets. A recursively enumerable   set S    is  recursive  if its complement is recursively enumerable.   Equivalently, S is recursive if its characteristic function is computable.   Roughly speaking, the analogue says that if one can effectively determine for every recursive set whether it has a certain property,   then only finitely many integers determine whether a recursive set has the property.   This result is analogous to the original theorem of Rice, because both results assert that a property is decidable   only if one can determine whether a set has that property by examining for at most finitely many i    , if i belongs to the set.     Let W be a class  of recursive sets.   If S is a recursive set, then for some e , computable function     is the characteristic function of S . We call e a characteristic index for S .     Lets say the class W is computable if there is an algorithm that decides   for any nonnegative integer e ,   if e is a characteristic index for a recursive set belonging to W , then the algorithm gives yes ;   if e is a characteristic index for a recursive set not belonging to W , then the algorithm gives no .     A set S    extends a string   of 0s and 1s   if for every k ": null
    }
]