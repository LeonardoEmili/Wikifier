          In  |computer_science|Computer_Science| , a queue is a  |collection|Collection|  of entities that are maintained in a sequence and can be modified by the addition of entities at one end of the sequence and removal from the other end of the sequence. By convention, the end of the sequence at which elements are added is called the back or rear of the queue and the end at which elements are removed is called the head or front of the queue, analogously to the words used when people line up to wait for goods or services. The operation of adding an element to the rear of the queue is known as enqueue, and the operation of removing an element from the front is known as dequeue. Other operations may also be allowed, often including a  peek  or front operation that returns the value of the next element to be dequeued without dequeuing it.     The operations of a queue make it a  |first-in-first-out_data_structure|Fifo| . In a FIFO data structure, the first element added to the queue will be the first one to be removed. This is equivalent to the requirement that once a new element is added, all elements that were added before have to be removed before the new element can be removed. A queue is an example of a  |linear_data_structure|Linear_Data_Structure| , or more abstractly a sequential collection.   Queues are common in computer programs, where they are implemented as data structures coupled with access routines, as an  |abstract_data_structure|Abstract_Data_Structure|  or in object-oriented languages as classes. Common implementations are  |circular_buffers|Circular_Buffer|  and  |linked_lists|Linked_List| .     Queues provide services in  |computer_science|Computer_Science| ,  |transport|Transport| , and  |operations_research|Operations_Research|  where various entities such as data, objects, persons, or events are stored and held to be processed later. In these contexts, the queue performs the function of a  |buffer|Buffer| .   Another usage of queues is in the implementation of  |breadth-first_search|Breadth-First_Search| .     Queue implementation |pointers|Pointer|  can implement or come with libraries for dynamic lists. Such  |data_structures|Data_Structure|  may have not specified fixed capacity limit besides memory constraints. Queue overflow results from trying to add an element onto a full queue and queue underflow happens when trying to remove an element from an empty queue.     A bounded queue is a queue limited to a fixed number of items.      There are several efficient implementations of FIFO queues. An efficient implementation is one that can perform the operations—enqueuing and dequeuing—in  |O_time|Big_O_Notation| .    |Linked_list|Linked_List| |doubly_linked_list|Doubly_Linked_List|  has O insertion and deletion at both ends, so it is a natural choice for queues.   A regular singly linked list only has efficient insertion and deletion at one end. However, a small modification—keeping a pointer to the last node in addition to the first one—will enable it to implement an efficient queue.   A  |deque|Double-Ended_Queue|  implemented using a modified dynamic array       Queues may be implemented as a separate data type, or may be considered a special case of a  |double-ended_queue|Double-Ended_Queue|  and not implemented separately. For example,  |Perl|Perl|  and  |Ruby|Ruby|  allow pushing and popping an array from both ends, so one can use push and unshift functions to enqueue and dequeue a list , although in some cases these operations are not efficient.     C++s  |Standard_Template_Library|Standard_Template_Library|  provides a queue templated class which is restricted to only push/pop operations. Since J2SE5.0, Javas library contains a  interface that specifies queue operations; implementing classes include  and . PHP has an  class and third party libraries like  |beanstalkd|Beanstalkd|  and  |Gearman|Gearman| .       A simple queue implemented in  |Ruby|Ruby|.