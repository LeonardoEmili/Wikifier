[
    {
        "The following is a list of algorithm s along with one-line descriptions for each.             ": null
    },
    {
        "Brents algorithm": "Cycle Detectionbrents Algorithm"
    },
    {
        "Floyds cycle-finding algorithm": "Floyds Cycle-Finding Algorithm"
    },
    {
        "Gale–Shapley algorithm": "Stable Marriage Problem"
    },
    {
        "Pseudorandom number generators": "Pseudorandom Number Generator"
    },
    {
        " ACORN generator": "Acorn"
    },
    {
        " Blum Blum Shub": "Blum Blum Shub"
    },
    {
        " Lagged Fibonacci generator": "Lagged Fibonacci Generator"
    },
    {
        " Linear congruential generator": "Linear Congruential Generator"
    },
    {
        " Mersenne Twister": "Mersenne Twister"
    },
    {
        "        Coloring algorithm": "Coloring Algorithm"
    },
    {
        "Hopcroft–Karp algorithm": "Hopcroft–Karp Algorithm"
    },
    {
        "maximum cardinality matching": "Maximum Cardinality Matching"
    },
    {
        " Hungarian algorithm": "Hungarian Algorithm"
    },
    {
        "perfect matching": "Perfect Matching"
    },
    {
        " Prüfer coding": "Prüfer Sequence"
    },
    {
        "Prüfer sequence": "Prüfer Sequence"
    },
    {
        " Tarjans off-line lowest common ancestors algorithm": "Tarjans Off-Line Lowest Common Ancestors Algorithm"
    },
    {
        "lowest common ancestors": "Lowest Common Ancestor"
    },
    {
        " for pairs of nodes in a tree   ": null
    },
    {
        "Topological sort": "Topological Sorting"
    },
    {
        " Force-based algorithms": "Force-Based Algorithms"
    },
    {
        "   Spectral layout": "Spectral Layout"
    },
    {
        "        Girvan–Newman algorithm": "Girvan–Newman Algorithm"
    },
    {
        "Hyperlink-Induced Topic Search": "Hyperlink-Induced Topic Search"
    },
    {
        "    PageRank": "Pagerank"
    },
    {
        " TrustRank": "Trustrank"
    },
    {
        "Flow networks": "Flow Network"
    },
    {
        "   Dinics algorithm": "Dinics Algorithm"
    },
    {
        "strongly polynomial": "Strongly Polynomial"
    },
    {
        " algorithm for computing the ": null
    },
    {
        "maximum flow": "Maximum Flow"
    },
    {
        " in a ": null
    },
    {
        "flow network": "Flow Network"
    },
    {
        ".   ": null
    },
    {
        "Edmonds–Karp algorithm": "Edmonds–Karp Algorithm"
    },
    {
        "Ford–Fulkerson algorithm": "Ford–Fulkerson Algorithm"
    },
    {
        "maximum flow": "Maximum Flow Problem"
    },
    {
        " in a graph   ": null
    },
    {
        "Kargers algorithm": "Kargers Algorithm"
    },
    {
        "minimum cut": "Minimum Cut"
    },
    {
        " of a connected graph   ": null
    },
    {
        "Push–relabel algorithm": "Push–Relabel Algorithm"
    },
    {
        "maximum flow": "Maximum Flow Problem"
    },
    {
        " in a graph       ": null
    },
    {
        "Edmonds algorithm": "Edmonds Algorithm"
    },
    {
        " : find maximum or minimum branchings   ": null
    },
    {
        "Euclidean minimum spanning tree": "Euclidean Minimum Spanning Tree"
    },
    {
        "Euclidean shortest path problem": "Euclidean Shortest Path Problem"
    },
    {
        "Longest path problem": "Longest Path Problem"
    },
    {
        "Minimum spanning tree": "Minimum Spanning Tree"
    },
    {
        " Borůvkas algorithm": "Borůvkas Algorithm"
    },
    {
        " Kruskals algorithm": "Kruskals Algorithm"
    },
    {
        " Prims algorithm": "Prims Algorithm"
    },
    {
        " Reverse-delete algorithm": "Reverse-Delete Algorithm"
    },
    {
        " Nonblocking minimal spanning switch": "Nonblocking Minimal Spanning Switch"
    },
    {
        " say, for a ": null
    },
    {
        "telephone exchange": "Telephone Exchange"
    },
    {
        " Shortest path problem": "Shortest Path Problem"
    },
    {
        " Bellman–Ford algorithm": "Bellman–Ford Algorithm"
    },
    {
        "shortest paths": "Shortest Path Problem"
    },
    {
        " in a weighted graph   ": null
    },
    {
        "Dijkstras algorithm": "Dijkstras Algorithm"
    },
    {
        "shortest paths": "Shortest Path Problem"
    },
    {
        " in a graph with non-negative edge weights   ": null
    },
    {
        "Floyd–Warshall algorithm": "Floyd–Warshall Algorithm"
    },
    {
        "all pairs shortest path": "All Pairs Shortest Path"
    },
    {
        " problem in a weighted, directed graph   ": null
    },
    {
        "Johnsons algorithm": "Johnsons Algorithm"
    },
    {
        "   Transitive closure": "Transitive Closure"
    },
    {
        " problem: find the ": null
    },
    {
        "transitive closure": "Transitive Closure"
    },
    {
        " of a given binary relation   ": null
    },
    {
        "Traveling salesman problem": "Traveling Salesman Problem"
    },
    {
        " Christofides algorithm": "Christofides Algorithm"
    },
    {
        " Nearest neighbour algorithm": "Nearest Neighbour Algorithm"
    },
    {
        " Warnsdorffs rule": "Warnsdorffs Rule"
    },
    {
        "Knights tour": "Knights Tour"
    },
    {
        " problem.        ": null
    },
    {
        "A": "A Search Algorithm"
    },
    {
        "B": "B"
    },
    {
        "Backtracking": "Backtracking"
    },
    {
        "Beam search": "Beam Search"
    },
    {
        "best-first search": "Best-First Search"
    },
    {
        " that reduces its memory requirement   ": null
    },
    {
        "Beam stack search": "Beam Stack Search"
    },
    {
        "beam search": "Beam Search"
    },
    {
        " Best-first search": "Best-First Search"
    },
    {
        "priority queue": "Priority Queue"
    },
    {
        " Bidirectional search": "Bidirectional Search"
    },
    {
        "Breadth-first search": "Breadth-First Search"
    },
    {
        "Brute-force search": "Brute-Force Search"
    },
    {
        "D": "D"
    },
    {
        "incremental heuristic search": "Incremental Heuristic Search"
    },
    {
        " algorithm   ": null
    },
    {
        "Depth-first search": "Depth-First Search"
    },
    {
        "Dijkstras algorithm": "Dijkstras Algorithm"
    },
    {
        "General Problem Solver": "General Problem Solver"
    },
    {
        "Iterative deepening depth-first search": "Iterative Deepening Depth-First Search"
    },
    {
        " : a state space search strategy   ": null
    },
    {
        "Jump point search": "Jump Point Search"
    },
    {
        "Lexicographic breadth-first search": "Lexicographic Breadth-First Search"
    },
    {
        " : a linear time algorithm for ordering the vertices of a graph   ": null
    },
    {
        "Uniform-cost search": "Uniform-Cost Search"
    },
    {
        "tree search": "Tree Traversal"
    },
    {
        " that finds the lowest-cost route where costs vary   ": null
    },
    {
        "SSS": "Sss"
    },
    {
        "F": "F Merge Algorithm"
    },
    {
        "Cliques": "Clique"
    },
    {
        " Bron–Kerbosch algorithm": "Bron–Kerbosch Algorithm"
    },
    {
        "maximal cliques": "Maximal Clique"
    },
    {
        " in an undirected graph   ": null
    },
    {
        "MaxCliqueDyn maximum clique algorithm": "Maxcliquedyn Maximum Clique Algorithm"
    },
    {
        "maximum clique": "Maximum Clique"
    },
    {
        " in an undirected graph   ": null
    },
    {
        "Strongly connected components": "Strongly Connected Components"
    },
    {
        " Path-based strong component algorithm": "Path-Based Strong Component Algorithm"
    },
    {
        " Kosarajus algorithm": "Kosarajus Algorithm"
    },
    {
        " Tarjans strongly connected components algorithm": "Tarjans Strongly Connected Components Algorithm"
    },
    {
        " Subgraph isomorphism problem": "Subgraph Isomorphism Problem"
    },
    {
        "              Bitap algorithm": "Bitap Algorithm"
    },
    {
        "Phonetic algorithms": "Phonetic Algorithm"
    },
    {
        "   Daitch–Mokotoff Soundex": "Daitch–Mokotoff Soundex"
    },
    {
        "Soundex": "Soundex"
    },
    {
        " refinement which allows matching of Slavic and Germanic surnames   ": null
    },
    {
        "Double Metaphone": "Double Metaphone"
    },
    {
        "Match rating approach": "Match Rating Approach"
    },
    {
        "Metaphone": "Metaphone"
    },
    {
        "NYSIIS": "New York State Identification And Intelligence System"
    },
    {
        "phonetic algorithm": "Phonetic Algorithm"
    },
    {
        ", improves on ": null
    },
    {
        "Soundex": "Soundex"
    },
    {
        " Soundex": "Soundex"
    },
    {
        "String metrics": "String Metric"
    },
    {
        ": compute a similarity or dissimilarity score between two pairs of text strings   ": null
    },
    {
        "Damerau–Levenshtein distance": "Damerau–Levenshtein Distance"
    },
    {
        " compute a distance measure between two strings, improves on ": null
    },
    {
        "Levenshtein distance": "Levenshtein Distance"
    },
    {
        " Dices coefficient": "Dices Coefficient"
    },
    {
        " : a similarity measure related to the ": null
    },
    {
        "Jaccard index": "Jaccard Index"
    },
    {
        " Hamming distance": "Hamming Distance"
    },
    {
        "Jaro–Winkler distance": "Jaro–Winkler Distance"
    },
    {
        "Levenshtein edit distance": "Levenshtein Distance"
    },
    {
        "Trigram search": "Trigram Search"
    },
    {
        " Quickselect": "Quickselect"
    },
    {
        " Introselect": "Introselect"
    },
    {
        "       Linear search": "Linear Search"
    },
    {
        "Selection algorithm": "Selection Algorithm"
    },
    {
        "kth largest item in a sequence   ": null
    },
    {
        "Ternary search": "Ternary Search"
    },
    {
        "Sorted lists": "Sorted List"
    },
    {
        "   Binary search algorithm": "Binary Search Algorithm"
    },
    {
        "Fibonacci search technique": "Fibonacci Search Technique"
    },
    {
        "Fibonacci numbers": "Fibonacci Numbers"
    },
    {
        " Jump search": "Jump Search"
    },
    {
        " : linear search on a smaller subset of the sequence   ": null
    },
    {
        "Predictive search": "Interpolation Search"
    },
    {
        "magnitude": "Magnitude"
    },
    {
        " of search term versus the high and low values in the search. Sometimes called dictionary search or interpolated search.   ": null
    },
    {
        "Uniform binary search": "Uniform Binary Search"
    },
    {
        "  Fisher–Yates shuffle": "Fisher–Yates Shuffle"
    },
    {
        " : randomly shuffle a finite set   ": null
    },
    {
        "Schensted algorithm": "Schensted Algorithm"
    },
    {
        "Young tableau": "Young Tableau"
    },
    {
        "x from a permutation   ": null
    },
    {
        "Steinhaus–Johnson–Trotter algorithm": "Steinhaus–Johnson–Trotter Algorithm"
    },
    {
        " : generate permutations by transposing elements   ": null
    },
    {
        "Heaps permutation generation algorithm": "Heaps Algorithm"
    },
    {
        "Dynamic time warping": "Dynamic Time Warping"
    },
    {
        "Hirschbergs algorithm": "Hirschbergs Algorithm"
    },
    {
        "sequence alignment": "Sequence Alignment"
    },
    {
        " between two sequences, as measured by their ": null
    },
    {
        "Levenshtein distance": "Levenshtein Distance"
    },
    {
        " Needleman–Wunsch algorithm": "Needleman–Wunsch Algorithm"
    },
    {
        "Smith–Waterman algorithm": "Smith–Waterman Algorithm"
    },
    {
        "    Bubble sort": "Bubble Sort"
    },
    {
        "Cocktail shaker sort": "Cocktail Shaker Sort"
    },
    {
        " or bidirectional bubble sort, a bubble sort traversing the list alternately from front to back and back to front   ": null
    },
    {
        "Comb sort": "Comb Sort"
    },
    {
        " Gnome sort": "Gnome Sort"
    },
    {
        " Odd–even sort": "Odd–Even Sort"
    },
    {
        " Quicksort": "Quicksort"
    },
    {
        "Bogosort": "Bogosort"
    },
    {
        " Stooge sort": "Stooge Sort"
    },
    {
        " Flashsort": "Flashsort"
    },
    {
        " Introsort": "Introsort"
    },
    {
        "Timsort": "Timsort"
    },
    {
        "Insertion sort": "Insertion Sort"
    },
    {
        "Library sort": "Library Sort"
    },
    {
        " Patience sorting": "Patience Sorting"
    },
    {
        " Shell sort": "Shellsort"
    },
    {
        "Tree sort": "Tree Sort"
    },
    {
        " : build binary tree, then traverse it to create sorted list   ": null
    },
    {
        "Cycle sort": "Cycle Sort"
    },
    {
        "Merge sort": "Merge Sort"
    },
    {
        "Slowsort": "Slowsort"
    },
    {
        " Strand sort": "Strand Sort"
    },
    {
        " Bead sort": "Bead Sort"
    },
    {
        " Bucket sort": "Bucket Sort"
    },
    {
        " Burstsort": "Burstsort"
    },
    {
        "burst trie": "Burst Trie"
    },
    {
        " and then traverse it to create sorted output   ": null
    },
    {
        "Counting sort": "Counting Sort"
    },
    {
        " Pigeonhole sort": "Pigeonhole Sort"
    },
    {
        " Postman sort": "Postman Sort"
    },
    {
        "Radix sort": "Radix Sort"
    },
    {
        "Heapsort": "Heapsort"
    },
    {
        "Selection sort": "Selection Sort"
    },
    {
        "Smoothsort": "Smoothsort"
    },
    {
        " Bitonic sorter": "Bitonic Sorter"
    },
    {
        " Pancake sorting": "Pancake Sorting"
    },
    {
        " Spaghetti sort": "Spaghetti Sort"
    },
    {
        " Topological sort": "Topological Sorting"
    },
    {
        " Samplesort": "Samplesort"
    },
    {
        "        Kadanes algorithm": "Kadanes Algorithm"
    },
    {
        "Longest common subsequence problem": "Longest Common Subsequence Problem"
    },
    {
        "Longest increasing subsequence problem": "Longest Increasing Subsequence Problem"
    },
    {
        "Shortest common supersequence problem": "Shortest Common Supersequence Problem"
    },
    {
        " Longest common substring problem": "Longest Common Substring Problem"
    },
    {
        "Substring search": "Substring Search"
    },
    {
        " Aho–Corasick string matching algorithm": "Aho–Corasick String Matching Algorithm"
    },
    {
        "trie": "Trie"
    },
    {
        " based algorithm for finding all substring matches to any of a finite set of strings   ": null
    },
    {
        "Boyer–Moore string-search algorithm": "Boyer–Moore String-Search Algorithm"
    },
    {
        " algorithm for substring search   ": null
    },
    {
        "Boyer–Moore–Horspool algorithm": "Boyer–Moore–Horspool Algorithm"
    },
    {
        "Knuth–Morris–Pratt algorithm": "Knuth–Morris–Pratt Algorithm"
    },
    {
        "Rabin–Karp string search algorithm": "Rabin–Karp String Search Algorithm"
    },
    {
        "Zhu–Takaoka string matching algorithm": "Zhu–Takaoka String Matching Algorithm"
    },
    {
        "Ukkonens algorithm": "Ukkonens Algorithm"
    },
    {
        "linear-time": "Linear-Time"
    },
    {
        ", ": null
    },
    {
        "online algorithm": "Online Algorithm"
    },
    {
        " for constructing ": null
    },
    {
        "suffix trees": "Suffix Tree"
    },
    {
        "   Matching wildcards": "Matching Wildcards"
    },
    {
        " Rich Salz": "Internetnews"
    },
    {
        " wildmat": "Wildmat"
    },
    {
        "open-source": "Open-Source Software"
    },
    {
        " recursive": "Recursion"
    },
    {
        " algorithm   ": null
    },
    {
        "Krauss matching wildcards algorithm": "Krauss Matching Wildcards Algorithm"
    },
    {
        "           Chien search": "Chien Search"
    },
    {
        "Schreier–Sims algorithm": "Schreier–Sims Algorithm"
    },
    {
        "strong generating set": "Strong Generating Set"
    },
    {
        " of a ": null
    },
    {
        "permutation group": "Permutation Group"
    },
    {
        " Todd–Coxeter algorithm": "Todd–Coxeter Algorithm"
    },
    {
        "cosets": "Coset"
    },
    {
        ".        ": null
    },
    {
        "Buchbergers algorithm": "Buchbergers Algorithm"
    },
    {
        "Gröbner basis": "Gröbner Basis"
    },
    {
        " Cantor–Zassenhaus algorithm": "Cantor–Zassenhaus Algorithm"
    },
    {
        "Faugère F4 algorithm": "Faugère F4 Algorithm"
    },
    {
        "Gospers algorithm": "Gospers Algorithm"
    },
    {
        "Knuth–Bendix completion algorithm": "Knuth–Bendix Completion Algorithm"
    },
    {
        "rewriting": "Rewriting"
    },
    {
        " rule systems   ": null
    },
    {
        "Multivariate division algorithm": "Multivariate Division Algorithm"
    },
    {
        "polynomials": "Polynomial"
    },
    {
        " in several indeterminates   ": null
    },
    {
        "Pollards kangaroo algorithm": "Pollards Kangaroo Algorithm"
    },
    {
        " : an algorithm for solving the discrete logarithm problem   ": null
    },
    {
        "Polynomial long division": "Polynomial Long Division"
    },
    {
        "Risch algorithm": "Risch Algorithm"
    },
    {
        "           Closest pair problem": "Closest Pair Problem"
    },
    {
        "Collision detection": "Collision Detection"
    },
    {
        " algorithms: check for the collision or intersection of two given solids   ": null
    },
    {
        "Cone algorithm": "Cone Algorithm"
    },
    {
        "Convex hull algorithms": "Convex Hull Algorithms"
    },
    {
        "convex hull": "Convex Hull"
    },
    {
        " of a ": null
    },
    {
        "set": "Set"
    },
    {
        " of points   ": null
    },
    {
        "Graham scan": "Graham Scan"
    },
    {
        " Quickhull": "Quickhull"
    },
    {
        " Gift wrapping algorithm": "Gift Wrapping Algorithm"
    },
    {
        " or Jarvis march   ": null
    },
    {
        "Chans algorithm": "Chans Algorithm"
    },
    {
        " Kirkpatrick–Seidel algorithm": "Kirkpatrick–Seidel Algorithm"
    },
    {
        " Euclidean distance transform": "Euclidean Distance Map"
    },
    {
        "Geometric hashing": "Geometric Hashing"
    },
    {
        "affine transformation": "Affine Transformation"
    },
    {
        " Gilbert–Johnson–Keerthi distance algorithm": "Gilbert–Johnson–Keerthi Distance Algorithm"
    },
    {
        "convex": "Convex Set"
    },
    {
        " shapes.   ": null
    },
    {
        "Jump-and-Walk algorithm": "Jump-And-Walk Algorithm"
    },
    {
        "Laplacian smoothing": "Laplacian Smoothing"
    },
    {
        "Line segment intersection": "Line Segment Intersection"
    },
    {
        "sweep line algorithm": "Sweep Line Algorithm"
    },
    {
        " Bentley–Ottmann algorithm": "Bentley–Ottmann Algorithm"
    },
    {
        " Shamos–Hoey algorithm": "Shamos–Hoey Algorithm"
    },
    {
        " Minimum bounding box algorithms": "Minimum Bounding Box Algorithms"
    },
    {
        "oriented minimum bounding box": "Minimum Bounding Boxarbitrarily Oriented Minimum Bounding Box"
    },
    {
        " enclosing a set of points   ": null
    },
    {
        "Nearest neighbor search": "Nearest Neighbor Search"
    },
    {
        "Point in polygon": "Point In Polygon"
    },
    {
        " algorithms: tests whether a given point lies within a given polygon   ": null
    },
    {
        "Point set registration": "Point Set Registration"
    },
    {
        " algorithms: finds the transformation between two ": null
    },
    {
        "point sets": "Point Cloud"
    },
    {
        " to optimally align them.   ": null
    },
    {
        "Rotating calipers": "Rotating Calipers"
    },
    {
        "antipodal": "Antipodal Point"
    },
    {
        " pairs of points and vertices on a ": null
    },
    {
        "convex polygon": "Convex Polygon"
    },
    {
        " or ": null
    },
    {
        "convex hull": "Convex Hull"
    },
    {
        ".   ": null
    },
    {
        "Shoelace algorithm": "Shoelace Algorithm"
    },
    {
        "Triangulation": "Triangulation"
    },
    {
        " Delaunay triangulation": "Delaunay Triangulation"
    },
    {
        " Rupperts algorithm": "Rupperts Algorithm"
    },
    {
        " : create quality Delaunay triangulations   ": null
    },
    {
        "Chews second algorithm": "Chews Second Algorithm"
    },
    {
        "constrained Delaunay triangulations": "Constrained Delaunay Triangulation"
    },
    {
        "   Marching triangles": "Marching Triangles"
    },
    {
        "point cloud": "Point Cloud"
    },
    {
        " Polygon triangulation": "Polygon Triangulation"
    },
    {
        " algorithms: decompose a polygon into a set of triangles   ": null
    },
    {
        "Voronoi diagrams": "Voronoi Diagram"
    },
    {
        ", geometric ": null
    },
    {
        "dual": "Duality"
    },
    {
        " of ": null
    },
    {
        "Delaunay triangulation": "Delaunay Triangulation"
    },
    {
        " Bowyer–Watson algorithm": "Bowyer–Watson Algorithm"
    },
    {
        "Fortunes Algorithm": "Fortunes Algorithm"
    },
    {
        "Quasitriangulation": "Quasitriangulation"
    },
    {
        "        Binary GCD algorithm": "Binary Gcd Algorithm"
    },
    {
        "Booths multiplication algorithm": "Booths Multiplication Algorithm"
    },
    {
        " Chakravala method": "Chakravala Method"
    },
    {
        "Pells equation": "Pells Equation"
    },
    {
        " Discrete logarithm": "Discrete Logarithm"
    },
    {
        "Baby-step giant-step": "Baby-Step Giant-Step"
    },
    {
        " Index calculus algorithm": "Index Calculus Algorithm"
    },
    {
        " Pollards rho algorithm for logarithms": "Pollards Rho Algorithm For Logarithms"
    },
    {
        " Pohlig  Hellman algorithm": "Pohlig & Ndash;Hellman Algorithm"
    },
    {
        " Euclidean algorithm": "Euclidean Algorithm"
    },
    {
        "greatest common divisor": "Greatest Common Divisor"
    },
    {
        " Extended Euclidean algorithm": "Extended Euclidean Algorithm"
    },
    {
        "ax  +  by    c.   ": null
    },
    {
        "Integer factorization": "Integer Factorization"
    },
    {
        "prime": "Prime Number"
    },
    {
        " factors   ": null
    },
    {
        "Congruence of squares": "Congruence Of Squares"
    },
    {
        " Dixons algorithm": "Dixons Algorithm"
    },
    {
        " Fermats factorization method": "Fermats Factorization Method"
    },
    {
        " General number field sieve": "General Number Field Sieve"
    },
    {
        " Lenstra elliptic curve factorization": "Lenstra Elliptic Curve Factorization"
    },
    {
        " Pollards p  −  1 algorithm": "Pollards P  & Minus; 1 Algorithm"
    },
    {
        " Pollards rho algorithm": "Pollards Rho Algorithm"
    },
    {
        " prime factorization algorithm": "Prime Factorization Algorithm"
    },
    {
        " Quadratic sieve": "Quadratic Sieve"
    },
    {
        " Shors algorithm": "Shors Algorithm"
    },
    {
        " Special number field sieve": "Special Number Field Sieve"
    },
    {
        " Trial division": "Trial Division"
    },
    {
        "Multiplication algorithms": "Multiplication Algorithm"
    },
    {
        ": fast multiplication of two numbers   ": null
    },
    {
        "Karatsuba algorithm": "Karatsuba Algorithm"
    },
    {
        " Schönhage–Strassen algorithm": "Schönhage–Strassen Algorithm"
    },
    {
        " Toom–Cook multiplication": "Toom–Cook Multiplication"
    },
    {
        " Modular square root": "Modular Square Root"
    },
    {
        "Tonelli–Shanks algorithm": "Tonelli–Shanks Algorithm"
    },
    {
        " Cipollas algorithm": "Cipollas Algorithm"
    },
    {
        " Berlekamps root finding algorithm": "Berlekamps Root Finding Algorithm"
    },
    {
        " Odlyzko  Schönhage algorithm": "Odlyzko & Ndash;Schönhage Algorithm"
    },
    {
        "Riemann zeta function": "Riemann Zeta Function"
    },
    {
        " Lenstra–Lenstra–Lovász algorithm": "Lenstra–Lenstra–Lovász Lattice Basis Reduction Algorithm"
    },
    {
        " : find a short, nearly orthogonal ": null
    },
    {
        "lattice": "Lattice"
    },
    {
        " basis": "Basis"
    },
    {
        " in polynomial time   ": null
    },
    {
        "Primality tests": "Primality Test"
    },
    {
        ": determining whether a given number is ": null
    },
    {
        "prime": "Prime Number"
    },
    {
        " AKS primality test": "Aks Primality Test"
    },
    {
        " Baillie-PSW primality test": "Baillie-Psw Primality Test"
    },
    {
        " Fermat primality test": "Fermat Primality Test"
    },
    {
        " Lucas primality test": "Lucas Primality Test"
    },
    {
        " Miller  Rabin primality test": "Miller & Ndash;Rabin Primality Test"
    },
    {
        " Sieve of Atkin": "Sieve Of Atkin"
    },
    {
        " Sieve of Eratosthenes": "Sieve Of Eratosthenes"
    },
    {
        " Sieve of Sundaram": "Sieve Of Sundaram"
    },
    {
        "               Euler method": "Euler Method"
    },
    {
        " Backward Euler method": "Backward Euler Method"
    },
    {
        " Trapezoidal rule ": "Trapezoidal Rule"
    },
    {
        "Linear multistep methods": "Linear Multistep Method"
    },
    {
        "   Runge–Kutta methods": "Runge–Kutta Methods"
    },
    {
        " Euler integration": "Euler Integration"
    },
    {
        "Multigrid methods": "Multigrid Method"
    },
    {
        " , a group of algorithms for solving differential equations using a hierarchy of discretizations   ": null
    },
    {
        "Partial differential equation": "Partial Differential Equation"
    },
    {
        "Finite difference method": "Finite Difference Method"
    },
    {
        " Crank–Nicolson method": "Crank–Nicolson Method"
    },
    {
        " for diffusion equations   ": null
    },
    {
        "Lax-Wendroff": "Lax–Wendroff Method"
    },
    {
        " for wave equations   ": null
    },
    {
        "Verlet integration": "Verlet Integration"
    },
    {
        "  Computation of π": "Computing Π"
    },
    {
        "Borweins algorithm": "Borweins Algorithm"
    },
    {
        "Gauss–Legendre algorithm": "Gauss–Legendre Algorithm"
    },
    {
        "pi": "Pi"
    },
    {
        " Chudnovsky algorithm": "Chudnovsky Algorithm"
    },
    {
        "Bailey–Borwein–Plouffe formula": "Bailey–Borwein–Plouffe Formula"
    },
    {
        "Division algorithms": "Division Algorithm"
    },
    {
        ": for computing quotient and/or remainder of two numbers   ": null
    },
    {
        "Long division": "Long Division"
    },
    {
        " Restoring division": "Restoring Division"
    },
    {
        " Non-restoring division": "Non-Restoring Division"
    },
    {
        " SRT division": "Srt Division"
    },
    {
        " Newton–Raphson division": "Newton–Raphson Division"
    },
    {
        "Newtons method": "Newtons Method"
    },
    {
        " to find the ": null
    },
    {
        "reciprocal": "Multiplicative Inverse"
    },
    {
        " of D, and multiply that reciprocal by N to find the final quotient Q.   ": null
    },
    {
        "Goldschmidt division": "Goldschmidt Division"
    },
    {
        " BKM algorithm": "Bkm Algorithm"
    },
    {
        "elementary functions": "Elementary Function"
    },
    {
        " using a table of logarithms   ": null
    },
    {
        "CORDIC": "Cordic"
    },
    {
        "Addition-chain exponentiation": "Addition-Chain Exponentiation"
    },
    {
        "Exponentiating by squaring": "Exponentiating By Squaring"
    },
    {
        "large integer": "Arbitrary-Precision Arithmetic"
    },
    {
        " powers of a number   ": null
    },
    {
        "Montgomery reduction": "Montgomery Reduction"
    },
    {
        "modular arithmetic": "Modular Arithmetic"
    },
    {
        " to be performed efficiently when the modulus is large   ": null
    },
    {
        "Multiplication algorithms": "Multiplication Algorithm"
    },
    {
        ": fast multiplication of two numbers   ": null
    },
    {
        "Booths multiplication algorithm": "Booths Multiplication Algorithm"
    },
    {
        "Fürers algorithm": "Fürers Algorithm"
    },
    {
        "asymptotic complexity": "Computational Complexity Theory"
    },
    {
        " Karatsuba algorithm": "Karatsuba Algorithm"
    },
    {
        "Schönhage–Strassen algorithm": "Schönhage–Strassen Algorithm"
    },
    {
        "Toom–Cook multiplication": "Toom–Cook Multiplication"
    },
    {
        "Multiplicative inverse Algorithms": "Multiplicative Inversealgorithms"
    },
    {
        "Newtons method": "Newtons Methodmultiplicative Inverses Of Numbers And Power Series"
    },
    {
        " Rounding functions": "Rounding Functions"
    },
    {
        "Spigot algorithm": "Spigot Algorithm"
    },
    {
        "mathematical constant": "Mathematical Constant"
    },
    {
        " without knowing preceding digits   Square and Nth root of a number:   ": null
    },
    {
        "Alpha max plus beta min algorithm": "Alpha Max Plus Beta Min Algorithm"
    },
    {
        "Methods of computing square roots": "Methods Of Computing Square Roots"
    },
    {
        " nth root algorithm": "Nth Root Algorithm"
    },
    {
        " Shifting nth-root algorithm": "Shifting Nth-Root Algorithm"
    },
    {
        "Binary splitting": "Binary Splitting"
    },
    {
        "divide and conquer": "Divide And Conquer Algorithm"
    },
    {
        " technique which speeds up the numerical evaluation of many types of series with rational terms   ": null
    },
    {
        "Kahan summation algorithm": "Kahan Summation Algorithm"
    },
    {
        "Unrestricted algorithm": "Unrestricted Algorithm"
    },
    {
        "       Filtered back-projection": "Radon Transformfiltered Back-Projection"
    },
    {
        "Radon transform": "Radon Transform"
    },
    {
        ".   ": null
    },
    {
        "Level set method": "Level Set Method"
    },
    {
        " : a numerical technique for tracking interfaces and shapes        ": null
    },
    {
        "Birkhoff interpolation": "Birkhoff Interpolation"
    },
    {
        "Cubic interpolation": "Cubic Interpolation"
    },
    {
        " Hermite interpolation": "Hermite Interpolation"
    },
    {
        " Lagrange interpolation": "Lagrange Interpolation"
    },
    {
        "Lagrange polynomials": "Lagrange Polynomial"
    },
    {
        "   Linear interpolation": "Linear Interpolation"
    },
    {
        "Monotone cubic interpolation": "Monotone Cubic Interpolation"
    },
    {
        "Multivariate interpolation": "Multivariate Interpolation"
    },
    {
        " Bicubic interpolation": "Bicubic Interpolation"
    },
    {
        ", a generalization of ": null
    },
    {
        "cubic interpolation": "Cubic Interpolation"
    },
    {
        " to two dimensions   ": null
    },
    {
        "Bilinear interpolation": "Bilinear Interpolation"
    },
    {
        "linear interpolation": "Linear Interpolation"
    },
    {
        " for interpolating functions of two variables on a regular grid   ": null
    },
    {
        "Lanczos resampling": "Lanczos Resampling"
    },
    {
        " : a multivariate interpolation method used to compute new values for any digitally sampled data   ": null
    },
    {
        "Nearest-neighbor interpolation": "Nearest-Neighbor Interpolation"
    },
    {
        " Tricubic interpolation": "Tricubic Interpolation"
    },
    {
        ", a generalization of ": null
    },
    {
        "cubic interpolation": "Cubic Interpolation"
    },
    {
        " to three dimensions   ": null
    },
    {
        "Pareto interpolation": "Pareto Interpolation"
    },
    {
        "Pareto distribution": "Pareto Distribution"
    },
    {
        ".   ": null
    },
    {
        "Polynomial interpolation": "Polynomial Interpolation"
    },
    {
        " Nevilles algorithm": "Nevilles Algorithm"
    },
    {
        " Spline interpolation": "Spline Interpolation"
    },
    {
        "Runges phenomenon": "Runges Phenomenon"
    },
    {
        ".   ": null
    },
    {
        "De Boor algorithm": "De Boor Algorithm"
    },
    {
        "B-splines": "B-Spline"
    },
    {
        "   De Casteljaus algorithm": "De Casteljaus Algorithm"
    },
    {
        "Bézier curves": "Bézier Curve"
    },
    {
        "   Trigonometric interpolation": "Trigonometric Interpolation"
    },
    {
        "Eigenvalue algorithms": "Eigenvalue Algorithm"
    },
    {
        "   Arnoldi iteration": "Arnoldi Iteration"
    },
    {
        " Inverse iteration": "Inverse Iteration"
    },
    {
        " Jacobi method": "Jacobi Eigenvalue Algorithm"
    },
    {
        " Lanczos iteration": "Lanczos Iteration"
    },
    {
        " Power iteration": "Power Iteration"
    },
    {
        " QR algorithm": "Qr Algorithm"
    },
    {
        " Rayleigh quotient iteration": "Rayleigh Quotient Iteration"
    },
    {
        " Gram–Schmidt process": "Gram–Schmidt Process"
    },
    {
        "Matrix multiplication algorithms": "Matrix Multiplication Algorithm"
    },
    {
        "   Cannons algorithm": "Cannons Algorithm"
    },
    {
        "distributed algorithm": "Distributed Algorithm"
    },
    {
        " for ": null
    },
    {
        "matrix multiplication": "Matrix Multiplication"
    },
    {
        " especially suitable for computers laid out in an N × N mesh   ": null
    },
    {
        "Coppersmith–Winograd algorithm": "Coppersmith–Winograd Algorithm"
    },
    {
        "matrix multiplication": "Matrix Multiplication"
    },
    {
        " Freivalds algorithm": "Freivalds Algorithm"
    },
    {
        "Strassen algorithm": "Strassen Algorithm"
    },
    {
        "matrix multiplication": "Matrix Multiplication"
    },
    {
        "    systems of linear equations": "System Of Linear Equations"
    },
    {
        " Biconjugate gradient method": "Biconjugate Gradient Method"
    },
    {
        "Conjugate gradient": "Conjugate Gradient"
    },
    {
        "Gaussian elimination": "Gaussian Elimination"
    },
    {
        " Gauss–Jordan elimination": "Gauss–Jordan Elimination"
    },
    {
        "Gauss–Seidel method": "Gauss–Seidel Method"
    },
    {
        "Levinson recursion": "Levinson Recursion"
    },
    {
        "Toeplitz matrix": "Toeplitz Matrix"
    },
    {
        " Stones method": "Stones Method"
    },
    {
        "Successive over-relaxation": "Successive Over-Relaxation"
    },
    {
        " : method used to speed up convergence of the ": null
    },
    {
        "Gauss–Seidel method": "Gauss–Seidel Method"
    },
    {
        " Tridiagonal matrix algorithm": "Tridiagonal Matrix Algorithm"
    },
    {
        " : solves systems of tridiagonal equations   ": null
    },
    {
        "Sparse matrix": "Sparse Matrix"
    },
    {
        " algorithms   ": null
    },
    {
        "Cuthill–McKee algorithm": "Cuthill–Mckee Algorithm"
    },
    {
        "bandwidth": "Bandwidth"
    },
    {
        " of a ": null
    },
    {
        "symmetric sparse matrix": "Symmetric Sparse Matrix"
    },
    {
        " Minimum degree algorithm": "Minimum Degree Algorithm"
    },
    {
        "symmetric sparse matrix": "Symmetric Sparse Matrix"
    },
    {
        " before applying the ": null
    },
    {
        "Cholesky decomposition": "Cholesky Decomposition"
    },
    {
        " Symbolic Cholesky decomposition": "Symbolic Cholesky Decomposition"
    },
    {
        "sparse matrix": "Sparse Matrix"
    },
    {
        "        Gibbs sampling": "Gibbs Sampling"
    },
    {
        "Hybrid Monte Carlo": "Hybrid Monte Carlo"
    },
    {
        "Hamiltonian": "Hamiltonian Dynamics"
    },
    {
        " weighted ": null
    },
    {
        "Markov chain Monte Carlo": "Markov Chain Monte Carlo"
    },
    {
        ", from a probability distribution which is difficult to sample directly.   ": null
    },
    {
        "Metropolis–Hastings algorithm": "Metropolis–Hastings Algorithm"
    },
    {
        "probability distribution": "Probability Distribution"
    },
    {
        " of one or more variables   ": null
    },
    {
        "Wang and Landau algorithm": "Wang And Landau Algorithm"
    },
    {
        "Metropolis–Hastings algorithm": "Metropolis–Hastings Algorithm"
    },
    {
        " sampling        ": null
    },
    {
        "MISER algorithm": "Miser Algorithm"
    },
    {
        "numerical integration": "Numerical Integration"
    },
    {
        "        Bisection method": "Bisection Method"
    },
    {
        " False position method": "False Position Method"
    },
    {
        "Newtons method": "Newtons Method"
    },
    {
        "calculus": "Calculus"
    },
    {
        " Halleys method": "Halleys Method"
    },
    {
        "Secant method": "Secant Method"
    },
    {
        "False position method": "False Position Method"
    },
    {
        " and Illinois method: 2-point, bracketing   ": null
    },
    {
        "Ridders method": "Ridders Method"
    },
    {
        "Mullers method": "Mullers Method"
    },
    {
        " Alpha–beta pruning": "Alpha–Beta Pruning"
    },
    {
        "Branch and bound": "Branch And Bound"
    },
    {
        " Bruss algorithm": "Bruss Algorithm"
    },
    {
        "odds algorithm": "Odds Algorithm"
    },
    {
        " Chain matrix multiplication": "Chain Matrix Multiplication"
    },
    {
        " Combinatorial optimization": "Combinatorial Optimization"
    },
    {
        "Greedy randomized adaptive search procedure": "Greedy Randomized Adaptive Search Procedure"
    },
    {
        " : successive constructions of a greedy randomized solution and subsequent iterative improvements of it through a local search   ": null
    },
    {
        "Hungarian method": "Hungarian Method"
    },
    {
        "assignment problem": "Assignment Problem"
    },
    {
        " in polynomial time   ": null
    },
    {
        "Constraint satisfaction": "Constraint Satisfaction"
    },
    {
        " AC-3 algorithm": "Ac-3 Algorithm"
    },
    {
        " Difference map algorithm": "Difference Map Algorithm"
    },
    {
        " Min conflicts algorithm": "Min Conflicts Algorithm"
    },
    {
        " Chaff algorithm": "Chaff Algorithm"
    },
    {
        "Davis–Putnam algorithm": "Davis–Putnam Algorithm"
    },
    {
        "Davis–Putnam–Logemann–Loveland algorithm": "Dpll Algorithm"
    },
    {
        " : an algorithm for deciding the satisfiability of propositional logic formula in ": null
    },
    {
        "conjunctive normal form": "Conjunctive Normal Form"
    },
    {
        ", i.e. for solving the ": null
    },
    {
        "CNF-SAT": "Cnf-Sat"
    },
    {
        " problem   ": null
    },
    {
        "Exact cover": "Exact Cover"
    },
    {
        " problem   ": null
    },
    {
        "Algorithm X": "Algorithm X"
    },
    {
        "nondeterministic algorithm": "Nondeterministic Algorithm"
    },
    {
        " Dancing Links": "Dancing Links"
    },
    {
        "Cross-entropy method": "Cross-Entropy Method"
    },
    {
        "importance sampling": "Importance Sampling"
    },
    {
        " Differential evolution": "Differential Evolution"
    },
    {
        " Dynamic Programming": "Dynamic Programming"
    },
    {
        "overlapping subproblems": "Overlapping Subproblem"
    },
    {
        " and ": null
    },
    {
        "optimal substructure": "Optimal Substructure"
    },
    {
        " Ellipsoid method": "Ellipsoid Method"
    },
    {
        "Evolutionary computation": "Evolutionary Computation"
    },
    {
        "Evolution strategy": "Evolution Strategy"
    },
    {
        " Gene expression programming": "Gene Expression Programming"
    },
    {
        " Genetic algorithms": "Genetic Algorithms"
    },
    {
        " Fitness proportionate selection": "Fitness Proportionate Selection"
    },
    {
        " - also known as roulette-wheel selection   ": null
    },
    {
        "Stochastic universal sampling": "Stochastic Universal Sampling"
    },
    {
        " Truncation selection": "Truncation Selection"
    },
    {
        " Tournament selection": "Tournament Selection"
    },
    {
        " Memetic algorithm": "Memetic Algorithm"
    },
    {
        " Swarm intelligence": "Swarm Intelligence"
    },
    {
        " Ant colony optimization": "Ant Colony Optimization"
    },
    {
        " Bees algorithm": "Bees Algorithm"
    },
    {
        "Particle swarm": "Particle Swarm Optimization"
    },
    {
        " golden section search": "Golden Section Search"
    },
    {
        "Gradient descent": "Gradient Descent"
    },
    {
        " Harmony search": "Harmony Search"
    },
    {
        " : a ": null
    },
    {
        "metaheuristic": "Metaheuristic"
    },
    {
        " algorithm mimicking the improvisation process of musicians   ": null
    },
    {
        "Interior point method": "Interior Point Method"
    },
    {
        " Linear programming": "Linear Programming"
    },
    {
        " Bensons algorithm": "Bensons Algorithm"
    },
    {
        "vector optimization": "Vector Optimization"
    },
    {
        " problems   ": null
    },
    {
        "Dantzig–Wolfe decomposition": "Dantzig–Wolfe Decomposition"
    },
    {
        "Delayed column generation": "Delayed Column Generation"
    },
    {
        " Integer linear programming": "Integer Linear Programming"
    },
    {
        "Branch and cut": "Branch And Cut"
    },
    {
        " Cutting-plane method": "Cutting-Plane Method"
    },
    {
        " Karmarkars algorithm": "Karmarkars Algorithm"
    },
    {
        "linear programming": "Linear Programming"
    },
    {
        " problem in ": null
    },
    {
        "polynomial time": "Polynomial Time"
    },
    {
        ".   ": null
    },
    {
        "Simplex algorithm": "Simplex Algorithm"
    },
    {
        "linear programming": "Linear Programming"
    },
    {
        " problems   ": null
    },
    {
        "Line search": "Line Search"
    },
    {
        " Local search": "Local Search"
    },
    {
        "Random-restart hill climbing": "Random-Restart Hill Climbing"
    },
    {
        " Tabu search": "Tabu Search"
    },
    {
        " Minimax": "Minimaxminimax Algorithm With Alternate Moves"
    },
    {
        " used in game programming   ": null
    },
    {
        "Nearest neighbor search": "Nearest Neighbor Search"
    },
    {
        " : find closest points in a ": null
    },
    {
        "metric space": "Metric Space"
    },
    {
        " Best Bin First": "Best Bin First"
    },
    {
        "Nearest neighbor search": "Nearest Neighbor Search"
    },
    {
        " problem in very-high-dimensional spaces   ": null
    },
    {
        "Newtons method in optimization": "Newtons Method In Optimization"
    },
    {
        " Nonlinear optimization": "Nonlinear Optimization"
    },
    {
        " BFGS method": "Bfgs Method"
    },
    {
        "nonlinear optimization": "Nonlinear Optimization"
    },
    {
        " algorithm   ": null
    },
    {
        "Gauss–Newton algorithm": "Gauss–Newton Algorithm"
    },
    {
        "least squares": "Least Squares"
    },
    {
        " problems.   ": null
    },
    {
        "Levenberg–Marquardt algorithm": "Levenberg–Marquardt Algorithm"
    },
    {
        "least squares": "Least Squares"
    },
    {
        " problems.   ": null
    },
    {
        "Nelder–Mead method": "Nelder–Mead Method"
    },
    {
        " : A ": null
    },
    {
        "nonlinear optimization": "Nonlinear Optimization"
    },
    {
        " algorithm   ": null
    },
    {
        "Odds algorithm": "Odds Algorithm"
    },
    {
        " : Finds the optimal strategy to predict a last specific event in a random sequence event   ": null
    },
    {
        "Simulated annealing": "Simulated Annealing"
    },
    {
        " Stochastic tunneling": "Stochastic Tunneling"
    },
    {
        " Subset sum": "Subset Sum Problem"
    },
    {
        " algorithm               ": null
    },
    {
        "Doomsday algorithm": "Doomsday Algorithm"
    },
    {
        "Zellers congruence": "Zellers Congruence"
    },
    {
        " is an algorithm to calculate the day of the week for any Julian or Gregorian calendar date   various ": null
    },
    {
        "Easter algorithms": "Computus"
    },
    {
        " are used to calculate the day of Easter           ": null
    },
    {
        "Basic Local Alignment Search Tool": "Basic Local Alignment Search Tool"
    },
    {
        " also known as BLAST: an algorithm for comparing primary biological sequence information   ": null
    },
    {
        "Kabsch algorithm": "Kabsch Algorithm"
    },
    {
        "root mean squared deviation": "Rmsd"
    },
    {
        " between two protein structures.   ": null
    },
    {
        "Velvet": "Velvet"
    },
    {
        "de Bruijn graphs": "De Bruijn Graph"
    },
    {
        " for genomic ": null
    },
    {
        "sequence assembly": "Sequence Assembly"
    },
    {
        " Sorting by signed reversals": "Sorting By Signed Reversals"
    },
    {
        "Maximum parsimony ": "Maximum Parsimony"
    },
    {
        "UPGMA": "Upgma"
    },
    {
        " Vincentys formulae": "Vincentys Formulae"
    },
    {
        "Geohash": "Geohash"
    },
    {
        " Lesk algorithm": "Lesk Algorithm"
    },
    {
        "Stemming algorithm": "Stemming"
    },
    {
        "Sukhotins algorithm": "Sukhotins Algorithm"
    },
    {
        " ESC algorithm": "Esc Algorithm"
    },
    {
        " for the diagnosis of heart failure   ": null
    },
    {
        "Manning Criteria": "Manning Criteria"
    },
    {
        " for irritable bowel syndrome   ": null
    },
    {
        "Pulmonary embolism": "Pulmonary Embolismalgorithms"
    },
    {
        " diagnostic algorithms   ": null
    },
    {
        "Texas Medication Algorithm Project": "Texas Medication Algorithm Project"
    },
    {
        "        Constraint algorithm": "Constraint Algorithm"
    },
    {
        "Demon algorithm": "Demon Algorithm"
    },
    {
        "Monte Carlo method": "Monte Carlo Method"
    },
    {
        " for efficiently sampling members of a ": null
    },
    {
        "microcanonical ensemble": "Microcanonical Ensemble"
    },
    {
        " with a given energy   ": null
    },
    {
        "Featherstones algorithm": "Featherstones Algorithm"
    },
    {
        "Ground state": "Ground State"
    },
    {
        " approximation   ": null
    },
    {
        "Variational method": "Variational Method"
    },
    {
        " Ritz method": "Ritz Method"
    },
    {
        "N-body problems": "N-Body Problem"
    },
    {
        "   Barnes–Hut simulation": "Barnes–Hut Simulation"
    },
    {
        " instead of  as in a direct-sum simulation.   ": null
    },
    {
        "Fast multipole method": "Fast Multipole Method"
    },
    {
        " : speeds up the calculation of long-ranged forces   ": null
    },
    {
        "Rainflow-counting algorithm": "Rainflow-Counting Algorithm"
    },
    {
        "stress": "Stress"
    },
    {
        " history to a count of elementary stress-reversals for use in ": null
    },
    {
        "fatigue": "Fatigue"
    },
    {
        " analysis   ": null
    },
    {
        "Sweep and prune": "Sweep And Prune"
    },
    {
        "collision detection": "Collision Detection"
    },
    {
        " to limit the number of pairs of solids that need to be checked for collision   ": null
    },
    {
        "VEGAS algorithm": "Vegas Algorithm"
    },
    {
        "Monte Carlo simulations": "Monte Carlo Simulation"
    },
    {
        "        Algorithms for calculating variance": "Algorithms For Calculating Variance"
    },
    {
        "Approximate counting algorithm": "Approximate Counting Algorithm"
    },
    {
        "Bayesian statistics": "Bayesian Statistics"
    },
    {
        " Nested sampling algorithm": "Nested Sampling Algorithm"
    },
    {
        "Clustering Algorithms": "Data Clustering"
    },
    {
        " Average-linkage clustering": "Upgma"
    },
    {
        "Canopy clustering algorithm": "Canopy Clustering Algorithm"
    },
    {
        "Complete-linkage clustering": "Complete-Linkage Clustering"
    },
    {
        "DBSCAN": "Dbscan"
    },
    {
        "Expectation-maximization algorithm": "Expectation-Maximization Algorithm"
    },
    {
        " Fuzzy clustering": "Fuzzy Clustering"
    },
    {
        "Fuzzy c-means": "Fuzzy Clusteringfuzzy C-Means Clustering"
    },
    {
        " FLAME clustering": "Flame Clustering"
    },
    {
        " : define clusters in the dense parts of a dataset and perform cluster assignment solely based on the neighborhood relationships among objects   ": null
    },
    {
        "KHOPCA clustering algorithm": "Khopca Clustering Algorithm"
    },
    {
        "k-means clustering": "K-Means Clustering"
    },
    {
        "k-means++": "K-Means++"
    },
    {
        "k-medoids": "K-Medoids"
    },
    {
        "medoids": "Medoid"
    },
    {
        " as centers   ": null
    },
    {
        "Linde–Buzo–Gray algorithm": "Linde–Buzo–Gray Algorithm"
    },
    {
        "Lloyds algorithm": "Lloyds Algorithm"
    },
    {
        " : group data points into a given number of categories, a popular algorithm for ": null
    },
    {
        "k-means clustering": "K-Means Clustering"
    },
    {
        " OPTICS": "Optics Algorithm"
    },
    {
        "Single-linkage clustering": "Single-Linkage Clustering"
    },
    {
        "SUBCLU": "Subclu"
    },
    {
        "Wards method": "Wards Method"
    },
    {
        " : an agglomerative clustering algorithm, extended to more general Lance–Williams algorithms   ": null
    },
    {
        "WACA clustering algorithm": "Waca Clustering Algorithm"
    },
    {
        "Estimation Theory": "Estimation Theory"
    },
    {
        " Expectation-maximization algorithm": "Expectation-Maximization Algorithm"
    },
    {
        " A class of related algorithms for finding maximum likelihood estimates of parameters in probabilistic models   ": null
    },
    {
        "Ordered subset expectation maximization": "Ordered Subset Expectation Maximization"
    },
    {
        " : used in ": null
    },
    {
        "medical imaging": "Medical Imaging"
    },
    {
        " for ": null
    },
    {
        "positron emission tomography": "Positron Emission Tomography"
    },
    {
        ", ": null
    },
    {
        "single photon emission computed tomography": "Single Photon Emission Computed Tomography"
    },
    {
        " and ": null
    },
    {
        "X-ray": "X-Ray"
    },
    {
        " computed tomography.   ": null
    },
    {
        "Odds algorithm": "Odds Algorithm"
    },
    {
        " Optimal online search for distinguished value in sequential random input   ": null
    },
    {
        "Kalman filter": "Kalman Filter"
    },
    {
        "dynamic system": "Dynamical System"
    },
    {
        " from a series of noisy measurements   ": null
    },
    {
        "False nearest neighbor algorithm": "False Nearest Neighbor Algorithm"
    },
    {
        " estimates ": null
    },
    {
        "fractal dimension": "Fractal Dimension"
    },
    {
        " Hidden Markov model": "Hidden Markov Model"
    },
    {
        " Baum–Welch algorithm": "Baum–Welch Algorithm"
    },
    {
        "posterior mode": "Maximum A Posteriori"
    },
    {
        " estimates for the parameters of a hidden Markov model   ": null
    },
    {
        "Forward-backward algorithm": "Forward-Backward Algorithm"
    },
    {
        " a dynamic programming algorithm for computing the probability of a particular observation sequence   ": null
    },
    {
        "Viterbi algorithm": "Viterbi Algorithm"
    },
    {
        "Partial least squares regression": "Partial Least Squares Regression"
    },
    {
        "Queuing theory": "Queuing Theory"
    },
    {
        " Buzens algorithm": "Buzens Algorithm"
    },
    {
        "Gordon–Newell theorem": "Gordon–Newell Theorem"
    },
    {
        " RANSAC": "Ransac"
    },
    {
        " : an iterative method to estimate parameters of a mathematical model from a set of observed data which contains outliers   ": null
    },
    {
        "Scoring algorithm": "Scoring Algorithm"
    },
    {
        "Newtons method": "Newtons Method"
    },
    {
        " used to solve ": null
    },
    {
        "maximum likelihood": "Maximum Likelihood"
    },
    {
        " equations numerically   ": null
    },
    {
        "Yamartino method": "Yamartino Method"
    },
    {
        "Ziggurat algorithm": "Ziggurat Algorithm"
    },
    {
        "        Tomasulo algorithm": "Tomasulo Algorithm"
    },
    {
        " Clipping": "Clipping"
    },
    {
        " Line clipping": "Line Clipping"
    },
    {
        " Cohen–Sutherland": "Cohen–Sutherland"
    },
    {
        " Cyrus–Beck": "Cyrus–Beck"
    },
    {
        " Fast-clipping": "Fast Clipping"
    },
    {
        " Liang–Barsky": "Liang–Barsky"
    },
    {
        " Nicholl–Lee–Nicholl": "Nicholl–Lee–Nicholl"
    },
    {
        " Sutherland–Hodgman": "Sutherland–Hodgman"
    },
    {
        " Vatti": "Vatti Clipping Algorithm"
    },
    {
        " Weiler–Atherton": "Weiler–Atherton"
    },
    {
        "Contour lines": "Contour Line"
    },
    {
        " and ": null
    },
    {
        "Isosurfaces": "Isosurface"
    },
    {
        "   Marching cubes": "Marching Cubes"
    },
    {
        "Marching squares": "Marching Squares"
    },
    {
        "Marching tetrahedrons": "Marching Tetrahedrons"
    },
    {
        "Marching cubes": "Marching Cubes"
    },
    {
        " Discrete Greens Theorem": "Discrete Greens Theorem"
    },
    {
        "Flood fill": "Flood Fill"
    },
    {
        "Global illumination": "Global Illumination"
    },
    {
        " algorithms: Considers direct illumination and reflection from other objects.   ": null
    },
    {
        "Ambient occlusion": "Ambient Occlusion"
    },
    {
        " Beam tracing": "Beam Tracing"
    },
    {
        " Cone tracing": "Cone Tracing"
    },
    {
        " Image-based lighting": "Image-Based Lighting"
    },
    {
        " Metropolis light transport": "Metropolis Light Transport"
    },
    {
        " Path tracing": "Path Tracing"
    },
    {
        " Photon mapping": "Photon Mapping"
    },
    {
        " Radiosity": "Radiosity"
    },
    {
        " Ray tracing": "Ray Tracing"
    },
    {
        " Hidden surface removal": "Hidden Surface Determination"
    },
    {
        " or ": null
    },
    {
        "Visual surface determination": "Hidden Surface Determination"
    },
    {
        " Newells algorithm": "Newells Algorithm"
    },
    {
        "Painters algorithm": "Painters Algorithm"
    },
    {
        "Scanline rendering": "Scanline Rendering"
    },
    {
        "Warnock algorithm": "Warnock Algorithm"
    },
    {
        " Line Drawing": "Line Drawing Algorithm"
    },
    {
        "Bresenhams line algorithm": "Bresenhams Line Algorithm"
    },
    {
        "DDA line algorithm": "Digital Differential Analyzer"
    },
    {
        "Xiaolin Wus line algorithm": "Xiaolin Wus Line Algorithm"
    },
    {
        "Midpoint circle algorithm": "Midpoint Circle Algorithm"
    },
    {
        "Ramer–Douglas–Peucker algorithm": "Ramer–Douglas–Peucker Algorithm"
    },
    {
        "Shading": "Shading"
    },
    {
        " Gouraud shading": "Gouraud Shading"
    },
    {
        "Phong shading": "Phong Shading"
    },
    {
        "Slerp": "Slerp"
    },
    {
        " : quaternion interpolation for the purpose of animating 3D rotation   ": null
    },
    {
        "Summed area table": "Summed Area Table"
    },
    {
        " : an algorithm for computing the sum of values in a rectangular subset of a grid in constant time        ": null
    },
    {
        "Asymmetric encryption": "Asymmetric Key Algorithm"
    },
    {
        "ElGamal": "Elgamal Encryption"
    },
    {
        " Elliptic curve cryptography": "Elliptic Curve Cryptography"
    },
    {
        " MAE1": "Matei Array Encreption 1"
    },
    {
        " NTRUEncrypt": "Ntruencrypt"
    },
    {
        " RSA": "Rsa"
    },
    {
        "Digital signatures": "Digital Signature"
    },
    {
        " :   ": null
    },
    {
        "DSA": "Digital Signature Algorithm"
    },
    {
        ", and its variants:   ": null
    },
    {
        "ECDSA": "Ecdsa"
    },
    {
        " and  ": null
    },
    {
        "EdDSA": "Eddsa"
    },
    {
        "   RSA": "Rsa"
    },
    {
        "Cryptographic hash functions": "Cryptographic Hash Function"
    },
    {
        " :   ": null
    },
    {
        "BLAKE": "Blake"
    },
    {
        " MD5": "Md5"
    },
    {
        " – Note that there is now a method of generating collisions for MD5   ": null
    },
    {
        "RIPEMD-160": "Ripemd-160"
    },
    {
        " SHA-1": "Sha-1"
    },
    {
        " – Note that there is now a method of generating collisions for SHA-1   ": null
    },
    {
        "SHA-2": "Sha-2"
    },
    {
        "   SHA-3": "Sha-3"
    },
    {
        "   Tiger": "Tiger"
    },
    {
        " , usually used in ": null
    },
    {
        "Tiger tree hashes": "Hash Tree"
    },
    {
        " WHIRLPOOL": "Whirlpool"
    },
    {
        "Cryptographically secure pseudo-random number generators": "Cryptographically Secure Pseudo-Random Number Generator"
    },
    {
        "   Blum Blum Shub": "Blum Blum Shub"
    },
    {
        " - based on the hardness of ": null
    },
    {
        "factorization": "Integer Factorization"
    },
    {
        " Fortuna": "Fortuna"
    },
    {
        ", intended as an improvement on ": null
    },
    {
        "Yarrow algorithm": "Yarrow Algorithm"
    },
    {
        " Linear-feedback shift register": "Linear-Feedback Shift Register"
    },
    {
        "   Yarrow algorithm": "Yarrow Algorithm"
    },
    {
        " Key exchange": "Key Exchange"
    },
    {
        " Diffie–Hellman key exchange": "Diffie–Hellman Key Exchange"
    },
    {
        " Elliptic-curve Diffie-Hellman": "Elliptic-Curve Diffie-Hellman"
    },
    {
        "Key derivation functions": "Key Derivation Function"
    },
    {
        ", often used for ": null
    },
    {
        "password hashing": "Password Hashing"
    },
    {
        " and ": null
    },
    {
        "key stretching": "Key Stretching"
    },
    {
        " bcrypt": "Bcrypt"
    },
    {
        " PBKDF2": "Pbkdf2"
    },
    {
        " scrypt": "Scrypt"
    },
    {
        " Argon2": "Argon2"
    },
    {
        "Message authentication codes": "Message Authentication Code"
    },
    {
        " :   ": null
    },
    {
        "HMAC": "Keyed-Hash Message Authentication Code"
    },
    {
        "Poly1305": "Poly1305"
    },
    {
        " SipHash": "Siphash"
    },
    {
        " Secret sharing": "Secret Sharing"
    },
    {
        ", Secret Splitting, Key Splitting, M of N algorithms   Blakeys Scheme   ": null
    },
    {
        "Shamirs Scheme": "Shamirs Secret Sharing"
    },
    {
        " Symmetric encryption": "Symmetric Key Algorithm"
    },
    {
        "Advanced Encryption Standard": "Advanced Encryption Standard"
    },
    {
        " , winner of ": null
    },
    {
        "NIST": "Nist"
    },
    {
        " competition, also known as ": null
    },
    {
        "Rijndael": "Rijndael"
    },
    {
        " Blowfish": "Blowfish"
    },
    {
        " Twofish": "Twofish"
    },
    {
        " Threefish": "Threefish"
    },
    {
        " Data Encryption Standard": "Data Encryption Standard"
    },
    {
        " , sometimes DE Algorithm, winner of NBS selection competition, replaced by AES for most purposes   ": null
    },
    {
        "IDEA": "International Data Encryption Algorithm"
    },
    {
        " RC4 ": "Rc4"
    },
    {
        " Tiny Encryption Algorithm": "Tiny Encryption Algorithm"
    },
    {
        "   Salsa20": "Salsa20"
    },
    {
        ", and its updated variant ": null
    },
    {
        "ChaCha20": "Salsa20Chachavariant"
    },
    {
        " Post-quantum cryptography": "Post-Quantum Cryptography"
    },
    {
        " Proof-of-work algorithms": "Proof-Of-Work System"
    },
    {
        " Quine–McCluskey algorithm": "Quine–Mccluskey Algorithm"
    },
    {
        "Petricks method": "Petricks Method"
    },
    {
        "Espresso heuristic logic minimizer": "Espresso Heuristic Logic Minimizer"
    },
    {
        "    ALOPEX": "Alopex"
    },
    {
        "machine-learning algorithm": "Machine Learning"
    },
    {
        " Association rule learning": "Association Rule Learning"
    },
    {
        "data mining": "Data Mining"
    },
    {
        " Apriori algorithm": "Apriori Algorithm"
    },
    {
        " Eclat algorithm": "Eclat Algorithm"
    },
    {
        " FP-growth algorithm": "Association Rule Learningfp-Growth Algorithm"
    },
    {
        " One-attribute rule": "One-Attribute Rule"
    },
    {
        " Zero-attribute rule": "Association Rule Learningzero-Attribute Rule"
    },
    {
        " Boosting ": "Boosting"
    },
    {
        "AdaBoost": "Adaboost"
    },
    {
        "BrownBoost": "Brownboost"
    },
    {
        "LogitBoost": "Logitboost"
    },
    {
        "logistic regression": "Logistic Regression"
    },
    {
        " boosting   ": null
    },
    {
        "LPBoost": "Lpboost"
    },
    {
        "linear programming": "Linear Programming"
    },
    {
        " boosting   ": null
    },
    {
        "Bootstrap aggregating": "Bootstrap Aggregating"
    },
    {
        " : technique to improve stability and classification accuracy   ": null
    },
    {
        "Computer Vision": "Computer Vision"
    },
    {
        " Grabcut": "Grabcut"
    },
    {
        " based on ": null
    },
    {
        "Graph cuts": "Graph Cuts In Computer Vision"
    },
    {
        " Decision Trees": "Decision Tree Learning"
    },
    {
        " C4.5 algorithm": "C4.5 Algorithm"
    },
    {
        "ID3 algorithm": "Id3 Algorithm"
    },
    {
        " : Use heuristic to generate small decision trees   ": null
    },
    {
        "Clustering": "Cluster Analysis"
    },
    {
        "unsupervised learning": "Unsupervised Learning"
    },
    {
        " algorithms for grouping and bucketing related input vector.   ": null
    },
    {
        "k-nearest neighbors": "K-Nearest Neighbors"
    },
    {
        " : a method for classifying objects based on closest training examples in the ": null
    },
    {
        "feature space": "Feature Space"
    },
    {
        " Linde–Buzo–Gray algorithm": "Linde–Buzo–Gray Algorithm"
    },
    {
        "Locality-sensitive hashing": "Locality-Sensitive Hashing"
    },
    {
        " : a method of performing probabilistic dimension reduction of high-dimensional data   ": null
    },
    {
        "Neural Network": "Artificial Neural Network"
    },
    {
        " Backpropagation": "Backpropagation"
    },
    {
        "supervised learning": "Supervised Learning"
    },
    {
        " method which requires a teacher that knows, or can calculate, the desired output for any given input   ": null
    },
    {
        "Hopfield net": "Hopfield Net"
    },
    {
        "Recurrent neural network": "Recurrent Neural Network"
    },
    {
        " in which all connections are symmetric   ": null
    },
    {
        "Perceptron": "Perceptron"
    },
    {
        "linear classifier": "Linear Classifier"
    },
    {
        ".   ": null
    },
    {
        "Pulse-coupled neural networks": "Pulse-Coupled Neural Networks"
    },
    {
        " : ": null
    },
    {
        "Neural models": "Artificial Neural Network"
    },
    {
        " proposed by modeling a cats ": null
    },
    {
        "visual cortex": "Visual Cortex"
    },
    {
        " and developed for high-performance ": null
    },
    {
        "biomimetic": "Bionics"
    },
    {
        " image processing.   ": null
    },
    {
        "Radial basis function network": "Radial Basis Function Network"
    },
    {
        "basis functions": "Basis Function"
    },
    {
        " as activation functions   ": null
    },
    {
        "Self-organizing map": "Self-Organizing Map"
    },
    {
        "Random forest": "Random Forest"
    },
    {
        "Reinforcement Learning": "Reinforcement Learning"
    },
    {
        "Q-learning": "Q-Learning"
    },
    {
        "State-Action-Reward-State-Action": "State-Action-Reward-State-Action"
    },
    {
        " : learn a ": null
    },
    {
        "Markov decision process": "Markov Decision Process"
    },
    {
        " policy   ": null
    },
    {
        "Temporal difference learning": "Temporal Difference Learning"
    },
    {
        " Relevance Vector Machine": "Relevance Vector Machine"
    },
    {
        " : similar to SVM, but provides probabilistic classification   ": null
    },
    {
        "Supervised Learning": "Supervised Learning"
    },
    {
        "Support Vector Machines": "Support Vector Machines"
    },
    {
        " : a set of methods which divide multidimensional data by finding a dividing hyperplane with the maximum margin between the two sets   ": null
    },
    {
        "Structured SVM": "Structured Svm"
    },
    {
        "Winnow algorithm": "Winnow Algorithm"
    },
    {
        "multiplicative weight-update scheme": "Multiplicative Weight Update Method"
    },
    {
        "        C3 linearization": "C3 Linearization"
    },
    {
        "Chaitins algorithm": "Chaitins Algorithm"
    },
    {
        "Hindley–Milner type inference algorithm": "Hindley-Milner Type Inference"
    },
    {
        " Rete algorithm": "Rete Algorithm"
    },
    {
        "production rule": "Start Symbol"
    },
    {
        " systems   ": null
    },
    {
        "Sethi-Ullman algorithm": "Sethi-Ullman Algorithm"
    },
    {
        " CYK algorithm": "Cyk Algorithm"
    },
    {
        "context-free grammars": "Context-Free Grammar"
    },
    {
        " in ": null
    },
    {
        "Chomsky normal form": "Chomsky Normal Form"
    },
    {
        " Earley parser": "Earley Parser"
    },
    {
        "context-free grammar": "Context-Free Grammar"
    },
    {
        " GLR parser": "Glr Parser"
    },
    {
        "context-free grammar": "Context-Free Grammar"
    },
    {
        " by ": null
    },
    {
        "Masaru Tomita": "Masaru Tomita"
    },
    {
        ". It is tuned for deterministic grammars, on which it performs almost ": null
    },
    {
        "linear time": "Linear Time"
    },
    {
        " and O in worst case.   ": null
    },
    {
        "Inside-outside algorithm": "Inside-Outside Algorithm"
    },
    {
        "probabilistic context-free grammars": "Probabilistic Context-Free Grammar"
    },
    {
        "   LL parser": "Ll Parser"
    },
    {
        "linear time": "Linear Time"
    },
    {
        " parsing algorithm for a limited class of ": null
    },
    {
        "context-free grammars": "Context-Free Grammar"
    },
    {
        "   LR parser": "Lr Parser"
    },
    {
        "linear time": "Linear Time"
    },
    {
        " parsing algorithm for a larger class of ": null
    },
    {
        "context-free grammars": "Context-Free Grammar"
    },
    {
        ". Variants:   ": null
    },
    {
        "Canonical LR parser": "Canonical Lr Parser"
    },
    {
        " LALR parser": "Look-Ahead Lr Parser"
    },
    {
        " Operator-precedence parser": "Operator-Precedence Parser"
    },
    {
        " SLR parser": "Simple Lr Parser"
    },
    {
        " Simple precedence parser": "Simple Precedence Parser"
    },
    {
        " Packrat parser": "Packrat Parser"
    },
    {
        "linear time": "Linear Time"
    },
    {
        " parsing algorithm supporting some ": null
    },
    {
        "context-free grammars": "Context-Free Grammar"
    },
    {
        " and ": null
    },
    {
        "parsing expression grammars": "Parsing Expression Grammar"
    },
    {
        "   Recursive descent parser": "Recursive Descent Parser"
    },
    {
        "top-down parser": "Top-Down Parsing"
    },
    {
        " suitable for LL grammars   ": null
    },
    {
        "Shunting yard algorithm": "Shunting Yard Algorithm"
    },
    {
        "Pratt parser": "Pratt Parser"
    },
    {
        " Lexical analysis": "Lexical Analysis"
    },
    {
        "        Deutsch–Jozsa algorithm": "Deutsch–Jozsa Algorithm"
    },
    {
        "Grovers algorithm": "Grovers Algorithm"
    },
    {
        "Shors algorithm": "Shors Algorithm"
    },
    {
        "exponential": "Exponential Function"
    },
    {
        " speedup for factoring a number   ": null
    },
    {
        "Simons algorithm": "Simons Algorithm"
    },
    {
        "exponential": "Exponential Function"
    },
    {
        " speedup for a black-box problem        ": null
    },
    {
        "Hopcrofts algorithm": "Dfa Minimizationhopcrofts Algorithm"
    },
    {
        ", ": null
    },
    {
        "Moores algorithm": "Dfa Minimizationmoores Algorithm"
    },
    {
        ", and ": null
    },
    {
        "Brzozowskis algorithm": "Dfa Minimizationbrzozowskis Algorithm"
    },
    {
        "minimizing the number of states in a deterministic finite automaton": "Dfa Minimization"
    },
    {
        " Powerset construction": "Powerset Construction"
    },
    {
        "deterministic automaton": "Deterministic Automaton"
    },
    {
        ".   ": null
    },
    {
        "Tarski–Kuratowski algorithm": "Tarski–Kuratowski Algorithm"
    },
    {
        "non-deterministic algorithm": "Non-Deterministic Algorithm"
    },
    {
        " which provides an upper bound for the complexity of formulas in the ": null
    },
    {
        "arithmetical hierarchy": "Arithmetical Hierarchy"
    },
    {
        " and ": null
    },
    {
        "analytical hierarchy": "Analytical Hierarchy"
    },
    {
        "BCH Codes": "Bch Code"
    },
    {
        "   Berlekamp–Massey algorithm": "Berlekamp–Massey Algorithm"
    },
    {
        " Peterson–Gorenstein–Zierler algorithm": "Peterson–Gorenstein–Zierler Algorithm"
    },
    {
        " Reed–Solomon error correction": "Reed–Solomon Error Correction"
    },
    {
        " BCJR algorithm": "Bcjr Algorithm"
    },
    {
        "Forward error correction": "Forward Error Correction"
    },
    {
        " Gray code": "Gray Code"
    },
    {
        "Hamming codes": "Hamming Code"
    },
    {
        "   Hamming": "Hamming"
    },
    {
        "Hamming code": "Hamming Code"
    },
    {
        " that encodes 4 bits of data into 7 bits by adding 3 parity bits   ": null
    },
    {
        "Hamming distance": "Hamming Distance"
    },
    {
        "Hamming weight": "Hamming Weight"
    },
    {
        " : find the number of 1 bits in a binary word   ": null
    },
    {
        "Redundancy checks": "Redundancy Check"
    },
    {
        "   Adler-32": "Adler-32"
    },
    {
        " Cyclic redundancy check": "Cyclic Redundancy Check"
    },
    {
        " Damm algorithm": "Damm Algorithm"
    },
    {
        " Fletchers checksum": "Fletchers Checksum"
    },
    {
        " Longitudinal redundancy check": "Longitudinal Redundancy Check"
    },
    {
        "   Luhn algorithm": "Luhn Algorithm"
    },
    {
        "Luhn mod N algorithm": "Luhn Mod N Algorithm"
    },
    {
        "Parity": "Parity Bit"
    },
    {
        "Verhoeff algorithm": "Verhoeff Algorithm"
    },
    {
        "        Burrows–Wheeler transform": "Burrows–Wheeler Transform"
    },
    {
        "lossless compression": "Lossless Data Compression"
    },
    {
        " Context tree weighting": "Context Tree Weighting"
    },
    {
        " Delta encoding": "Delta Encoding"
    },
    {
        "Dynamic Markov compression": "Dynamic Markov Compression"
    },
    {
        "Dictionary coders": "Dictionary Coder"
    },
    {
        "   Byte pair encoding": "Byte Pair Encoding"
    },
    {
        "   DEFLATE": "Deflate"
    },
    {
        " Lempel–Ziv": "Lempel–Ziv"
    },
    {
        " LZ77 and LZ78": "Lz77 And Lz78"
    },
    {
        " Lempel–Ziv Jeff Bonwick": "Lzjb"
    },
    {
        "   Lempel–Ziv–Markov chain algorithm": "Lempel–Ziv–Markov Chain Algorithm"
    },
    {
        "   Lempel–Ziv–Oberhumer": "Lempel–Ziv–Oberhumer"
    },
    {
        " : speed oriented   ": null
    },
    {
        "Lempel–Ziv–Stac": "Lempel–Ziv–Stac"
    },
    {
        "   Lempel–Ziv–Storer–Szymanski": "Lempel–Ziv–Storer–Szymanski"
    },
    {
        "   Lempel–Ziv–Welch": "Lempel–Ziv–Welch"
    },
    {
        "   LZWL": "Lzwl"
    },
    {
        "LZX": "Lzx"
    },
    {
        " Lempel–Ziv Ross Williams": "Lzrw"
    },
    {
        "   Entropy encoding": "Entropy Encoding"
    },
    {
        "Arithmetic coding": "Arithmetic Coding"
    },
    {
        "entropy": "Entropy"
    },
    {
        " coding   ": null
    },
    {
        "Range encoding": "Range Encoding"
    },
    {
        "arithmetic coding": "Arithmetic Coding"
    },
    {
        ", but looked at in a slightly different way   ": null
    },
    {
        "Huffman coding": "Huffman Coding"
    },
    {
        "Adaptive Huffman coding": "Adaptive Huffman Coding"
    },
    {
        "adaptive coding": "Adaptive Coding"
    },
    {
        " technique based on Huffman coding   ": null
    },
    {
        "Package-merge algorithm": "Package-Merge Algorithm"
    },
    {
        "Shannon–Fano coding": "Shannon–Fano Coding"
    },
    {
        " Shannon–Fano–Elias coding": "Shannon–Fano–Elias Coding"
    },
    {
        "   Entropy coding with known entropy characteristics": "Entropy Encoding"
    },
    {
        " Golomb coding": "Golomb Coding"
    },
    {
        "Rice coding": "Rice Coding"
    },
    {
        "Truncated binary encoding": "Truncated Binary Encoding"
    },
    {
        " Unary coding": "Unary Coding"
    },
    {
        "Universal codes": "Universal Code"
    },
    {
        "delta": "Elias Delta Coding"
    },
    {
        ", ": null
    },
    {
        "gamma": "Elias Gamma Coding"
    },
    {
        ", and ": null
    },
    {
        "omega": "Elias Omega Coding"
    },
    {
        " coding   ": null
    },
    {
        "Exponential-Golomb coding": "Exponential-Golomb Coding"
    },
    {
        " Fibonacci coding": "Fibonacci Coding"
    },
    {
        " Levenshtein coding": "Levenshtein Coding"
    },
    {
        " Fast Efficient & Lossless Image Compression System": "Felics"
    },
    {
        " : a lossless image compression algorithm   ": null
    },
    {
        "Incremental encoding": "Incremental Encoding"
    },
    {
        "Prediction by partial matching": "Ppm Compression Algorithm"
    },
    {
        " : an adaptive statistical data compression technique based on context modeling and prediction   ": null
    },
    {
        "Run-length encoding": "Run-Length Encoding"
    },
    {
        "SEQUITUR algorithm": "Sequitur Algorithm"
    },
    {
        " 3Dc": "3Dc"
    },
    {
        "normal maps": "Normal Mapping"
    },
    {
        " Audio": "Audio Data Compression"
    },
    {
        " and ": null
    },
    {
        "Speech": "Speech Encoding"
    },
    {
        " compression   ": null
    },
    {
        "A-law algorithm": "A-Law Algorithm"
    },
    {
        "Code-excited linear prediction": "Code-Excited Linear Prediction"
    },
    {
        " : low bit-rate speech compression   ": null
    },
    {
        "Linear predictive coding": "Linear Predictive Coding"
    },
    {
        " : lossy compression by representing the ": null
    },
    {
        "spectral envelope": "Spectral Envelope"
    },
    {
        " of a digital signal of speech in compressed form   ": null
    },
    {
        "Mu-law algorithm": "Mu-Law Algorithm"
    },
    {
        "Warped Linear Predictive Coding": "Warped Linear Predictive Coding"
    },
    {
        "   Image compression": "Image Compression"
    },
    {
        " Block Truncation Coding": "Block Truncation Coding"
    },
    {
        " : a type of lossy image compression technique for greyscale images   ": null
    },
    {
        "Embedded Zerotree Wavelet": "Embedded Zerotree Wavelet"
    },
    {
        "Fast Cosine Transform algorithms": "Fast Cosine Transform"
    },
    {
        " : compute Discrete Cosine Transform efficiently   ": null
    },
    {
        "Fractal compression": "Fractal Compression"
    },
    {
        "Set Partitioning in Hierarchical Trees": "Set Partitioning In Hierarchical Trees"
    },
    {
        "   Wavelet compression": "Wavelet Compression"
    },
    {
        "image compression": "Image Compression"
    },
    {
        "   Transform coding": "Transform Coding"
    },
    {
        "Video compression": "Video Compression"
    },
    {
        " Vector quantization": "Vector Quantization"
    },
    {
        " Adaptive-additive algorithm": "Adaptive-Additive Algorithm"
    },
    {
        " : find the spatial frequency phase of an observed wave source   ": null
    },
    {
        "Discrete Fourier transform": "Discrete Fourier Transform"
    },
    {
        "Bluesteins FFT algorithm": "Bluesteins Fft Algorithm"
    },
    {
        " Bruuns FFT algorithm": "Bruuns Fft Algorithm"
    },
    {
        " Cooley  Tukey FFT algorithm": "Cooley & Ndash;Tukey Fft Algorithm"
    },
    {
        " Fast Fourier transform": "Fast Fourier Transform"
    },
    {
        " Prime-factor FFT algorithm": "Prime-Factor Fft Algorithm"
    },
    {
        " Raders FFT algorithm": "Raders Fft Algorithm"
    },
    {
        " Fast folding algorithm": "Fast Folding Algorithm"
    },
    {
        "Gerchberg–Saxton algorithm": "Gerchberg–Saxton Algorithm"
    },
    {
        "Goertzel algorithm": "Goertzel Algorithm"
    },
    {
        "DTMF": "Dtmf"
    },
    {
        " digit decoding.   ": null
    },
    {
        "Karplus-Strong string synthesis": "Karplus-Strong String Synthesis"
    },
    {
        " Histogram equalization": "Histogram Equalization"
    },
    {
        "Adaptive histogram equalization": "Adaptive Histogram Equalization"
    },
    {
        "Connected-component labeling": "Connected-Component Labeling"
    },
    {
        "Dithering": "Dithering"
    },
    {
        " and ": null
    },
    {
        "half-toning": "Half-Toning"
    },
    {
        " Error diffusion": "Error Diffusion"
    },
    {
        " Floyd–Steinberg dithering": "Floyd–Steinberg Dithering"
    },
    {
        " Ordered dithering": "Ordered Dithering"
    },
    {
        " Riemersma dithering": "Riemersma Dithering"
    },
    {
        " difference-map algorithm": "Difference-Map Algorithm"
    },
    {
        "X-Ray diffraction": "X-Ray Crystallography"
    },
    {
        " microscopy   ": null
    },
    {
        "Feature detection": "Feature Detection"
    },
    {
        " Canny edge detector": "Canny Edge Detector"
    },
    {
        "Generalised Hough transform": "Generalised Hough Transform"
    },
    {
        " Hough transform": "Hough Transform"
    },
    {
        " Marr–Hildreth algorithm": "Marr–Hildreth Algorithm"
    },
    {
        "edge detection": "Edge Detection"
    },
    {
        " algorithm   ": null
    },
    {
        "SIFT": "Scale-Invariant Feature Transform"
    },
    {
        " : is an algorithm to detect and describe local features in images.   ": null
    },
    {
        "SURF ": "Surf"
    },
    {
        "    Richardson–Lucy deconvolution": "Richardson–Lucy Deconvolution"
    },
    {
        "Blind deconvolution": "Blind Deconvolution"
    },
    {
        "point spread function": "Point Spread Function"
    },
    {
        " is unknown.   ": null
    },
    {
        "Median filtering": "Median Filtering"
    },
    {
        " Seam carving": "Seam Carving"
    },
    {
        "Segmentation": "Segmentation"
    },
    {
        "GrowCut algorithm": "Growcut Algorithm"
    },
    {
        "Random walker algorithm": "Random Walker Algorithm"
    },
    {
        " Region growing": "Region Growing"
    },
    {
        " Watershed transformation": "Watershed"
    },
    {
        " Cache algorithms": "Cache Algorithms"
    },
    {
        " CHS conversion": "Chs Conversion"
    },
    {
        "Double dabble": "Double Dabble"
    },
    {
        "Hash Function": "Hash Function"
    },
    {
        "Fowler–Noll–Vo hash function": "Fowler–Noll–Vo Hash Function"
    },
    {
        "Pearson hashing": "Pearson Hashing"
    },
    {
        "Zobrist hashing": "Zobrist Hashing"
    },
    {
        "transposition tables": "Transposition Table"
    },
    {
        "   Unicode Collation Algorithm": "Unicode Collation Algorithm"
    },
    {
        " Xor swap algorithm": "Xor Swap Algorithm"
    },
    {
        " Algorithms for Recovery and Isolation Exploiting Semantics": "Algorithms For Recovery And Isolation Exploiting Semantics"
    },
    {
        " : ": null
    },
    {
        "transaction": "Transaction"
    },
    {
        " recovery   ": null
    },
    {
        "Join algorithms": "Join"
    },
    {
        " Block nested loop": "Block Nested Loop"
    },
    {
        " Hash join": "Hash Join"
    },
    {
        " Nested loop join": "Nested Loop Join"
    },
    {
        " Sort-Merge Join": "Sort-Merge Join"
    },
    {
        "        Bully algorithm": "Bully Algorithm"
    },
    {
        "Byzantine fault tolerance": "Byzantine Fault Tolerance"
    },
    {
        "fault tolerance": "Fault-Tolerant System"
    },
    {
        ".   ": null
    },
    {
        "Clock synchronization": "Clock Synchronization"
    },
    {
        " Berkeley algorithm": "Berkeley Algorithm"
    },
    {
        " Cristians algorithm": "Cristians Algorithm"
    },
    {
        " Intersection algorithm": "Intersection Algorithm"
    },
    {
        " Marzullos algorithm": "Marzullos Algorithm"
    },
    {
        " Dijkstra-Scholten algorithm": "Dijkstra-Scholten Algorithm"
    },
    {
        " Huangs algorithm": "Huangs Algorithm"
    },
    {
        " Lamport ordering": "Lamport Ordering"
    },
    {
        "partial order": "Partial Order"
    },
    {
        "ing of events based on the happened-before relation   ": null
    },
    {
        "Mutual exclusion": "Mutual Exclusion"
    },
    {
        " Lamports Distributed Mutual Exclusion Algorithm": "Lamports Distributed Mutual Exclusion Algorithm"
    },
    {
        " Naimi-Trehels log Algorithm": "Naimi-Trehels Log Algorithm"
    },
    {
        " Maekawas Algorithm": "Maekawas Algorithm"
    },
    {
        " Raymonds Algorithm": "Raymonds Algorithm"
    },
    {
        " Ricart-Agrawala Algorithm": "Ricart-Agrawala Algorithm"
    },
    {
        " Paxos algorithm": "Paxos Algorithm"
    },
    {
        "Raft ": "Raft"
    },
    {
        "Snapshot algorithm": "Snapshot Algorithm"
    },
    {
        "Chandy-Lamport algorithm": "Chandy-Lamport Algorithm"
    },
    {
        " Vector clocks": "Vector Clocks"
    },
    {
        "partial ordering": "Partial Ordering"
    },
    {
        " of events in a distributed system and detect ": null
    },
    {
        "causality": "Causality"
    },
    {
        " violations       ": null
    },
    {
        "Buddy memory allocation": "Buddy Memory Allocation"
    },
    {
        "Garbage collectors": "Garbage Collection"
    },
    {
        " Cheneys algorithm": "Cheneys Algorithm"
    },
    {
        "Semi-space collector": "Semi-Space Collector"
    },
    {
        " Generational garbage collector": "Garbage Collection"
    },
    {
        "Mark-compact algorithm": "Mark-Compact Algorithm"
    },
    {
        "mark-sweep algorithm": "Mark And Sweep"
    },
    {
        " and ": null
    },
    {
        "Cheneys copying algorithm": "Cheneys Algorithm"
    },
    {
        " Mark and sweep": "Mark And Sweep"
    },
    {
        " Semi-space collector": "Semi-Space Collector"
    },
    {
        "Reference counting": "Reference Counting"
    },
    {
        "        Karns algorithm": "Karns Algorithm"
    },
    {
        "Luleå algorithm": "Luleå Algorithm"
    },
    {
        "Network congestion": "Network Congestion"
    },
    {
        " Exponential backoff": "Exponential Backoff"
    },
    {
        " Nagles algorithm": "Nagles Algorithm"
    },
    {
        "Truncated binary exponential backoff": "Truncated Binary Exponential Backoff"
    },
    {
        "        Bankers algorithm": "Bankers Algorithm"
    },
    {
        "Page replacement algorithms": "Page Replacement Algorithms"
    },
    {
        "Adaptive replacement cache": "Adaptive Replacement Cache"
    },
    {
        "Clock with Adaptive Replacement": "Clock With Adaptive Replacement"
    },
    {
        " : is a page replacement algorithm that has performance comparable to ": null
    },
    {
        "Adaptive replacement cache": "Adaptive Replacement Cache"
    },
    {
        "           Dekkers algorithm": "Dekkers Algorithm"
    },
    {
        " Lamports Bakery algorithm": "Lamports Bakery Algorithm"
    },
    {
        " Petersons algorithm": "Petersons Algorithm"
    },
    {
        "        Earliest deadline first scheduling": "Earliest Deadline First Scheduling"
    },
    {
        " Fair-share scheduling": "Fair-Share Scheduling"
    },
    {
        " Least slack time scheduling": "Least Slack Time Scheduling"
    },
    {
        " List scheduling": "List Scheduling"
    },
    {
        " Multi level feedback queue": "Multi Level Feedback Queue"
    },
    {
        " Rate-monotonic scheduling": "Rate-Monotonic Scheduling"
    },
    {
        " Round-robin scheduling": "Round-Robin Scheduling"
    },
    {
        " Shortest job next": "Shortest Job Next"
    },
    {
        " Shortest remaining time": "Shortest Remaining Time"
    },
    {
        " Top-nodes algorithm": "Top-Nodes Algorithm"
    },
    {
        "          Elevator algorithm": "Elevator Algorithm"
    },
    {
        "Shortest seek first": "Shortest Seek First"
    },
    {
        "seek time": "Seek Time"
    }
]