           A fast Fourier transform  is an  |algorithm|Algorithm|  that computes the  |discrete_Fourier_transform|Discrete_Fourier_Transform|  of a sequence, or its inverse .  |Fourier_analysis|Fourier_Analysis|  converts a signal from its original domain to a representation in the  |frequency_domain|Frequency_Domain|  and vice versa. The DFT is obtained by decomposing a  |sequence|Sequence|  of values into components of different frequencies. This operation is useful in many fields, but computing it directly from the definition is often too slow to be practical. An FFT rapidly computes such transformations by  |factorizing|Matrix_Decomposition|  the  |DFT_matrix|Dft_Matrix|  into a product of  |sparse|Sparse_Matrix|  factors. As a result, it manages to reduce the  |complexity|Computational_Complexity_Theory|  of computing the DFT from O  , which arises if one simply applies the definition of DFT, to O , where N is the data size. The difference in speed can be enormous, especially for long data sets where N may be in the thousands or millions. In the presence of  |round-off_error|Round-Off_Error| , many FFT algorithms are much more accurate than evaluating the DFT definition directly or indirectly. There are many different FFT algorithms based on a wide range of published theories, from simple  |complex-number_arithmetic|Complex_Number|  to  |group_theory|Group_Theory|  and  |number_theory|Number_Theory| .     Fast Fourier transforms are widely used for  |applications|Discrete_Fourier_Transformapplications|  in engineering, music, science, and mathematics. The basic ideas were popularized in 1965, but some algorithms had been derived as early as 1805. In 1994,  |Gilbert_Strang|Gilbert_Strang|  described the FFT as the most important  |numerical_algorithm|Numerical_Analysis|  of our lifetime , and it was included in Top 10 Algorithms of 20th Century by the  |IEEE|Ieee|  magazine Computing in Science & Engineering.     The best-known FFT algorithms depend upon the  |factorization|Factorization|  of N, but there are FFTs with  |O|Big_O_Notation| |complexity|Computational_Complexity_Theory|  for all N, even for  |prime|Prime_Number|   N. Many FFT algorithms only depend on the fact that e is an N-th  |primitive_root_of_unity|Primitive_Root_Of_Unity| , and thus can be applied to analogous transforms over any  |finite_field|Finite_Field| , such as  |number-theoretic_transforms|Number-Theoretic_Transform| . Since the inverse DFT is the same as the DFT, but with the opposite sign in the exponent and a 1/N factor, any FFT algorithm can easily be adapted for it.       The development of fast algorithms for DFT can be traced to  |Carl_Friedrich_Gausss|Carl_Friedrich_Gauss|  unpublished work in 1805 when he needed it to interpolate the orbit of asteroids  |Pallas|2_Pallas|  and  |Juno|3_Juno|  from sample observations. His method was very similar to the one published in 1965 by  |James_Cooley|James_Cooley|  and  |John_Tukey|John_Tukey| , who are generally credited for the invention of the modern generic FFT algorithm. While Gausss work predated even  |Joseph_Fouriers|Joseph_Fourier|  results in 1822, he did not analyze the computation time and eventually used other methods to achieve his goal.     Between 1805 and 1965, some versions of FFT were published by other authors.  |Frank_Yates|Frank_Yates|  in 1932 published his version called interaction algorithm, which provided efficient computation of  |Hadamard_and_Walsh_transforms|Hadamard_Transform| . Yates algorithm is still used in the field of statistical design and analysis of experiments. In 1942,  |G._C._Danielson|G._C._Danielson|  and  |Cornelius_Lanczos|Cornelius_Lanczos|  published their version to compute DFT for  |x-ray_crystallography|X-Ray_Crystallography| , a field where calculation of Fourier transforms presented a formidable bottleneck. While many methods in the past had focused on reducing the constant factor for O  computation by taking advantage of symmetries , Danielson and Lanczos realized that one could use the periodicity and apply a doubling trick to get O runtime.     James Cooley and John Tukey published a  |more_general_version_of_FFT|Cooley–Tukey_Fft_Algorithm|  in 1965 that is applicable when N is composite and not necessarily a power of 2. Tukey came up with the idea during a meeting of  |President_Kennedys|President_Kennedy|  Science Advisory Committee where a discussion topic involved detecting nuclear tests by the Soviet Union by setting up sensors to surround the country from outside. To analyze the output of these sensors, an FFT algorithm would be needed. In discussion with Tukey,  |Richard_Garwin|Richard_Garwin|  recognized the general applicability of the algorithm not just to national security problems, but also to a wide range of problems including one of immediate interest to him, determining the periodicities of the spin orientations in a 3-D crystal of Helium-3. Garwin gave Tukeys idea to Cooley  for implementation. Cooley and Tukey published the paper in a relatively short time of six months. As Tukey did not work at IBM, the patentability of the idea was doubted and the algorithm went into the public domain, which, through the computing revolution of the next decade, made FFT one of the indispensable algorithms in digital signal processing.       Let x 0 , …, x N−1 be  |complex_numbers|Complex_Number| . The  |DFT|Discrete_Fourier_Transform|  is defined by the formula     : Xk   xn e   k 0,      where e is a  |primitive|Primitive_Root_Of_Unity|  th root of 1.     Evaluating this definition directly requires O  operations: there are N outputs X k , and each output requires a sum of N terms. An FFT is any method to compute the same results in O operations. All known FFT algorithms require  |Θ|Big_O_Notationuse_In_Computer_Science|  operations, although there is no known proof that a lower complexity score is impossible.     To illustrate the savings of an FFT, consider the count of complex multiplications and additions for N4096 data points. Evaluating the DFTs sums directly involves N 2 complex multiplications and N complex additions, of which O operations can be saved by eliminating trivial operations such as multiplications by 1, leaving about 30 million operations. On the other hand, the radix-2  |Cooley–Tukey_algorithm|Cooley–Tukey_Algorithm| , for N a power of 2, can compute the same result with only log 2  complex multiplications and N  log 2  complex additions, in total about 30,000 operations - a thousand times less than with direct evaluation. In practice, actual performance on modern computers is usually dominated by factors other than the speed of arithmetic operations and the analysis is a complicated subject , but the overall improvement from O  to O remains.                By far the most commonly used FFT is the Cooley–Tukey algorithm. This is a  |divide_and_conquer_algorithm|Divide_And_Conquer_Algorithm|  that  |recursively|Recursion|  breaks down a DFT of any  |composite|Composite_Number|  size N N 1 N 2 into many smaller DFTs of sizes N 1 and N 2 , along with O multiplications by complex  |roots_of_unity|Roots_Of_Unity|  traditionally called  |twiddle_factors|Twiddle_Factor|  .     This method was popularized by a publication of Cooley and Tukey in 1965, but it was later discovered that those two authors had independently re-invented an algorithm known to  |Carl_Friedrich_Gauss|Carl_Friedrich_Gauss|  around 1805 .     The best known use of the Cooley–Tukey algorithm is to divide the transform into two pieces of size N/2 at each step, and is therefore limited to power-of-two sizes, but any factorization can be used in general . These are called the radix-2 and mixed-radix cases, respectively . Although the basic idea is recursive, most traditional implementations rearrange the algorithm to avoid explicit recursion. Also, because the Cooley–Tukey algorithm breaks the DFT into smaller DFTs, it can be combined arbitrarily with any other algorithm for the DFT, such as those described below.            There are FFT algorithms other than Cooley–Tukey.  |Cornelius_Lanczos|Cornelius_Lanczos|  did pioneering work on the FFT and FFS  with  |G._C._Danielson|G._C._Danielson|  .     For N N 1 N 2 with  |coprime|Coprime|  N 1 and N 2 , one can use the  |prime-factor|Prime-Factor_Fft_Algorithm|  algorithm , based on the  |Chinese_remainder_theorem|Chinese_Remainder_Theorem| , to factorize the DFT similarly to Cooley–Tukey but without the twiddle factors. The Rader–Brenner algorithm is a Cooley–Tukey-like factorization but with purely imaginary twiddle factors, reducing multiplications at the cost of increased additions and reduced  |numerical_stability|Numerical_Stability| ; it was later superseded by the  |split-radix|Split-Radix_Fft_Algorithm|  variant of Cooley–Tukey . Algorithms that recursively factorize the DFT into smaller operations other than DFTs include the Bruun and  |QFT|Quick_Fourier_Transform_Algorithm|  algorithms.   |Bruuns_algorithm|Bruuns_Fft_Algorithm| , in particular, is based on interpreting the FFT as a recursive factorization of the  |polynomial|Polynomial|  z N  −  1, here into real-coefficient polynomials of the form z M  −  1 and z 2M  +  az M  +  1.     Another polynomial viewpoint is exploited by the Winograd FFT algorithm, which factorizes z N  −  1 into  |cyclotomic_polynomials|Cyclotomic_Polynomial| —these often have coefficients of 1,  0,  or  −1, and therefore require few multiplications, so Winograd can be used to obtain minimal-multiplication FFTs and is often used to find efficient algorithms for small factors. Indeed, Winograd showed that the DFT can be computed with only O irrational multiplications, leading to a proven achievable lower bound on the number of multiplications for power-of-two sizes; unfortunately, this comes at the cost of many more additions, a tradeoff no longer favorable on modern  |processors|Central_Processing_Unit|  with  |hardware_multipliers|Floating-Point_Unit| . In particular, Winograd also makes use of the PFA as well as an algorithm by Rader for FFTs of prime sizes.      |Raders_algorithm|Raders_Fft_Algorithm| , exploiting the existence of a  |generator|Generating_Set_Of_A_Group|  for the multiplicative  |group|Group|  modulo prime N, expresses a DFT of prime size N as a cyclic  |convolution|Convolution|  of size N − 1, which can then be computed by a pair of ordinary FFTs via the  |convolution_theorem|Convolution_Theorem|  . Another prime-size FFT is due to L. I. Bluestein, and is sometimes called the  |chirp-z_algorithm|Chirp-Z_Algorithm| ; it also re-expresses a DFT as a convolution, but this time of the same size , via the identity     : nk -  2 +   2 +   2.      |Hexagonal_Fast_Fourier_Transform|Hexagonal_Fast_Fourier_Transform|  aims at computing an efficient FFT for the hexagonally sampled data by using a new addressing scheme for hexagonal grids, called Array Set Addressing .       In many applications, the input data for the DFT are purely real, in which case the outputs satisfy the symmetry     : X Xk     and efficient FFT algorithms have been designed for this situation . One approach consists of taking an ordinary algorithm and removing the redundant parts of the computation, saving roughly a factor of two in time and memory. Alternatively, it is possible to express an even-length real-input DFT as a complex DFT of half the length , followed by O post-processing operations.     It was once believed that real-input DFTs could be more efficiently computed by means of the  |discrete_Hartley_transform|Discrete_Hartley_Transform|  , but it was subsequently argued that a specialized real-input DFT algorithm can typically be found that requires fewer operations than the corresponding DHT algorithm for the same number of inputs. Bruuns algorithm is another method that was initially proposed to take advantage of real inputs, but it has not proved popular.     There are further FFT specializations for the cases of real data that have  |even/odd|Even_And_Odd_Functions|  symmetry, in which case one can gain another factor of roughly two in time and memory and the DFT becomes the  |discrete_cosine|Discrete_Cosine_Transform| / |sine_transform|Discrete_Sine_Transform|  . Instead of directly modifying an FFT algorithm for these cases, DCTs/DSTs can also be computed via FFTs of real data combined with O pre- and post-processing.              A fundamental question of longstanding theoretical interest is to prove lower bounds on the  |complexity|Computational_Complexity_Theory|  and exact operation counts of fast Fourier transforms, and many open problems remain. It is not even rigorously proved whether DFTs truly require Ω  operations, even for the simple case of  |power_of_two|Power_Of_Two|  sizes, although no algorithms with lower complexity are known. In particular, the count of arithmetic operations is usually the focus of such questions, although actual performance on modern-day computers is determined by many other factors such as  |cache|Cache|  or  |CPU_pipeline|Pipeline|  optimization.     Following work by  |Shmuel_Winograd|Shmuel_Winograd|  , a tight Θ lower bound is known for the number of real multiplications required by an FFT. It can be shown that only 4N - 2  - 2  - 4 irrational real multiplications are required to compute a DFT of power-of-two length N 2m . Moreover, explicit algorithms that achieve this count are known . However, these algorithms require too many additions to be practical, at least on modern computers with hardware multipliers .     A tight lower bound is not known on the number of required additions, although lower bounds have been proved under some restrictive assumptions on the algorithms. In 1973, Morgenstern proved an Ω lower bound on the addition count for algorithms where the multiplicative constants have bounded magnitudes . This result, however, applies only to the unnormalized Fourier transform , and does not explain why the Fourier matrix is harder to compute than any other unitary matrix under the same scaling.  |Pan|Victor_Pan|  proved an Ω lower bound assuming a bound on a measure of the FFT algorithms asynchronicity , but the generality of this assumption is unclear. For the case of power-of-two N,  |Papadimitriou|Christos_Papadimitriou|  argued that the number N   N of complex-number additions achieved by Cooley–Tukey algorithms is optimal under certain assumptions on the  |graph|Graph|  of the algorithm . Thus far, no published FFT algorithm has achieved fewer than N   N complex-number additions for power-of-two  N.     A third problem is to minimize the total number of real multiplications and additions, sometimes called the arithmetic complexity . Again, no tight lower bound has been proven. Since 1968, however, the lowest published count for power-of-two N was long achieved by the  |split-radix_FFT_algorithm|Split-Radix_Fft_Algorithm| , which requires 4N  - 6N + 8 real multiplications and additions for N math /math  ref name Haynal2011 /  ref name DuhamelVetterli1990 /  ref name EdelmanMcCorquodaleToledo1999 /  ref name GuoBurrus1996 / ref name ShentovMitraHeuteHossen1995 /  .