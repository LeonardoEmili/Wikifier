[
    {
        "In ": null
    },
    {
        "mathematics": "Mathematics"
    },
    {
        " and ": null
    },
    {
        "computer science": "Computer Science"
    },
    {
        ", currying is the technique of translating the evaluation of a ": null
    },
    {
        "function": "Function"
    },
    {
        " that takes multiple ": null
    },
    {
        "arguments": "Parameter"
    },
    {
        " into evaluating a sequence of functions, each with a single argument. For example, a function that takes two arguments, one from X and one from Y, and produces outputs in Z, by currying is translated into a function that takes a single argument from X and produces as outputs functions from Y to Z. Currying is related to, but not the same as, ": null
    },
    {
        "partial application": "Partial Application"
    },
    {
        ".     Currying is useful in both practical and theoretical settings. In ": null
    },
    {
        "functional programming language": "Functional Programming Language"
    },
    {
        "s, and many others, it provides a way of automatically managing how arguments are passed to functions and exceptions. In ": null
    },
    {
        "theoretical computer science": "Theoretical Computer Science"
    },
    {
        ", it provides a way to study functions with multiple arguments in simpler theoretical models which provide only one argument. The most general setting for the strict notion of currying and uncurrying is in the ": null
    },
    {
        "closed monoidal categories": "Closed Monoidal Category"
    },
    {
        ", which underpins a vast generalization of the ": null
    },
    {
        "Curry–Howard correspondence": "Curry–Howard Correspondence"
    },
    {
        " of proofs and programs to a correspondence with many other structures, including quantum mechanics, cobordisms and string theory. It was introduced by ": null
    },
    {
        "Gottlob Frege": "Gottlob Frege"
    },
    {
        ", ": null
    },
    {
        "Willard Van Orman Quine": "Willard Van Orman Quine"
    },
    {
        ", introduction to ": null
    },
    {
        "Moses Schönfinkels": "Moses Schönfinkel"
    },
    {
        " Bausteine der mathematischen Logik , pp.  355  357, esp. 355. Translated by Stefan Bauer-Mengelberg as On the building blocks of mathematical logic in ": null
    },
    {
        "Jean van Heijenoort": "Jean Van Heijenoort"
    },
    {
        " , A Source Book in Mathematical Logic, 1879  1931. Harvard University Press, pp. 355  66. developed by ": null
    },
    {
        "Moses Schönfinkel": "Moses Schönfinkel"
    },
    {
        ",   Kenneth Slonneger and Barry L. Kurtz. Formal Syntax and Semantics of Programming Languages. 1995. p.  144.   and further developed by ": null
    },
    {
        "Haskell Curry": "Haskell Curry"
    },
    {
        ". Henk Barendregt, Erik Barendsen,  , March 2000, page  8.      Uncurrying is the ": null
    },
    {
        "dual": "Duality"
    },
    {
        " transformation to currying, and can be seen as a form of ": null
    },
    {
        "defunctionalization": "Defunctionalization"
    },
    {
        ". It takes a ": null
    },
    {
        "function": "Function"
    },
    {
        " f whose return value is another function g , and yields a new function f that takes as parameters the arguments for both f and g , and returns, as a result, the application of f and subsequently, g , to those arguments. The process can be iterated.       Currying provides a way for working with functions that take multiple arguments, and using them in frameworks where functions might take only one argument. For example, some ": null
    },
    {
        "analytical techniques": "Definition"
    },
    {
        " can only be applied to ": null
    },
    {
        "functions": "Function"
    },
    {
        "with a single argument. Practical functions frequently take more arguments than this. ": null
    },
    {
        "Frege": "Gottlob Frege"
    },
    {
        " showed that it was sufficient to provide solutions for the single argument case, as it was possible to transform a function with multiple arguments into a chain of single-argument functions instead. This transformation is the process now known as currying.  All ordinary functions that might typically be encountered in ": null
    },
    {
        "mathematical analysis": "Mathematical Analysis"
    },
    {
        " or in ": null
    },
    {
        "computer programming": "Computer Programming"
    },
    {
        " can be curried. However, there are categories in which currying is not possible; the most general categories which allow currying are the ": null
    },
    {
        "closed monoidal categories": "Closed Monoidal Category"
    },
    {
        ".     Some ": null
    },
    {
        "programming languages": "Programming Language"
    },
    {
        "almost always use curried functions to achieve multiple arguments; notable examples are ": null
    },
    {
        "ML": "Ml Programming Language"
    },
    {
        " and ": null
    },
    {
        "Haskell": "Haskell"
    },
    {
        ", where in both cases all functions have exactly one argument. This property is inherited from ": null
    },
    {
        "lambda calculus": "Lambda Calculus"
    },
    {
        ", where multi-argument functions are usually represented in curried form.     Currying is related to, but not the same as ": null
    },
    {
        "partial application": "Partial Application"
    },
    {
        ". In practice, the programming technique of ": null
    },
    {
        "closures": "Closure"
    },
    {
        " can be used to perform partial application and a kind of currying, by hiding arguments in an environment that travels with the curried function.       Suppose we have a function f:  which takes two real arguments and outputs real numbers, and it is defined by fx+y2 . Currying translates this into a function h which takes a single real argument and outputs functions from   to   . In symbols, h:  , where   denotes the set of all functions that take a single real argument and produce real outputs. For every real number x , define the function hx :   by hxx+y2 , and then define the function h:  by hhx . So for instance, h is the function that sends its real argument y to the output 2+y2 , or hh22+y2 . We see that in general     : hx+y2f     so that the original function f and its currying h convey exactly the same information. In this situation, we also write     :   h.     This also works for functions with more than two arguments. If f were a function of three arguments f , its currying h would have the property     : fh.       The name currying , coined by ": null
    },
    {
        "Christopher Strachey": "Christopher Strachey"
    },
    {
        " in 1967, is a reference to logician ": null
    },
    {
        "Haskell Curry": "Haskell Curry"
    },
    {
        ". The alternative name Schönfinkelisation has been proposed as a reference to ": null
    },
    {
        "Moses Schönfinkel": "Moses Schönfinkel"
    },
    {
        ". I. Heim and A. Kratzer . Semantics in Generative Grammar. Blackwell. In the mathematical context, the principle can be traced back to work in 1893 by ": null
    },
    {
        "Frege": "Gottlob Frege"
    },
    {
        ".       Currying is most easily understood by starting with an informal definition, which can then be molded to fit many different domains. First, there is some notation to be established. The notation X   Y denotes all ": null
    },
    {
        "functions": "Function"
    },
    {
        " from X to Y . If f is such a function, we write f   X   Y . Let X   Y denote the ": null
    },
    {
        "ordered pairs": "Ordered Pair"
    },
    {
        "of the elements of X and Y respectively, that is, the ": null
    },
    {
        "Cartesian product": "Cartesian Product"
    },
    {
        " of X and Y . Here, X and Y may be sets, or they may be types, or they may be other kinds of objects, as explored below.     Given a function     : f     Z ,     currying constructs a new function     : h   X   .     That is, h takes an argument from X and returns a function that maps Y to Z . It is defined by     : hf     for x from X and y from Y . We then also write     :       Uncurrying is the reverse transformation, and is most easily understood in terms of its right adjoint, the ": null
    },
    {
        "function   ": "Apply"
    },
    {
        "       In ": null
    },
    {
        "set theory": "Set Theory"
    },
    {
        ", the notation YX is used to denote the ": null
    },
    {
        "set": "Set"
    },
    {
        " of functions from the set X to the set Y . Currying is the ": null
    },
    {
        "natural bijection": "Natural Equivalence"
    },
    {
        " between the set A of functions from B  C to A , and the set B of functions from B to the set of functions from C to A . In symbols:     : A  B     Indeed, it is this natural bijection that justifies the ": null
    },
    {
        "exponential notation": "Exponential Notation"
    },
    {
        " for the set of functions. As is the case in all instances of currying, the formula above describes an ": null
    },
    {
        "adjoint pair of functors": "Adjoint Functors"
    },
    {
        "category of sets": "Category Of Sets"
    },
    {
        ", the ": null
    },
    {
        "object": "Mathematical Object"
    },
    {
        " YX is called the ": null
    },
    {
        "exponential object": "Exponential Object"
    },
    {
        ".       In the theory of ": null
    },
    {
        "function space": "Function Space"
    },
    {
        "s, such as in ": null
    },
    {
        "functional analysis": "Functional Analysis"
    },
    {
        " or ": null
    },
    {
        "homotopy theory": "Homotopy Theory"
    },
    {
        ", one is commonly interested in ": null
    },
    {
        "continuous functions": "Continuous Function"
    },
    {
        "between ": null
    },
    {
        "topological space": "Topological Space"
    },
    {
        "s. One writes    for the set of all functions from X to Y , and uses the notation YX to denote the subset of continuous functions. Here,   is the ": null
    },
    {
        "bijection": "Bijection"
    },
    {
        "     :       ,     while uncurrying is the inverse map. If the set YX of continuous functions from X to Y is given the ": null
    },
    {
        "compact-open topology": "Compact-Open Topology"
    },
    {
        ", and if the space Y is ": null
    },
    {
        "locally compact Hausdorff": "Locally Compact Hausdorff"
    },
    {
        ", then     :   : Z  X     is a ": null
    },
    {
        "homeomorphism": "Homeomorphism"
    },
    {
        ". This is also the case when X , Y and YX are ": null
    },
    {
        "kaonized": "Compactly Generated Space"
    },
    {
        ", J.P. May, http://www.math.uchicago.edu/~may/CONCISE/ConciseRevised.pdf A Concise Course in Algebraic Topology, Chicago Lectures in Mathematics    although there are more cases. P. I. Booth and J. Tillotson,  , Pacific Journal of Mathematics, 88 pp.33-53.      One useful corollary is that a function is continuous ": null
    },
    {
        "if and only if": "If And Only If"
    },
    {
        " its curried form is continuous. Another important result is that the ": null
    },
    {
        "application map": "Apply"
    },
    {
        ", usually called evaluation in this context, is continuous  That is,       & &     X   Y     & &   f       is continuous when YX is compact-open and Y locally compact Hausdorff. Joseph J. Rotman, An Introduction to Algebraic Topology Springer-Verlag   These two results are central for establishing the continuity of ": null
    },
    {
        "homotopy": "Homotopy"
    },
    {
        ", i.e. when X is the unit interval I , so that Z   I can the thought of as either a homotopy of two functions from Y to Z , or, equivalently, a single path in ZY .       In ": null
    },
    {
        "algebraic topology": "Algebraic Topology"
    },
    {
        ", currying serves as an example of ": null
    },
    {
        "Eckmann–Hilton duality": "Eckmann–Hilton Duality"
    },
    {
        ", and, as such, plays an important role in a variety of different settings. For example, ": null
    },
    {
        "loop space": "Loop Space"
    },
    {
        " is adjoint to ": null
    },
    {
        "reduced suspension": "Reduced Suspension"
    },
    {
        "s; this is commonly written as   :     where is the set of ": null
    },
    {
        "homotopy class": "Homotopy Class"
    },
    {
        "es of maps A   B , and   A is the ": null
    },
    {
        "suspension": "Suspension"
    },
    {
        " of A, and   A is the ": null
    },
    {
        "loop space": "Loop Space"
    },
    {
        " of A. In essence, the suspension   X can be seen as the cartesian product of X with the unit interval, modulo an equivalence relation to turn the interval into a loop. The curried form then maps the space X to the space of functions from loops into Z , that is, from X into   Z . Then   is the ": null
    },
    {
        "adjoint functor": "Adjoint Functor"
    },
    {
        " that maps suspensions to loop spaces, and uncurrying is the dual.     The duality between the ": null
    },
    {
        "mapping cone": "Mapping Cone"
    },
    {
        " and the mapping fiber   can be understood as a form of currying, which in turn leads to the duality of the ": null
    },
    {
        "long exact": "Long Exact Sequence"
    },
    {
        " and coexact ": null
    },
    {
        "Puppe sequence": "Puppe Sequence"
    },
    {
        "s.     In ": null
    },
    {
        "homological algebra": "Homological Algebra"
    },
    {
        ", the relationship between currying and uncurrying is known as ": null
    },
    {
        "tensor-hom adjunction": "Tensor-Hom Adjunction"
    },
    {
        ". Here, an interesting twist arises: the ": null
    },
    {
        "Hom functor": "Hom Functor"
    },
    {
        " and the ": null
    },
    {
        "tensor product": "Tensor Product"
    },
    {
        " functor might not ": null
    },
    {
        "lift": "Lift"
    },
    {
        " to an ": null
    },
    {
        "exact sequence": "Exact Sequence"
    },
    {
        "; this leads to the definition of the ": null
    },
    {
        "Ext functor": "Ext Functor"
    },
    {
        " and the ": null
    },
    {
        "Tor functor": "Tor Functor"
    },
    {
        ".       In ": null
    },
    {
        "order theory": "Order Theory"
    },
    {
        ", that is, the theory of ": null
    },
    {
        "lattices": "Lattice"
    },
    {
        " of ": null
    },
    {
        "partially ordered set": "Partially Ordered Set"
    },
    {
        "s,   is a ": null
    },
    {
        "continuous function": "Continuous Function"
    },
    {
        " when the lattice is given the ": null
    },
    {
        "Scott topology": "Scott Topology"
    },
    {
        ".   Scott-continuous functions were first investigated in the attempt to provide a semantics for ": null
    },
    {
        "lambda calculus": "Lambda Calculus"
    },
    {
        " . More generally, Scott-continuous functions are now studied in ": null
    },
    {
        "domain theory": "Domain Theory"
    },
    {
        ", which encompasses the study of ": null
    },
    {
        "denotational semantics": "Denotational Semantics"
    },
    {
        " of computer algorithms. Note that the Scott topology is quite different than many common topologies one might encounter in the ": null
    },
    {
        "category of topological spaces": "Category Of Topological Spaces"
    },
    {
        "; the Scott topology is typically ": null
    },
    {
        "finer": "Final Topology"
    },
    {
        ", and is not ": null
    },
    {
        "sober": "Sober Space"
    },
    {
        ".     The notion of continuity makes its appearance in ": null
    },
    {
        "homotopy type theory": "Homotopy Type Theory"
    },
    {
        ", where, roughly speaking, two computer programs can be considered to be homotopic, i.e. compute the same results, if they can be continuously ": null
    },
    {
        "refactored": "Code Refactoring"
    },
    {
        " from one to the other.       In ": null
    },
    {
        "theoretical computer science": "Theoretical Computer Science"
    },
    {
        ", currying provides a way to study functions with multiple arguments in very simple theoretical models, such as the ": null
    },
    {
        "lambda calculus": "Lambda Calculus"
    },
    {
        ", in which functions only take a single argument. Consider a function f taking two arguments, and having the type   Z , which should be understood to mean that x must have the type X , y must have the type Y , and the function itself returns the type Z . The curried form of f is defined as     :     x.     where   is the abstractor of lambda calculus. Since curry takes, as input, functions with the type   Z , one concludes that the type of curry itself is     :         The → operator is often considered ": null
    },
    {
        "right-associative": "Right-Associative"
    },
    {
        ", so the curried function type X   is often written as X   Y   Z . Conversely, ": null
    },
    {
        "function application": "Function Application"
    },
    {
        " is considered to be ": null
    },
    {
        "left-associative": "Operator Associativity"
    },
    {
        ", so that f is equivalent to     :     x   .     That is, the parenthesis are not required to disambiguate the order of the application.     Curried functions may be used in any ": null
    },
    {
        "programming language": "Programming Language"
    },
    {
        " that supports ": null
    },
    {
        "closure": "Closure"
    },
    {
        "s; however, uncurried functions are generally preferred for efficiency reasons, since the overhead of partial application and closure creation can then be avoided for most function calls.       In ": null
    },
    {
        "type theory": "Type Theory"
    },
    {
        ", the general idea of a ": null
    },
    {
        "type system": "Type System"
    },
    {
        " in computer science is formalized into a specific algebra of types. For example, when writing f   X   Y , the intent is that X and Y are ": null
    },
    {
        "types": "Type System"
    },
    {
        ", while the arrow   is a ": null
    },
    {
        "type constructor": "Type Constructor"
    },
    {
        ", specifically, the ": null
    },
    {
        "function type": "Function Type"
    },
    {
        " or arrow type. Similarly, the Cartesian product X   Y of types is constructed by the ": null
    },
    {
        "product type": "Product Type"
    },
    {
        " constructor   .     The type-theoretical approach is expressed in programming languages such as ": null
    },
    {
        "ML": "Ml"
    },
    {
        " and the languages derived from and inspired by it: ": null
    },
    {
        "CaML": "Caml"
    },
    {
        ", ": null
    },
    {
        "Haskell": "Haskell"
    },
    {
        " and ": null
    },
    {
        "F": "F Sharp"
    },
    {
        ".     The type-theoretical approach provides a natural complement to the language of ": null
    },
    {
        "category theory": "Category Theory"
    },
    {
        ", as discussed below. This is because categories, and specifically, ": null
    },
    {
        "monoidal categories": "Monoidal Categories"
    },
    {
        ", have an ": null
    },
    {
        "internal language": "Internal Language"
    },
    {
        ", with ": null
    },
    {
        "simply-typed lambda calculus": "Simply-Typed Lambda Calculus"
    },
    {
        " being the most prominent example of such a language. It is important in this context, because it can be built from a single type constructor, the arrow type. Currying then endows the language with a natural product type. The correspondence between objects in categories and types then allows programming languages to be re-interpreted as logics , and as other types of mathematical systems, as explored further, below.       Under the ": null
    },
    {
        "Curry–Howard correspondence": "Curry–Howard Correspondence"
    },
    {
        ", the existence of currying and uncurrying is equivalent to the logical theorem   C   A   , as ": null
    },
    {
        "tuples": "Tuple"
    },
    {
        "  corresponds to conjunction in logic, and function type corresponds to implication.     The ": null
    },
    {
        "exponential object": "Exponential Object"
    },
    {
        " QP in the category of ": null
    },
    {
        "Heyting algebras": "Heyting Algebra"
    },
    {
        "is normally written as ": null
    },
    {
        "material implication": "Material Conditional"
    },
    {
        " P  Q . Distributive Heyting algebras are ": null
    },
    {
        "Boolean algebra": "Boolean Algebra"
    },
    {
        "s, and the exponential object has the explicit form   P   Q , thus making it clear that the exponential object really is ": null
    },
    {
        "material implication": "Material Implication"
    },
    {
        ". Saunders Mac Lane and Ieke Moerdijk, Sheaves in Geometry and Logic Springer         The above notions of currying and uncurrying find their most general, abstract statement in ": null
    },
    {
        "category theory": "Category Theory"
    },
    {
        ". Currying is a ": null
    },
    {
        "universal property": "Universal Property"
    },
    {
        " of an ": null
    },
    {
        "exponential object": "Exponential Object"
    },
    {
        ", and gives rise to an ": null
    },
    {
        "adjunction": "Adjunction"
    },
    {
        " in ": null
    },
    {
        "cartesian closed categories": "Cartesian Closed Category"
    },
    {
        ". That is, there is a ": null
    },
    {
        "natural": "Natural Transformation"
    },
    {
        " isomorphism": "Isomorphism"
    },
    {
        " between the ": null
    },
    {
        "morphisms": "Morphism"
    },
    {
        " from a ": null
    },
    {
        "binary product": "Product"
    },
    {
        " f     Z and the morphisms to an exponential object g   X   ZY .     This generalizes to a broader result in ": null
    },
    {
        "closed monoidal categories": "Closed Monoidal Category"
    },
    {
        "tensor product": "Monoidal Category"
    },
    {
        " and the ": null
    },
    {
        "internal Hom": "Internal Hom"
    },
    {
        " are ": null
    },
    {
        "adjoint functors": "Adjoint Functors"
    },
    {
        "; that is, for every object B there is a ": null
    },
    {
        "natural isomorphism": "Natural Transformation"
    },
    {
        "Hom denotes the Hom-functor of all morphisms in the category, while B  C denotes the internal hom functor in the closed monoidal category. For the ": null
    },
    {
        "category of sets": "Category Of Sets"
    },
    {
        ", the two are the same. When the product is the cartesian product, then the internal hom B  C becomes the exponential object CB .     Currying can break down in one of two ways. One is if a category is not ": null
    },
    {
        "closed": "Closed Category"
    },
    {
        ", and thus lacks an internal hom functor . Another ways is if it is not ": null
    },
    {
        "monoidal": "Monoidal Category"
    },
    {
        ", and thus lacks a product . Categories that do have both products and internal homs are exactly the closed monoidal categories.     The setting of cartesian closed categories is sufficient for the discussion of ": null
    },
    {
        "classical logic": "Classical Logic"
    },
    {
        "; the more general setting of closed monoidal categories is suitable for ": null
    },
    {
        "quantum computation": "Quantum Computation"
    },
    {
        ". Samson Abramsky and Bob Coecke, .     The difference between these two is that the ": null
    },
    {
        "product": "Product"
    },
    {
        " for cartesian categories  is just the ": null
    },
    {
        "Cartesian product": "Cartesian Product"
    },
    {
        "; it is interpreted as an ": null
    },
    {
        "ordered pair": "Ordered Pair"
    },
    {
        " of items . ": null
    },
    {
        "Simply typed lambda calculus": "Simply Typed Lambda Calculus"
    },
    {
        " is the ": null
    },
    {
        "internal language": "Internal Language"
    },
    {
        " of cartesian closed categories; and it is for this reason that pairs and lists are the primary ": null
    },
    {
        "types": "Type System"
    },
    {
        " in the ": null
    },
    {
        "type theory": "Type Theory"
    },
    {
        " of ": null
    },
    {
        "LISP": "Lisp"
    },
    {
        ", ": null
    },
    {
        "scheme": "Scheme"
    },
    {
        " and many ": null
    },
    {
        "functional programming language": "Functional Programming Language"
    },
    {
        "s.     By contrast, the product for ": null
    },
    {
        "monoidal categories": "Monoidal Category"
    },
    {
        "  is the ": null
    },
    {
        "tensor product": "Tensor Product"
    },
    {
        ". The internal language of such categories is ": null
    },
    {
        "linear logic": "Linear Logic"
    },
    {
        ", a form of ": null
    },
    {
        "quantum logic": "Quantum Logic"
    },
    {
        "; the corresponding ": null
    },
    {
        "type system": "Type System"
    },
    {
        " is the ": null
    },
    {
        "linear type system": "Linear Type System"
    },
    {
        ". Such categories are suitable for describing ": null
    },
    {
        "entangled quantum states": "Entangled Quantum States"
    },
    {
        ", and, more generally, allow a vast generalization of the ": null
    },
    {
        "Curry–Howard correspondence": "Curry–Howard Correspondence"
    },
    {
        " to ": null
    },
    {
        "quantum mechanics": "Quantum Mechanics"
    },
    {
        ", to ": null
    },
    {
        "cobordisms": "Cobordism"
    },
    {
        "in ": null
    },
    {
        "algebraic topology": "Algebraic Topology"
    },
    {
        ", and to ": null
    },
    {
        "string theory": "String Theory"
    },
    {
        ". John C. Baez and Mike Stay,  ,  in New Structures for Physics, ed. Bob Coecke, Lecture Notes in Physics vol. 813, Springer, Berlin, 2011, pp. 95-174. The ": null
    },
    {
        "linear type system": "Linear Type System"
    },
    {
        ", and ": null
    },
    {
        "linear logic": "Linear Logic"
    },
    {
        " are useful for describing ": null
    },
    {
        "synchronization primitive": "Synchronization Primitive"
    },
    {
        "s, such as mutual exclusion locks, and the operation of vending machines.          Currying and partial function application are often conflated.  One of the significant differences between the two is that a call to a partially applied function returns the result right away, not another function down the currying chain; this distinction can be illustrated clearly for functions whose ": null
    },
    {
        "arity": "Arity"
    },
    {
        " is greater than two.      Given a function of type f     N , currying produces     X   . That is, while an evaluation of the first function might be represented as f , evaluation of the curried function would be represented as f  , applying each argument in turn to a single-argument function returned by the previous invocation. Note that after calling f  , we are left with a function that takes a single argument and returns another function, not a function that takes two arguments.     In contrast, partial function application refers to the process of fixing a number of arguments to a function, producing another function of smaller arity. Given the definition of f above, we might fix the first argument, producing a function of type       N . Evaluation of this function might be represented as f  . Note that the result of partial function application in this case is a function that takes two arguments.     Intuitively, partial function application says if you fix the first ": null
    },
    {
        "argument": "Parameter"
    },
    {
        " of the function, you get a function of the remaining arguments . For example, if function div stands for the division operation x/y, then div with the parameter x fixed at 1  is another function: the same as the function inv that returns the multiplicative inverse of its argument, defined by inv  1/y": null
    }
]