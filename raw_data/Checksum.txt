          A checksum is a small-sized  |datum|Datum|  derived from a block of  |digital_data|Digital_Data|  for the purpose of  |detecting_errors|Error_Detection|  that may have been introduced during its  |transmission|Telecommunication|  or  |storage|Computer_Storage| . It is usually applied to an installation file after it is received from the download server. By themselves, checksums are often used to verify data integrity but are not relied upon to verify data  |authenticity|Authentication| .     The actual  |procedure|Algorithm|  which yields the checksum from a data input is called a checksum function or  checksum algorithm . Depending on its design goals, a good checksum algorithm will usually output a significantly different value, even for small changes made to the input. This is especially true of  |cryptographic_hash_functions|Cryptographic_Hash_Function| , which may be used to detect many data corruption errors and verify overall  |data_integrity|Data_Integrity| ; if the computed checksum for the current data input matches the stored value of a previously computed checksum, there is a very high probability the data has not been accidentally altered or corrupted.     Checksum functions are related to  |hash_functions|Hash_Function| ,  |fingerprints|Fingerprint| ,  |randomization_functions|Randomization_Function| , and  |cryptographic_hash_functions|Cryptographic_Hash_Function| . However, each of those concepts has different applications and therefore different design goals. For instance, a function returning the start of a string can provide a hash appropriate for some applications but will never be a suitable checksum. Checksums are used as  |cryptographic_primitives|Cryptographic_Primitive|  in larger authentication algorithms. For cryptographic systems with these two specific design goals, see  |HMAC|Hash_Based_Message_Authentication_Code| .      |Check_digits|Check_Digit|  and  |parity_bits|Parity_Bit|  are special cases of checksums, appropriate for small blocks of data . Some  |error_correcting_codes|Error_Correcting_Code|  are based on special checksums which not only detect common errors but also allow the original data to be recovered in certain cases.         The simplest checksum algorithm is the so-called  |longitudinal_parity_check|Longitudinal_Redundancy_Check| , which breaks the data into words with a fixed number n of bits, and then computes the  |exclusive_or|Exclusive_Or|  of all those words. The result is appended to the message as an extra word. To check the integrity of a message, the receiver computes the exclusive or of all its words, including the checksum; if the result is not a word consisting of n zeros, the receiver knows a transmission error occurred.     With this checksum, any transmission error which flips a single bit of the message, or an odd number of bits, will be detected as an incorrect checksum. However, an error which affects two bits will not be detected if those bits lie at the same position in two distinct words. Also swapping of two or more words will not be detected. If the affected bits are independently chosen at random, the probability of a two-bit error being undetected is 1/n.         A variant of the previous algorithm is to add all the words as unsigned binary numbers, discarding any overflow bits, and append the  |twos_complement|Twos_Complement|  of the total as the checksum. To validate a message, the receiver adds all the words in the same manner, including the checksum; if the result is not a word full of zeros, an error must have occurred. This variant too detects any single-bit error, but the promodular sum is used in  |SAE_J1708|J1708| .          The simple checksums described above fail to detect some common errors which affect many bits at once, such as changing the order of data words, or inserting or deleting words with all bits set to zero. The checksum algorithms most used in practice, such as  |Fletchers_checksum|Fletchers_Checksum| ,  |Adler_32|Adler_32| , and  |cyclic_redundancy_checks|Cyclic_Redundancy_Check|  , address these weaknesses by considering not only the value of each word but also its position in the sequence. This feature generally increases the  |cost|Analysis_Of_Algorithms|  of computing the checksum.         A message that is m bits long can be viewed as a corner of the m-dimensional hypercube. The effect of a checksum algorithm that yields an n-bit checksum is to map each m-bit message to a corner of a larger hypercube, with dimension . The 2 m+n corners of this hypercube represent all possible received messages. The valid received messages comprise a smaller set, with only 2 m corners.     A single-bit transmission error then corresponds to a displacement from a valid corner to one of the m adjacent corners. An error which affects k bits moves the message to a corner which is k .