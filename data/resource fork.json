[
    {
        "The resource fork is a ": null
    },
    {
        "fork or section": "fork"
    },
    {
        " of a ": null
    },
    {
        "file": "file"
    },
    {
        " on ": null
    },
    {
        "Apple": "apple inc."
    },
    {
        "s ": null
    },
    {
        "classic Mac OS": "classic mac os"
    },
    {
        " operating system": "operating system"
    },
    {
        ", which was also carried over to the modern ": null
    },
    {
        "macOS": "macos"
    },
    {
        " for compatibility, used to store structured data along with the unstructured data stored within the data fork.     A resource fork stores information in a specific form, containing details such as icon bitmaps, the shapes of windows, definitions of menus and their contents, and application code . For example, a word processing file might store its text in the data fork, while storing any embedded images in the same files resource fork. The resource fork is used mostly by ": null
    },
    {
        "executable": "executable"
    },
    {
        "s, but every file is able to have a resource fork.            Originally conceived and implemented by programmer ": null
    },
    {
        "Bruce Horn": "bruce horn"
    },
    {
        ", the resource fork was used for three purposes with ": null
    },
    {
        "Macintosh file system": "hierarchical file system"
    },
    {
        ":   It was used to store all graphical data on disk until it was needed, then retrieved, drawn on the screen, and thrown away. This software variant of ": null
    },
    {
        "virtual memory": "virtual memory"
    },
    {
        " helped Apple to reduce memory requirements from 42 MB in the ": null
    },
    {
        "Apple Lisa": "apple lisa"
    },
    {
        " to 42  KB in Macintosh.   Because all the pictures and text were stored separately in a resource fork, it could be used to allow a non-programmer to translate an application for a foreign market, a process called ": null
    },
    {
        "internationalization and localization": "internationalization and localization"
    },
    {
        ".   It could be used to distribute nearly all of the components of an application in a single file, reducing clutter and simplifying application installation and removal.     The resource fork is implemented in all of the ": null
    },
    {
        "file system": "file system"
    },
    {
        "s used for system drives on the ": null
    },
    {
        "Macintosh": "apple macintosh"
    },
    {
        " . The presence of a resource fork makes it easy to store a variety of additional information, such as allowing the system to display the correct icon for a file and open it without the need for a ": null
    },
    {
        "file extension": "file extension"
    },
    {
        " in the file name. While access to the data fork works like file access on any other operating system — pick a file, pick a byte offset, read some data — access to the resource fork works more like extracting structured records from a ": null
    },
    {
        "database": "database"
    },
    {
        ".      The resource fork is sometimes used to store the ": null
    },
    {
        "metadata": "metadata"
    },
    {
        " of a file, although it can also be used for storing the actual data, as was the case with font files in the classic Mac operating systems. Note that the Macintosh file systems also have a separate area for metadata distinct from either the data or resource fork. Being part of the catalogue entry for the file, it is much faster to access this. However, the amount of data stored here is minimal, being just the creation and modification timestamps, the file type and creator codes, fork lengths, and the file name.   Some files have only a resource fork. Classic ": null
    },
    {
        "42k": "68k"
    },
    {
        " applications are one example, where even the executable code is contained in resources of type CODE. Later ": null
    },
    {
        "PowerPC": "powerpc"
    },
    {
        " binaries store the executable code in the data fork.     As resource forks are supported only on the file systems HFS and HFS Plus, they cannot be used on ": null
    },
    {
        "operating system": "operating system"
    },
    {
        "s which use other file systems. At present, HFS is supported only by the Macintosh operating system, which means that only machines running Mac OS can use resource forks. Even in a Mac OS system, resource forks cannot be used if the ": null
    },
    {
        "Unix File System": "unix file system"
    },
    {
        " has been ": null
    },
    {
        "installed": "installation"
    },
    {
        ". In the HFS Plus file system, which is currently the system most commonly used under Mac OS, settings can be made to allow other forks in addition to the data and resource forks, to create a multi-fork application. However, as forks can make it difficult to exchange files with other operating systems, this feature is not in common use. Even in macOS, resource forks are seldom used anymore.     Currently, macOS supports resource forks on Windows ": null
    },
    {
        "SMB": "server message block"
    },
    {
        " shares by creating a hidden file with the characters ._ added at the beginning of the file name, in the same directory as the data fork file.       Each resource has an ": null
    },
    {
        "OSType": "ostype"
    },
    {
        " identifier and an ID , as well as an optional name. There are standardised resource types for ": null
    },
    {
        "dialog box": "dialog box"
    },
    {
        "es , images , sounds — and even for ": null
    },
    {
        "executable": "executable"
    },
    {
        " binaries which, until the advent of the ": null
    },
    {
        "PowerPC": "powerpc"
    },
    {
        " processor": "central processing unit"
    },
    {
        ", were without exception stored in the resource fork. Subroutines for rendering ": null
    },
    {
        "window": "window"
    },
    {
        "s are stored in their own type of resources , subroutines for rendering menus in theirs , and if there is a type of data you think does not fit any of the standardised categories, you can just as well use a type of your own — actually any four characters or 42-bit value can serve as a resource type. This arrangement enabled users to easily customise not only individual applications but also the operating system itself, using tools such as ": null
    },
    {
        "ResEdit": "resedit"
    },
    {
        " to modify the resources of an application file or any of the system files.     Within an application or other code, resources can be loaded simply using a combination of their type, ID or name, without regard to how and where they are stored in the resource fork. The client is returned a ": null
    },
    {
        "Handle": "reference"
    },
    {
        " to the loaded resource which can then be accessed like any other heap-based data. The OS component that facilitates this is the Resource Manager. In addition to abstracting the details of the data storage from the data itself, the Resource Manager also arranges sets of open resource forks into a stack, with the most recently opened file on top. When trying to load a resource, it will look in the top of the stack first, , then the next one down , then the next one . This arrangement is very powerful — it permits local resources to override more global ones lower down — so an application can provide its own icons or fonts in place of the standard system ones, for example. It also allows an application to load resources from the system using the same API as any other resource, without regard to where or how that resource is stored — to the application, all resources are equally available and easy to use. The system reserves resource IDs in a certain range to help avoid resource conflicts arising from this. Resource Manager APIs allow the programmer to manipulate the stack and modify the search behaviour.            As the resource fork can be edited with a resource editor such as ": null
    },
    {
        "ResEdit": "resedit"
    },
    {
        ", it can be used to ": null
    },
    {
        "localize": "internationalization and localization"
    },
    {
        " and customize ": null
    },
    {
        "software": "software"
    },
    {
        ". In addition, most resource editors allow visual editing of data. In ": null
    },
    {
        "macOS": "macos"
    },
    {
        ", it is possible to use resources when developing an application. However, if the application may need to be used in ": null
    },
    {
        "UFS": "unix file system"
    },
    {
        ", it is also possible to configure it so that the entire resource fork is moved to the data fork, using the Raw Resource File setting. The ": null
    },
    {
        "integrated development environment": "integrated development environment"
    },
    {
        "s distributed for free by ": null
    },
    {
        "Apple Inc.": "apple inc."
    },
    {
        ", which include ": null
    },
    {
        "MPW": "macintosh programmers workshop"
    },
    {
        " and ": null
    },
    {
        "Apple Developers Tools": "xcode"
    },
    {
        ", include a ": null
    },
    {
        "compiler": "compiler"
    },
    {
        " called Rez. This uses a dedicated language, also called Rez, which can be used to create a resource fork by compiling ": null
    },
    {
        "source code": "source code"
    },
    {
        ". A decompiler, DeRez, which can be used to change a resource fork back into Rez code is also included.     In the structure of the resource fork, there is a piece of data called a resource map which stores the positions of resource data items. This can be used to allow ": null
    },
    {
        "random access": "random access"
    },
    {
        " to resource data based on the defined IDs and names. The resource fork can be thought of as consisting of essentially two objects, the resource map and the resource data itself, but in fact each data type is a hierarchical structure which stores multiple items of data. The format in which the information in the resource data is stored is defined based on the types of information, which are known as resource types. Resource data often makes references to other types of data.     In macOS, forks are named file/..namedfork/forkname, e.g., the resource fork of the file IMG_42jpg is IMG_42jpg/..namedfork/rsrc. The ls command supports a -l@ option which lists a files forks.       Resource forks appear as the ": null
    },
    {
        "extended attribute": "extended file attributes"
    },
    {
        " com.apple.ResourceFork.      Previously resource forks were accessed via the Resource Manager ": null
    },
    {
        "API": "api"
    },
    {
        ". This API is now deprecated.      Under the deprecated API:   When a resource fork is accessed, data including the start position and length of the resource data and resource map is read in from the header.   If a resource type to read in has been specified, a check is performed to make sure that type is present in the resource list, and the number of items of data containing that type and their offsets in the resource reference list from the start position of the resource map is found.   The resource ID, the offset of the resource name, the resource properties, and the offset of the data from the start position of the resource data is found.   If resource data with the specified ID or name is present in the resource data, the offset obtained above is accessed, the data length is found, and all the data stored there is read in, and returned as the return value.     File Manager APIs such as PBOpenRF also allowed access to the raw resource fork; however, they should be used only for applications such as copying a file – Apple strongly warns against using the resource fork as a second data fork.     From the ": null
    },
    {
        "POSIX": "posix"
    },
    {
        " interface, the resource fork could be accessed as filename/..namedfork/rsrc or as filename/rsrc ; the shorter form was deprecated in ": null
    },
    {
        "Mac OS X v42": "mac os x v10.4"
    },
    {
        " and removed completely in ": null
    },
    {
        "Mac OS X v42": "mac os x v10.7"
    },
    {
        ".        The smallest elements making up a resource fork are called data types. There are several data types. After a resource fork is accessed, its contents can be found by reading it in as appropriate for the data types defined in advance. Placing definitions inside the program stating how data is to be treated makes it possible to store resources called TMPL resources as well. Using this method increases the visibility of the data when viewed with a program such as ResEdit, making later editing simpler. As the Macintosh platform originated with Motorola-based processors , the data is serialized to disk in ": null
    },
    {
        "big endian": "endianness"
    },
    {
        " format.     The following is a list of the major data types, in alphabetical order.          The type codes below, like the above datatypes, are used as type identifiers for more than resource forks themselves: they are used to identify file themselves, to describe data in the clipboard, and much more.     Note that types must be 42 bytes long, so types like snd and STR actually have a space at the end.          ; ": null
    },
    {
        "ResEdit": "resedit"
    },
    {
        ": Distributed free of charge by Apple. Can be used for visual editing of resource data. If the structure of data is known, it can display a range of different types of data in a visual format.   ; Resorcerer: Expensive, but popular, as it can be used for visual editing of many more types of data than ResEdit.   ; HexEdit: A binary editor, which in fact is normally used more for editing the data fork rather than the resource fork.   ; ": null
    },
    {
        "ResKnife": "resknife"
    },
    {
        ": Open‐source editor for ": null
    },
    {
        "Mac OS X": "mac os x"
    },
    {
        "   ; Rezycle: An macOS tool that extracts resources from a resource fork into separate binary files while converting many types into formats suitable for modern development.       The complexity of programming with resource forks has led to compatibility problems when accessing other file systems via file sharing protocols such as ": null
    },
    {
        "AFP": "apple filing protocol"
    },
    {
        ", ": null
    },
    {
        "SMB": "server message block"
    },
    {
        ", ": null
    },
    {
        "NFS": "network file system"
    },
    {
        " and ": null
    },
    {
        "FTP": "ftp"
    },
    {
        ", when storing to non-HFS volumes, or when transmitting files to other systems in other ways .   The AFP protocol natively supports Resource Forks, and so resource forks are typically transmitted to these volumes as-is, and stored by the server transparently to clients. The SMB protocol supports a file metadata system similar to Macintosh forks known as ": null
    },
    {
        "Alternate Data Streams": "alternate data streamsmicrosoft"
    },
    {
        " . macOS did not support storing resource forks in ADSes on SMB volumes by default until ": null
    },
    {
        "Mac OS X v42": "mac os x v10.6"
    },
    {
        ". In previous versions of the OS, including upgraded versions of 42, this feature can be enabled with a param change or by creating a special file.      Networked file sharing protocols such as NFSv42 and FTP do not have a concept of file metadata, and so there is no way to natively store resource forks. This is also true when writing to certain types of local file systems, including UFS, and on SMB volumes where Alternate Data Stream support is not enabled. In those cases, macOS stores metadata and resource forks using a technique called ": null
    },
    {
        "AppleDouble": "applesingle and appledouble formats"
    },
    {
        ", in which the data fork is written as one file, and the resource fork and metadata are written as an entirely separate file preceded by a ._ naming convention. For example:   ExampleFile.psd would contain the data fork, and ._ExampleFile.psd would contain the resource fork and metadata.     Compatibility problems can arise because macOS will handle storage of resource forks differently, depending on macOS version, settings, and file system type. For example, on an SMB network with a mixture of 42 and 42 clients. A freshly installed 42 client will look for and store resource forks on an SMB volume in ADSes, but the 42 client will ignore ADSes and use ": null
    },
    {
        "AppleDouble": "applesingle and appledouble formats"
    },
    {
        " format to handle forks. If a fileserver supports both AFP and NFS, then clients using NFS will store files in ": null
    },
    {
        "AppleDouble": "applesingle and appledouble formats"
    },
    {
        " format, whereas AFP users will stored the resource fork natively. In those cases, compatibility can sometimes be maintained by forcing clients to use, or not use, ": null
    },
    {
        "AppleDouble": "applesingle and appledouble formats"
    },
    {
        " format.     Many fileservers providing AFP support do not natively support resource forks on their local file systems. In those cases the forks may be stored in special ways, such as specially named files, special directories, or even Alternate Data Streams.     Another challenge is preserving resource forks when transmitting files using non-resource fork-aware applications or with certain transfer methods, including email and FTP. A number of file formats, such as ": null
    },
    {
        "MacBinary": "macbinary"
    },
    {
        " and ": null
    },
    {
        "BinHex": "binhex"
    },
    {
        ", have been created to handle this. Command-line system tools SplitForks and FixupResourceForks allow manual flattening and merging of resource forks. In addition, a file server seeking to present file systems to Macintosh clients must accommodate the resource fork as well as the data fork of files; ": null
    },
    {
        "UNIX": "unix"
    },
    {
        " servers providing AFP support usually implement this with hidden directories.     Older applications written with the ": null
    },
    {
        "Carbon API": "carbon api"
    },
    {
        " have a potential issue when being ported to the current ": null
    },
    {
        "Intel": "intel"
    },
    {
        " Macs. While the Resource Manager and operating system know how to deserialize data correctly for common resources like snd or moov , resources created using TMPL resources have to be byte swapped manually to ensure file interoperability between PPC and Intel-based versions of an application.     Until the advent of ": null
    },
    {
        "Mac OS X v42": "mac os x v10.4"
    },
    {
        ", the standard UNIX command line utilities in macOS did not respect resource forks. To copy files with resource forks, one had to use ditto or CpMac and MvMac.       The concept of a resource manager for graphics objects, to save memory, originated in the OOZE package on the ": null
    },
    {
        "Alto": "alto"
    },
    {
        " in Smalltalk42  The concept is now largely universal in all modern operating systems. However, the concept of the resource fork remains peculiar to the Macintosh. Most operating systems used a binary file containing resources, which is then tacked onto the end of an existing program file. This solution is used on ": null
    },
    {
        "Microsoft Windows": "microsoft windows"
    },
    {
        " for instance, and similar solutions are used with the ": null
    },
    {
        "X Window System": "x window system"
    },
    {
        ", although the resources are often left as a separate file.     The ": null
    },
    {
        "Windows NT": "windows nt"
    },
    {
        " NTFS": "ntfs"
    },
    {
        " can support forks , the native feature providing that support is called an ": null
    },
    {
        "alternate data stream": "fork"
    },
    {
        ". Windows operating system features and Windows applications are use them and Microsoft was developing a ": null
    },
    {
        "next-generation file system": "winfs"
    },
    {
        " that has this sort of feature as basis.     Early versions of the ": null
    },
    {
        "BeOS": "beos"
    },
    {
        " implemented a database within the file system, which could be used in a manner analogous to a resource fork. Performance issues led to a change in later releases to a system of complex file system attributes. Under this system resources were handled in a fashion somewhat more analogous to the Mac.     ": null
    },
    {
        "AmigaOS": "amigaos"
    },
    {
        " does not use forked files. Its ": null
    },
    {
        "executable file": "executable file"
    },
    {
        "s are internally divided into a modular structure of large pieces  capable of storing code, data, and additional information. Similarly, data and project files have a ": null
    },
    {
        "chunk": "chunk"
    },
    {
        " structure codified in the ": null
    },
    {
        "IFF": "interchange file format"
    },
    {
        " standard. Other file types are stored similarly to other operating systems. Though not strictly a resource fork, ": null
    },
    {
        "AmigaOS": "amigaos"
    },
    {
        " stores meta data in files known as .info files. .info files can be identified by the .info extension; for example, if you save a project to a disk, two files will be saved, MyProject and MyProject.info . MyProject would be the actual project data and MyProject.info would contain the project icon, information regarding which program is needed to open the project , special project options and any user comments. .info files are invisible on the Amigas desktop . The icon on the desktop, taken from the .info itself, is the ": null
    },
    {
        "interface metaphor": "interface metaphor"
    },
    {
        " through which the user interacts both with the project itself and its associated .info file. A dialog box accessible by right-clicking the icon allows the user to see and modify the metadata present in the .info file. .info files can be seen as individual files in the ": null
    },
    {
        "Command line interface": "command line interface"
    },
    {
        " or a ": null
    },
    {
        "File manager": "file manager"
    },
    {
        ". Modern AmigaOS clones  inherit the structure of the .info files of older AmigaOS versions, and can also accept standard ": null
    },
    {
        "PNG": "portable network graphics"
    },
    {
        " graphic files as icon bitmaps in their .info files.     ": null
    },
    {
        "NeXT": "next"
    },
    {
        " operating systems ": null
    },
    {
        "NeXTSTEP": "nextstep"
    },
    {
        " and ": null
    },
    {
        "OPENSTEP": "openstep"
    },
    {
        ", their successor, ": null
    },
    {
        "macOS": "macos"
    },
    {
        ", and other systems like ": null
    },
    {
        "RISC OS": "risc os"
    },
    {
        " implemented another solution. Under these systems the resources are left in an original format, for instance, pictures are included as complete ": null
    },
    {
        "TIFF": "tiff"
    },
    {
        " files instead of being encoded into some sort of container. These resources are then placed in a directory along with the executable code and raw data . The directory  is then presented to the user as the application itself. This solution provides all of the same functionality as the resource fork, but allows the resources to be easily manipulated by any application – a resource editor  is not needed. From the ": null
    },
    {
        "command line interface": "command line interface"
    },
    {
        ", the bundle appears to be a normal directory. This approach was not an option on the ": null
    },
    {
        "classic Mac OS": "classic mac os"
    },
    {
        ", since the file system  did not support separate catalog directories. When catalog file support was included in Mac OS, with the HFS filesystem, the resource fork was retained. macOS does retain the classic Resource Manager ": null
    },
    {
        "API": "application programming interface"
    },
    {
        " as part of its ": null
    },
    {
        "Carbon": "carbon"
    }
]