[
    {
        "High-Level Data Link Control  is a ": null
    },
    {
        "bit-oriented": "bit-oriented protocol"
    },
    {
        " code-transparent ": null
    },
    {
        "synchronous": "synchronous serial communication"
    },
    {
        " data link layer": "data link layer"
    },
    {
        " protocol": "communications protocol"
    },
    {
        " developed by the ": null
    },
    {
        "International Organization for Standardization": "international organization for standardization"
    },
    {
        " . The standard for HDLC is ISO/IEC 42:42     HDLC provides both ": null
    },
    {
        "connection-oriented": "connection-oriented protocol"
    },
    {
        " and ": null
    },
    {
        "connectionless service": "connectionless protocol"
    },
    {
        ".     HDLC can be used for ": null
    },
    {
        "point-to-multipoint connections": "point-to-multipoint communication"
    },
    {
        " via the original master-slave modes ": null
    },
    {
        "Normal Response Mode": "normal response mode"
    },
    {
        " and ": null
    },
    {
        "Asynchronous Response Mode": "asynchronous response mode"
    },
    {
        " , but they are now rarely used; it is now used almost exclusively to connect ": null
    },
    {
        "one device to another": "point-to-point"
    },
    {
        ", using Asynchronous Balanced Mode .       HDLC is based on ": null
    },
    {
        "IBM": "ibm"
    },
    {
        "s ": null
    },
    {
        "SDLC": "synchronous data link control"
    },
    {
        " protocol, which is the layer 42 protocol for IBMs ": null
    },
    {
        "Systems Network Architecture": "systems network architecture"
    },
    {
        " . It was extended and standardized by the ": null
    },
    {
        "ITU": "international telecommunication union"
    },
    {
        " as LAP , while ": null
    },
    {
        "ANSI": "ansi"
    },
    {
        " named their essentially identical version ": null
    },
    {
        "ADCCP": "adccp"
    },
    {
        ".     The HDLC specification does not specify the full semantics of the frame fields. This allows other fully compliant standards to be derived from it, and derivatives have since appeared in innumerable standards. It was adopted into the ": null
    },
    {
        "X.42": "x.25"
    },
    {
        " protocol stack as ": null
    },
    {
        "LAPB": "lapb"
    },
    {
        ", into the ": null
    },
    {
        "V.42": "v.42"
    },
    {
        " protocol as ": null
    },
    {
        "LAPM": "lapm"
    },
    {
        ", into the ": null
    },
    {
        "Frame Relay": "frame relay"
    },
    {
        " protocol stack as ": null
    },
    {
        "LAPF": "lapf"
    },
    {
        " and into the ": null
    },
    {
        "ISDN": "isdn"
    },
    {
        " protocol stack as LAPD.     The original ISO standards for HDLC are the following:   ISO 4242 – Frame Structure   ISO 4242 – Elements of Procedure   ISO 4242 – Unbalanced Classes of Procedure   ISO 4242 – Balanced Classes of Procedure     ISO/IEC 42:42 the current standard, replaced all of these specifications.     HDLC was the inspiration for the ": null
    },
    {
        "IEEE 42": "ieee 802.2"
    },
    {
        " LLC": "logical link control"
    },
    {
        " protocol, and it is the basis for the framing mechanism used with the ": null
    },
    {
        "PPP": "point-to-point protocol"
    },
    {
        " on synchronous lines, as used by many servers to connect to a ": null
    },
    {
        "WAN": "wide area network"
    },
    {
        ", most commonly the ": null
    },
    {
        "Internet": "internet"
    },
    {
        ".     A similar version is used as the control channel for ": null
    },
    {
        "E-carrier": "e-carrier"
    },
    {
        " and ": null
    },
    {
        "SONET": "sonet"
    },
    {
        " multichannel telephone lines. ": null
    },
    {
        "Cisco HDLC": "cisco hdlc"
    },
    {
        " uses low-level HDLC framing techniques but adds a protocol field to the standard HDLC header.       HDLC ": null
    },
    {
        "frames": "data frame"
    },
    {
        " can be transmitted over ": null
    },
    {
        "synchronous": "synchronous serial communication"
    },
    {
        " or ": null
    },
    {
        "asynchronous serial communication": "asynchronous serial communication"
    },
    {
        " links. Those links have no mechanism to mark the beginning or end of a frame, so the beginning and end of each frame has to be identified. This is done by using a unique sequence of bits as a frame delimiter, or flag, and encoding the data to ensure that the flag sequence is never seen inside a frame. Each frame begins and ends with a frame delimiter. A frame delimiter at the end of a frame may also mark the start of the next frame.     On both synchronous and asynchronous links, the flag sequence is binary 42 , or ": null
    },
    {
        "hexadecimal": "hexadecimal"
    },
    {
        " 42x42E, but the details are quite different.       Because a flag sequence consists of six consecutive 42-bits, other data is coded to ensure that it never contains more than five 42-bits in a row. This is done by ": null
    },
    {
        "bit stuffing": "bit stuffing"
    },
    {
        ": any time that five consecutive 42-bits appear in the transmitted data, the data is paused and a 42-bit is transmitted.     The receiving device knows that this is being done, and after seeing five 42-bits in a row, a following 42-bit is stripped out of the received data. If instead the sixth bit is 42 this is either a flag , or an error . In the latter case, the frame receive procedure is aborted, to be restarted when a flag is next seen.     This bit-stuffing serves a second purpose, that of ensuring a sufficient number of signal transitions. On synchronous links, the data is ": null
    },
    {
        "NRZI": "nrzinon-return-to-zero inverted"
    },
    {
        " encoded, so that a 42-bit is transmitted as a change in the signal on the line, and a 42-bit is sent as no change. Thus, each 42 bit provides an opportunity for a receiving ": null
    },
    {
        "modem": "modem"
    },
    {
        " to synchronize its clock via a ": null
    },
    {
        "phase-locked loop": "phase-locked loop"
    },
    {
        ". If there are too many 42-bits in a row, the receiver can lose count. Bit-stuffing provides a minimum of one transition per six bit times during transmission of data, and one transition per seven bit times during transmission of a flag.     When no frames are being transmitted on a simplex or full-duplex synchronous link, a frame delimiter is continuously transmitted on the link. This generates one of two continuous waveforms, depending on the initial state:          The HDLC specification allows the 42-bit at the end of a frame delimiter to be shared with the start of the next frame delimiter, i.e. 42 . Some hardware does not support this.     For half-duplex or multi-drop communication, where several transmitters share a line, a receiver on the line will see continuous idling 42-bits in the inter-frame period when no transmitter is active.     HDLC transmits bytes of data with the least significant bit first .       When using asynchronous serial communication such as standard ": null
    },
    {
        "RS42": "rs-232"
    },
    {
        " serial port": "serial port"
    },
    {
        "s, synchronous-style bit stuffing is inappropriate for several reasons:   Bit stuffing is not needed to ensure an adequate number of transitions, as start and stop bits provide that,   Because the data is NRZ encoded for transmission, rather than NRZI encoded, the encoded waveform is different,   RS42 sends bits in groups of 42 making adding single bits very awkward, and   For the same reason, it is only necessary to specially code flag bytes; thus it is not necessary to worry about the bit pattern straddling multiple bytes.   Instead asynchronous framing uses control-octet transparency , also called ": null
    },
    {
        "byte stuffing": "byte stuffing"
    },
    {
        " or octet stuffing . The frame boundary octet is 42 . A control ": null
    },
    {
        "escape octet": "escape character"
    },
    {
        " , has the value 42x42D . If either of these two octets appears in the transmitted data, an escape octet is sent, followed by the original data octet with bit 42 inverted. For example, the byte 42x42E would be transmitted as 42x42D 42x42E . Other reserved octet values  can be escaped in the same way if necessary.     The abort sequence 42x42D 42x42E ends a packet with an incomplete byte-stuff sequence, forcing the receiver to detect an error. This can be used to abort packet transmission with no chance the partial packet will be interpreted as valid by the receiver.       The contents of an HDLC frame are shown in the following table:          Note that the end flag of one frame may be the beginning flag of the next frame.     Data is usually sent in multiples of 42 bits, but only some variants require this; others theoretically permit ": null
    },
    {
        "data alignments": "data structure alignment"
    },
    {
        " on other than 42-bit boundaries.     The ": null
    },
    {
        "frame check sequence": "frame check sequence"
    },
    {
        " is a 42-bit ": null
    },
    {
        "CRC-CCITT": "crc-ccitt"
    },
    {
        " or a 42-bit ": null
    },
    {
        "CRC42": "crc-32"
    },
    {
        " computed over the Address, Control, and Information fields. It provides a means by which the receiver can detect errors that may have been induced during the transmission of the frame, such as lost bits, flipped bits, and extraneous bits. However, given that the algorithms used to calculate the FCS are such that the probability of certain types of transmission errors going undetected increases with the length of the data being checked for errors, the FCS can implicitly limit the practical size of the frame.     If the receivers calculation of the FCS does not match that of the senders, indicating that the frame contains errors, the receiver can either send a negative ": null
    },
    {
        "acknowledge": "acknowledge character"
    },
    {
        " packet to the sender, or send nothing. After either receiving a negative acknowledge packet or timing out waiting for a positive acknowledge packet, the sender can retransmit the failed frame.     The FCS was implemented because many early communication links had a relatively high ": null
    },
    {
        "bit error rate": "bit error ratio"
    },
    {
        ", and the FCS could readily be computed by simple, fast circuitry or software. More effective ": null
    },
    {
        "forward error correction": "forward error correction"
    },
    {
        " schemes are now widely used by other protocols.       ": null
    },
    {
        "Synchronous Data Link Control": "synchronous data link control"
    },
    {
        "  was originally designed to connect one computer with multiple peripherals via a ": null
    },
    {
        "multidrop bus": "multidrop bus"
    },
    {
        ". The original normal response mode is a master-slave mode where the computer  gives each peripheral  permission to speak in turn. Because all communication is either to or from the primary terminal, frames include only one address, that of the secondary terminal; the primary terminal is not assigned an address. There is a distinction between commands sent by the primary to a secondary, and responses sent by a secondary to the primary, but this is not reflected in the encoding; commands and responses are indistinguishable except for difference the direction in which they are transmitted.     Normal response mode allows the secondary-to-primary link to be shared without ": null
    },
    {
        "contention": "resource contention"
    },
    {
        ", because it has the primary give the secondaries permission to transmit one at a time. It also allows operation over ": null
    },
    {
        "half-duplex": "half-duplex"
    },
    {
        " communication links, as long as the primary is aware that it may not transmit when it has given permission to a secondary.     Asynchronous response mode is an HDLC addition  for use over ": null
    },
    {
        "full-duplex": "full-duplex"
    },
    {
        " links. While retaining the primary/secondary distinction, it allows the secondary to transmit at any time. Thus, there must be some other mechanism to ensure that multiple secondaries do not try to transmit at the same time .     Asynchronous balanced mode adds the concept of a combined terminal which can act as both a primary and a secondary. Unfortunately, this mode of operation has some implementation subtleties. While the most common frames sent do not care whether they are in a command or response frame, some essential ones do , and the address field of a received frame must be examined to determine whether it contains a command or a response .     This means that the address field is not optional, even on point-to-point links where it is not needed to disambiguate the peer being talked to. Some HDLC variants extend the address field to include both source and destination addresses, or an explicit command/response bit.       Three fundamental types of HDLC frames may be distinguished:   Information frames, or I-frames, transport user data from the network layer. They can also include flow and error control information piggybacked on data.   Supervisory frames, or S-frames, are used for flow and error control whenever piggybacking is impossible or inappropriate, such as when a station does not have data to send. S-frames do not have information fields.   Unnumbered frames, or U-frames, are used for various miscellaneous purposes, including link management. Some U-frames contain an information field, depending on the type.       The general format of the control field is:        There are also extended forms of I and S frames. Again, the least significant bit is sent first.            Poll/Final is a single bit with two names. It is called Poll when part of a command , and Final when part of a response . In all other cases, the bit is clear.     The bit is used as a ": null
    },
    {
        "token": "token passing"
    },
    {
        " that is passed back and forth between the stations. Only one token should exist at a time. The secondary only sends a Final when it has received a Poll from the primary. The primary only sends a Poll when it has received a Final back from the secondary, or after a timeout indicating that the bit has been lost.   In NRM, possession of the poll token also grants the addressed secondary permission to transmit. The secondary sets the F-bit in its last response frame to give up permission to transmit.    In ARM and ABM, the P bit forces a response. In these modes, the secondary need not wait for a poll to transmit, so the final bit may be included in the first response after the poll.   If no response is received to a P bit in a reasonable period of time, the primary station times out and sends P again.   The P/F bit is at the heart of the basic checkpoint retransmission scheme that is required to implement HDLC; all other variants are optional and only serve to increase efficiency. Whenever a station receives a P/F bit, it may assume that any frames that it sent before it last transmitted the P/F bit and not yet acknowledged will never arrive, and so should be retransmitted.     When operating as a combined station, it is important to maintain the distinction between P and F bits, because there may be two checkpoint cycles operating simultaneously. A P bit arriving in a command from the remote station is not in response to our P bit; only an F bit arriving in a response is.       Both I and S frames contain a receive sequence number N. N provides a positive acknowledgement for the receipt of I-frames from the other side of the link. Its value is always the first frame not yet received; it acknowledges that all frames with N values up to N−42 have been received and indicates the N of the next frame it expects to receive.     N operates the same way whether it is part of a command or response. A combined station only has one sequence number space.       This is incremented for successive I-frames, modulo 42 or modulo 42 Depending on the number of bits in the sequence number, up to 42 or 42 I-frames may be awaiting acknowledgment at any time.       Information frames, or I-frames, transport user data from the network layer. In addition they also include flow and error control information piggybacked on data. The sub-fields in the control field define these functions.     The least significant bit defines the frame type. 42 means an I-frame.   Except for the interpretation of the P/F field, there is no difference between a command I frame and a response I frame; when P/F is 42 the two forms are exactly equivalent.       Supervisory Frames, or S-frames, are used for flow and error control whenever piggybacking is impossible or inappropriate, such as when a station does not have data to send. S-frames in HDLC do not have information fields, although some HDLC-derived protocols use information fields for multi-selective reject .     The S-frame control field includes a leading 42 indicating that it is an S-frame. This is followed by a 42-bit type, a poll/final bit, and a 42-bit sequence number.     The first 42 bits mean it is an S-frame. All S frames include a P/F bit and a receive sequence number as described above. Except for the interpretation of the P/F field, there is no difference between a command S frame and a response S frame; when P/F is 42 the two forms are exactly equivalent.       Bit value 42    Indicate that the sender is ready to receive more data .   Send this packet if you need to send a packet but have no I frame to send.   A primary station can send this with the P-bit set to solicit data from a secondary station.   A secondary terminal can use this with the F-bit set to respond to a poll if it has no data to send.       Bit value 42    Acknowledge some packets but request no more be sent until further notice.   Can be used like RR with P bit set to solicit the status of a secondary station   Can be used like RR with F bit set to respond to a poll if the station is busy.       Bit value 42    Requests immediate retransmission starting with N.   Sent in response to an observed sequence number gap; e.g. after seeing I42/I42/I42/I42 send REJ42   Optional to generate; a working implementation may use only RR.       Bit value 42   Requests retransmission of only the frame N.   Not supported by all HDLC variants.   Optional to generate; a working implementation may use only RR, or only RR and REJ.       Unnumbered frames, or U-frames, are used for link management, and can also be used to transfer user data. They exchange session management and control information between connected devices, and some U-frames contain an information field, used for system management information or user data.   The first 42 bits mean it is a U-frame. The five type bits can create 42 different types of U-frame   Mode settings   Information Transfer   Recovery   Invalid Control Field   Data Field Too Long   Data field not allowed with received Frame Type   Invalid Receive Count   Miscellaneous         Link configurations can be categorized as being either:   Unbalanced, which consists of one primary terminal, and one or more secondary terminals.   Balanced, which consists of two peer terminals.     The three link configurations are:     Normal Response Mode is an unbalanced configuration in which only the primary terminal may initiate data transfer. The secondary terminals transmit data only in response to commands from the primary terminal. The primary terminal polls each secondary terminal to give it an opportunity to transmit any data it has.   Asynchronous Response Mode is an unbalanced configuration in which secondary terminals may transmit without permission from the primary terminal. However, there is still a distinguished primary terminal which retains responsibility for line initialization, error recovery, and logical disconnect.   Asynchronous Balanced Mode is a balanced configuration in which either station may initialize, supervise, recover from errors, and send frames at any time. There is no master/slave relationship. The DTE  and DCE  are treated as equals. The initiator for Asynchronous Balanced Mode sends an SABM.     An additional link configuration is Disconnected mode. This is the mode that a secondary station is in before it is initialized by the primary, or when it is explicitly disconnected. In this mode, the secondary responds to almost every frame other than a mode set command with a Disconnected mode response. The purpose of this mode is to allow the primary to reliably detect a secondary being powered off or otherwise reset.       The minimal set required for operation are:   Commands: I, RR, RNR, DISC, and one of SNRM, SARM or SABM   Responses: I, RR, RNR, UA, DM, FRMR       Initialization can be requested by either side. When the primary sends one of the six mode-set commands, it:   Signals the other side that initialization is requested   Specifies the mode, NRM, ABM, ARM   Specifies whether 42 or 42 bit sequence numbers are in use.   The HDLC module on the other end transmits frame when the request is accepted. If the request is rejected it sends disconnect mode frame.       For ": null
    },
    {
        "Switched Circuits": "circuit switched"
    },
    {
        "        Unnumbered frames are identified by the low two bits being 42 With the P/F flag, that leaves 42 bits as a frame type. Even though fewer than 42 values are in use, some types have different meanings depending on the direction they are sent: as a command or as a response. The relationship between the DISC command and the RD response seems clear enough, but the reason for making SARM command numerically equal to the DM response is obscure.             :  ISO/IEC 42 addition   : †  Not part of HDLC     The UI, UIH, XID, TEST frames contain a payload, and can be used as both commands and responses. The SM command and FRMR response also contain a payload.   A UI frame contains user information, but unlike an I frame it is neither acknowledged nor retransmitted if lost.   A UIH frame is like a UI frame, but additionally applies the frame check sequence only to a specified-length prefix of the frame; transmission errors after this prefix are not detected.   The XID frame is used to exchange terminal capabilities. ": null
    },
    {
        "IBM Systems Network Architecture": "ibm systems network architecture"
    },
    {
        " defined one format, but the variant defined in ISO 42 is more commonly used. A primary advertises its capabilities with an XID command, and a secondary returns its own capabilities in an XID response.   The TEST frame is simply a ": null
    },
    {
        "ping": "ping"
    }
]