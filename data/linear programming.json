[
    {
        "        Linear programming  is a method to achieve the best outcome in a ": null
    },
    {
        "mathematical model": "mathematical model"
    },
    {
        " whose requirements are represented by ": null
    },
    {
        "linear relationships": "linear functionas a polynomial function"
    },
    {
        ". Linear programming is a special case of mathematical programming .     More formally, linear programming is a technique for the ": null
    },
    {
        "optimization": "mathematical optimization"
    },
    {
        " of a ": null
    },
    {
        "linear": "linear"
    },
    {
        " objective function": "objective function"
    },
    {
        ", subject to ": null
    },
    {
        "linear equality": "linear equality"
    },
    {
        " and ": null
    },
    {
        "linear inequality": "linear inequality"
    },
    {
        " constraints": "constraint"
    },
    {
        ". Its ": null
    },
    {
        "feasible region": "feasible region"
    },
    {
        " is a ": null
    },
    {
        "convex polytope": "convex polytope"
    },
    {
        ", which is a set defined as the ": null
    },
    {
        "intersection": "intersection"
    },
    {
        " of finitely many ": null
    },
    {
        "half spaces": "half-space"
    },
    {
        ", each of which is defined by a linear inequality  . Its objective function is a ": null
    },
    {
        "real": "real number"
    },
    {
        "-valued ": null
    },
    {
        "affine function": "affine function"
    },
    {
        " defined on this polyhedron. A linear programming ": null
    },
    {
        "algorithm": "algorithm"
    },
    {
        " finds a point in the ": null
    },
    {
        "polytope": "polytope"
    },
    {
        " where this function has the smallest value if such a point exists.     Linear programs are problems that can be expressed in ": null
    },
    {
        "canonical form": "canonical form"
    },
    {
        " as   : \\begin   & \\text & & \\mathbf^\\mathrm \\mathbf\\\\   & \\text & & A \\mathbf \\leq \\mathbf \\\\   & \\text & & \\mathbf \\ge \\mathbf   \\end   where x represents the vector of variables , c and b are ": null
    },
    {
        "vectors": "vector space"
    },
    {
        " of coefficients, A is a ": null
    },
    {
        "matrix": "matrix"
    },
    {
        " of coefficients, and ^\\mathrm is the ": null
    },
    {
        "matrix transpose": "matrix transpose"
    },
    {
        ". The expression to be maximized or minimized is called the ": null
    },
    {
        "objective function": "objective function"
    },
    {
        " . The inequalities Ax  ≤  b and x ≥ 42 are the constraints which specify a ": null
    },
    {
        "convex polytope": "convex polytope"
    },
    {
        " over which the objective function is to be optimized. In this context, two vectors are ": null
    },
    {
        "comparable": "comparability"
    },
    {
        " when they have the same dimensions. If every entry in the first is less-than or equal-to the corresponding entry in the second, then it can be said that the first vector is less-than or equal-to the second vector.     Linear programming can be applied to various fields of study. It is widely used in mathematics, and to a lesser extent in business, ": null
    },
    {
        "economics": "economics"
    },
    {
        ", and for some engineering problems. Industries that use linear programming models include transportation, energy, telecommunications, and manufacturing. It has proven useful in modeling diverse types of problems in ": null
    },
    {
        "planning": "automated planning and scheduling"
    },
    {
        ", ": null
    },
    {
        "routing": "routing"
    },
    {
        ", ": null
    },
    {
        "scheduling": "scheduling"
    },
    {
        ", ": null
    },
    {
        "assignment": "assignment problem"
    },
    {
        ", and design.               The problem of solving a system of linear inequalities dates back at least as far as ": null
    },
    {
        "Fourier": "joseph fourier"
    },
    {
        ", who in 42 published a method for solving them,  and after whom the method of ": null
    },
    {
        "Fourier–Motzkin elimination": "fourier–motzkin elimination"
    },
    {
        " is named.     In 42 a linear programming formulation of a problem that is equivalent to the general linear programming problem was given by the ": null
    },
    {
        "Soviet": "soviet union"
    },
    {
        " economist": "economist"
    },
    {
        " Leonid Kantorovich": "leonid kantorovich"
    },
    {
        ", who also proposed a method for solving it.  It is a way he developed, during ": null
    },
    {
        "World War II": "world war ii"
    },
    {
        ", to plan expenditures and returns in order to reduce costs of the army and to increase losses imposed on the enemy. Kantorovichs work was initially neglected in the ": null
    },
    {
        "USSR": "ussr"
    },
    {
        ".  About the same time as Kantorovich, the Dutch-American economist ": null
    },
    {
        "T. C. Koopmans": "tjalling koopmans"
    },
    {
        " formulated classical economic problems as linear programs. Kantorovich and Koopmans later shared the 42 ": null
    },
    {
        "Nobel prize in economics": "nobel prize in economics"
    },
    {
        ". In 42 ": null
    },
    {
        "Frank Lauren Hitchcock": "frank lauren hitchcock"
    },
    {
        " also formulated transportation problems as linear programs and gave a solution very similar to the later ": null
    },
    {
        "simplex method": "simplex method"
    },
    {
        ". Hitchcock had died in 42 and the Nobel prize is not awarded posthumously.     During 42–42 ": null
    },
    {
        "George B. Dantzig": "george dantzig"
    },
    {
        " independently developed general linear programming formulation to use for planning problems in the US Air Force  . In 42 Dantzig also invented the ": null
    },
    {
        "simplex method": "simplex algorithm"
    },
    {
        " that for the first time efficiently tackled the linear programming problem in most cases . When Dantzig arranged a meeting with ": null
    },
    {
        "John von Neumann": "john von neumann"
    },
    {
        " to discuss his simplex method, Neumann immediately conjectured the theory of ": null
    },
    {
        "duality": "duality"
    },
    {
        " by realizing that the problem he had been working in ": null
    },
    {
        "game theory": "game theory"
    },
    {
        " was equivalent . Dantzig provided formal proof in an unpublished report A Theorem on Linear Inequalities on January 42 42 In the post-war years, many industries applied it in their daily planning.     Dantzigs original example was to find the best assignment of 42 people to 42 jobs. The computing power required to test all the permutations to select the best assignment is vast; the number of possible configurations exceeds the ": null
    },
    {
        "number of particles": "abundance of the chemical elements"
    },
    {
        " in the ": null
    },
    {
        "observable universe": "observable universe"
    },
    {
        ". However, it takes only a moment to find the optimum solution by posing the problem as a linear program and applying the ": null
    },
    {
        "simplex algorithm": "simplex algorithm"
    },
    {
        ". The theory behind linear programming drastically reduces the number of possible solutions that must be checked.     The linear programming problem was first shown to be solvable in polynomial time by ": null
    },
    {
        "Leonid Khachiyan": "leonid khachiyan"
    },
    {
        " in 42  but a larger theoretical and practical breakthrough in the field came in 42 when ": null
    },
    {
        "Narendra Karmarkar": "narendra karmarkar"
    },
    {
        " introduced a new ": null
    },
    {
        "interior-point method": "interior-point method"
    },
    {
        " for solving linear-programming problems.        Linear programming is a widely used field of optimization for several reasons. Many practical problems in ": null
    },
    {
        "operations research": "operations research"
    },
    {
        " can be expressed as linear programming problems. Certain special cases of linear programming, such as  network flow  problems and ": null
    },
    {
        "multicommodity flow problems": "multi-commodity flow problem"
    },
    {
        " are considered important enough to have generated much research on specialized algorithms for their solution. A number of algorithms for other types of optimization problems work by solving LP problems as sub-problems. Historically, ideas from linear programming have inspired many of the central concepts of optimization theory, such as duality, decomposition, and the importance of convexity and its generalizations. Likewise, linear programming was heavily used in the early formation of ": null
    },
    {
        "microeconomics": "microeconomics"
    },
    {
        " and it is currently utilized in company management, such as planning, production, transportation, technology and other issues. Although the modern management issues are ever-changing, most companies would like to ": null
    },
    {
        "maximize profits": "profit maximization"
    },
    {
        " and minimize costs with limited resources. Therefore, many issues can be characterized as linear programming problems.       Standard form is the usual and most intuitive form of describing a linear programming problem. It consists of the following three parts:   A linear function to be maximized   : e.g. f c_42 x_42 + c_42 x_42   Problem constraints of the following form   : e.g.   :: \\begin   a_ x_42 + a_ x_42 & \\leq b_42 \\\\   a_ x_42 + a_ x_42 & \\leq b_42 \\\\   a_ x_42 + a_ x_42 & \\leq b_42 \\\\   \\end   Non-negative variables   : e.g.   :: \\begin   x_42 \\geq 42 \\\\   x_42 \\geq 42   \\end     The problem is usually expressed in  matrix form, and then becomes:   : \\max \\     Other forms, such as minimization problems, problems with constraints on alternative forms, as well as problems involving negative ": null
    },
    {
        "variables": "variable"
    },
    {
        " can always be rewritten into an equivalent problem in standard form.       Suppose that a farmer has a piece of farm land, say L km 42 , to be planted with either wheat or barley or some combination of the two. The farmer has a limited amount of fertilizer, F kilograms, and pesticide, P kilograms. Every square kilometer of wheat requires F 42 kilograms of fertilizer and P 42 kilograms of pesticide, while every square kilometer of barley requires F 42 kilograms of fertilizer and P 42 kilograms of pesticide. Let S 42 be the selling price of wheat per square kilometer, and S 42 be the selling price of barley. If we denote the area of land planted with wheat and barley by x 42 and x 42 respectively, then profit can be maximized by choosing optimal values for x 42 and x 42 . This problem can be expressed with the following linear programming problem in the standard form:        In matrix form this becomes:   : maximize \\begin S_42 & S_42 \\end \\begin x_42 \\\\ x_42 \\end   : subject to \\begin 42 & 42 \\\\ F_42 & F_42 \\\\ P_42 & P_42 \\end \\begin x_42 \\\\ x_42 \\end \\le \\begin L \\\\ F \\\\ P \\end, \\, \\begin x_42 \\\\ x_42 \\end \\ge \\begin 42 \\\\ 42 \\end.       Linear programming problems can be converted into an augmented form in order to apply the common form of the ": null
    },
    {
        "simplex algorithm": "simplex algorithm"
    },
    {
        ". This form introduces non-negative  slack variable s to replace inequalities with equalities in the constraints. The problems can then be written in the following ": null
    },
    {
        "block matrix": "block matrix"
    },
    {
        " form:   : Maximize z :   :   \\begin   42 & -\\mathbf^T & 42 \\\\   42 & \\mathbf & \\mathbf   \\end   \\begin   z \\\\ \\mathbf \\\\ \\mathbf   \\end   \\begin   42 \\\\ \\mathbf   \\end     : \\mathbf \\ge 42 \\mathbf \\ge 42   where \\mathbf are the newly introduced slack variables, \\mathbf are the decision variables, and z is the variable to be maximized.       The example above is converted into the following augmented form:   :   where x_42 x_42 x_42 are slack variables, representing in this example the unused area, the amount of unused fertilizer, and the amount of unused pesticide.     In matrix form this becomes:   : Maximize z :   :   \\begin   42 & -S_42 & -S_42 & 42 & 42 & 42 \\\\   42 & 42 & 42 & 42 & 42 & 42 \\\\   42 & F_42 & F_42 & 42 & 42 & 42 \\\\   42 & P_42 & P_42 & 42 & 42 & 42 \\\\   \\end   \\begin   z \\\\ x_42 \\\\ x_42 \\\\ x_42 \\\\ x_42 \\\\ x_42   \\end   \\begin   42 \\\\ L \\\\ F \\\\ P   \\end, \\,   \\begin   x_42 \\\\ x_42 \\\\ x_42 \\\\ x_42 \\\\ x_42   \\end \\ge 42            Every linear programming problem, referred to as a primal problem, can be converted into a ": null
    },
    {
        "dual problem": "dual problem"
    },
    {
        ", which provides an upper bound to the optimal value of the primal problem. In matrix form, we can express the primal problem as:     : Maximize c T x subject to Ax ≤ b, x ≥ 42;   :: with the corresponding symmetric dual problem,   : Minimize b T y subject to A T y ≥ c, y ≥ 42     An alternative primal formulation is:     : Maximize c T x subject to Ax ≤ b;   :: with the corresponding asymmetric dual problem,   : Minimize b T y subject to A T y c, y ≥ 42     There are two ideas fundamental to duality theory. One is the fact that the dual of a dual linear program is the original primal linear program. Additionally, every feasible solution for a linear program gives a bound on the optimal value of the objective function of its dual. The ": null
    },
    {
        "weak duality": "weak duality"
    },
    {
        " theorem states that the objective function value of the dual at any feasible solution is always greater than or equal to the objective function value of the primal at any feasible solution. The ": null
    },
    {
        "strong duality": "strong duality"
    },
    {
        " theorem states that if the primal has an optimal solution, x , then the dual also has an optimal solution, y , and c T x b T y .     A linear program can also be unbounded or infeasible. Duality theory tells us that if the primal is unbounded then the dual is infeasible by the weak duality theorem. Likewise, if the dual is unbounded, then the primal must be infeasible. However, it is possible for both the dual and the primal to be infeasible. See ": null
    },
    {
        "dual linear program": "dual linear program"
    },
    {
        " for details and several more examples.                   A ": null
    },
    {
        "covering LP": "covering problem"
    },
    {
        " is a linear program of the form:   : Minimize: b T y ,   : subject to: A T y ≥ c, y ≥ 42 ,   such that the matrix A and the vectors b and c are non-negative.     The dual of a covering LP is a ": null
    },
    {
        "packing LP": "packing problem"
    },
    {
        ", a linear program of the form:   : Maximize: c T x ,   : subject to: Ax ≤ b, x ≥ 42 ,   such that the matrix A and the vectors b and c are non-negative.       Covering and packing LPs commonly arise as a ": null
    },
    {
        "linear programming relaxation": "linear programming relaxation"
    },
    {
        " of a combinatorial problem and are important in the study of ": null
    },
    {
        "approximation algorithms": "approximation algorithms"
    },
    {
        ".  For example, the LP relaxations of the ": null
    },
    {
        "set packing problem": "set packing"
    },
    {
        ", the ": null
    },
    {
        "independent set problem": "independent set problem"
    },
    {
        ", and the ": null
    },
    {
        "matching problem": "matching"
    },
    {
        " are packing LPs. The LP relaxations of the ": null
    },
    {
        "set cover problem": "set cover problem"
    },
    {
        ", the ": null
    },
    {
        "vertex cover problem": "vertex cover problem"
    },
    {
        ", and the ": null
    },
    {
        "dominating set problem": "dominating set problem"
    },
    {
        " are also covering LPs.     Finding a ": null
    },
    {
        "fractional coloring": "fractional coloring"
    },
    {
        " of a ": null
    },
    {
        "graph": "graph"
    },
    {
        " is another example of a covering LP. In this case, there is one constraint for each vertex of the graph and one variable for each ": null
    },
    {
        "independent set": "independent set"
    },
    {
        " of the graph.       It is possible to obtain an optimal solution to the dual when only an optimal solution to the primal is known using the complementary slackness theorem. The theorem states:     Suppose that x     is primal feasible and that y     is dual feasible. Let  denote the corresponding primal slack variables, and let  denote the corresponding dual slack variables. Then x and y are optimal for their respective problems if and only if   x j z j    42 for j    42  42  ...  ,  n, and   w i y i    42 for i    42  42  ...  ,  m.     So if the i-th slack variable of the primal is not zero, then the i-th variable of the dual is equal to zero. Likewise, if the j-th slack variable of the dual is not zero, then the j-th variable of the primal is equal to zero.     This necessary condition for optimality conveys a fairly simple economic principle. In standard form , if there is slack in a constrained primal resource , then additional quantities of that resource must have no value. Likewise, if there is slack in the dual price non-negativity constraint requirement, i.e., the price is not zero, then there must be scarce supplies .           Geometrically, the linear constraints define the ": null
    },
    {
        "feasible region": "feasible region"
    },
    {
        ", which is a ": null
    },
    {
        "convex": "convex set"
    },
    {
        " polyhedron": "polyhedron"
    },
    {
        ". A ": null
    },
    {
        "linear function": "linear functional"
    },
    {
        " is a ": null
    },
    {
        "convex function": "convex function"
    },
    {
        ", which implies that every ": null
    },
    {
        "local minimum": "local minimum"
    },
    {
        " is a ": null
    },
    {
        "global minimum": "global minimum"
    },
    {
        "; similarly, a linear function is a ": null
    },
    {
        "concave function": "concave function"
    },
    {
        ", which implies that every ": null
    },
    {
        "local maximum": "local maximum"
    },
    {
        " is a ": null
    },
    {
        "global maximum": "global maximum"
    },
    {
        ".     An optimal solution need not exist, for two reasons. First, if the constraints are inconsistent, then no feasible solution exists: For instance, the constraints x  ≥  42 and x  ≤  42 cannot be satisfied jointly; in this case, we say that the LP is infeasible. Second, when the ": null
    },
    {
        "polytope": "polytope"
    },
    {
        " is unbounded in the direction of the gradient of the objective function , then no optimal value is attained because it is always possible to do better than any finite value of the objective function.       Otherwise, if a feasible solution exists and if the constraint set is bounded, then the optimum value is always attained on the boundary of the constraint set, by the  maximum principle  for  convex function s  since linear functions are both convex and concave. However, some problems have distinct optimal solutions; for example, the problem of finding a feasible solution to a system of linear inequalities is a linear programming problem in which the objective function is the zero function . For this feasibility problem with the zero-function for its objective-function, if there are two distinct solutions, then every convex combination of the solutions is a solution.     The vertices of the polytope are also called basic feasible solutions. The reason for this choice of name is as follows. Let d denote the number of variables. Then the fundamental theorem of linear inequalities implies that for every vertex x of the LP feasible region, there exists a set of d inequality constraints from the LP such that, when we treat those d constraints as equalities, the unique solution is x . Thereby we can study these vertices by means of looking at certain subsets of the set of all constraints , rather than the continuum of LP solutions. This principle underlies the ": null
    },
    {
        "simplex algorithm": "simplex algorithm"
    },
    {
        " for solving linear programs.                         The ": null
    },
    {
        "simplex algorithm": "simplex algorithm"
    },
    {
        ", developed by ": null
    },
    {
        "George Dantzig": "george dantzig"
    },
    {
        " in 42 solves LP problems by constructing a feasible solution at a vertex of the ": null
    },
    {
        "polytope": "polytope"
    },
    {
        " and then walking along a path on the edges of the polytope to vertices with non-decreasing values of the objective function until an optimum is reached for sure. In many practical problems, ": null
    },
    {
        "stalling": "simplex algorithmdegeneracy: stalling and cycling"
    },
    {
        " occurs: many pivots are made with no increase in the objective function.   In rare practical problems, the usual versions of the simplex algorithm may actually cycle . To avoid cycles, researchers developed new pivoting rules.        In practice, the simplex ": null
    },
    {
        "algorithm": "algorithm"
    },
    {
        " is quite efficient and can be guaranteed to find the global optimum if certain precautions against cycling are taken. The simplex algorithm has been proved to solve random problems efficiently, i.e. in a cubic number of steps,  which is similar to its behavior on practical problems.      However, the simplex algorithm has poor worst-case behavior: Klee and Minty constructed a family of linear programming problems for which the simplex method takes a number of steps exponential in the problem size. In fact, for some time it was not known whether the linear programming problem was solvable in ": null
    },
    {
        "polynomial time": "polynomial time"
    },
    {
        ", i.e. of ": null
    },
    {
        "complexity class P": "p"
    },
    {
        ".       Like the simplex algorithm of Dantzig, the ": null
    },
    {
        "criss-cross algorithm": "criss-cross algorithm"
    },
    {
        " is a basis-exchange algorithm that pivots between bases. However, the criss-cross algorithm need not maintain feasibility, but can pivot rather from a feasible basis to an infeasible basis. The criss-cross algorithm does not have ": null
    },
    {
        "polynomial time-complexity": "time complexity"
    },
    {
        " for linear programming. Both algorithms visit all  42 D  corners of a ": null
    },
    {
        "cube": "unit cube"
    },
    {
        " in dimension  D, the ": null
    },
    {
        "Klee–Minty cube": "klee–minty cube"
    },
    {
        ", in the ": null
    },
    {
        "worst case": "worst-case complexity"
    },
    {
        ". :  :        In contrast to the simplex algorithm, which finds an optimal solution by traversing the edges between vertices on a polyhedral set, interior-point methods move through the interior of the feasible region.       This is the first ": null
    },
    {
        "worst-case": "worst-case complexity"
    },
    {
        " polynomial-time": "polynomial-time"
    },
    {
        " algorithm ever found for linear programming. To solve a problem which has n variables and can be encoded in L input bits, this algorithm uses O pseudo-arithmetic operations on numbers with O digits. ": null
    },
    {
        "Leonid Khachiyan": "leonid khachiyan"
    },
    {
        " solved this long-standing complexity issue in 42 with the introduction of the ": null
    },
    {
        "ellipsoid method": "ellipsoid method"
    },
    {
        ". The convergence analysis has predecessors, notably the ": null
    },
    {
        "iterative method": "iterative method"
    },
    {
        "s developed by ": null
    },
    {
        "Naum Z. Shor": "naum z. shor"
    },
    {
        " and the ": null
    },
    {
        "approximation algorithm": "approximation algorithm"
    },
    {
        "s by Arkadi Nemirovski and D. Yudin.          Khachiyans algorithm was of landmark importance for establishing the polynomial-time solvability of linear programs. The algorithm was not a computational break-through, as the simplex method is more efficient for all but specially constructed families of linear programs.     However, Khachiyans algorithm inspired new lines of research in linear programming. In 42 ": null
    },
    {
        "N. Karmarkar": "narendra karmarkar"
    },
    {
        " proposed a ": null
    },
    {
        "projective method": "projective method"
    },
    {
        " for linear programming. Karmarkars algorithm improved on Khachiyans worst-case polynomial bound . Karmarkar claimed that his algorithm was much faster in practical LP than the simplex method, a claim that created great interest in interior-point methods.  Since Karmarkars discovery, many interior-point methods have been proposed and analyzed.            Affine scaling is one of the oldest interior point methods to be developed. It was developed in the Soviet Union in the mid42s, but didnt receive much attention until the discovery of Karmarkars algorithm, after which affine scaling was ": null
    },
    {
        "reinvented multiple times": "multiple discovery"
    },
    {
        " and presented as a simplified version of Karmarkars. Affine scaling amounts to doing ": null
    },
    {
        "gradient descent": "gradient descent"
    },
    {
        " steps within the feasible region, while rescaling the problem to make sure the steps move toward the optimum faster.        In 42 Vaidya developed an algorithm that runs in O time.  Formally speaking, the algorithm takes O arithmetic operations in the worst case, where d is the number of constraints, n is the number of variables, and L is the number of bits.       For both theoretical and practical purposes, ": null
    },
    {
        "barrier function": "barrier function"
    },
    {
        " or ": null
    },
    {
        "path-following": "path-following"
    },
    {
        " methods have been the most popular interior point methods since the 42s.  In 42 Lee and Sidford showed that, it can be solved in O time,  and it remains taking O in the worst case. In 42 Cohen, Lee and Song improved the running time to O time, \\omega is the exponent of ": null
    },
    {
        "matrix multiplication": "matrix multiplication"
    },
    {
        ".          The current opinion is that the efficiencies of good implementations of simplex-based methods and interior point methods are similar for routine applications of linear programming. However, for specific types of LP problems, it may be that one type of solver is better than another , and that the structure of the solutions generated by interior point methods versus simplex-based methods are significantly different with the support set of active variables being typically smaller for the later one.        Covering and packing LPs can be solved ": null
    },
    {
        "approximately": "approximation algorithm"
    },
    {
        " in nearly-linear time. That is, if matrix  is of dimension  and has  non-zero entries, then there exist algorithms that run in time  and produce  approximate solutions to given covering and packing LPs. The best known sequential algorithm of this kind runs in time ,  and the best known ": null
    },
    {
        "parallel algorithm": "parallel algorithm"
    },
    {
        " of this kind runs in  iterations, each requiring only a matrix-vector multiplication which is highly parallelizable.           There are several open problems in the theory of linear programming, the solution of which would represent fundamental breakthroughs in mathematics and potentially major advances in our ability to solve large-scale linear programs.   Does LP admit a ": null
    },
    {
        "strongly polynomial": "time complexitystrongly and weakly polynomial time"
    },
    {
        "-time algorithm?   Does LP admit a strongly polynomial-time algorithm to find a strictly complementary solution?   Does LP admit a polynomial-time algorithm in the real number model of computation?     This closely related set of problems has been cited by ": null
    },
    {
        "Stephen Smale": "stephen smale"
    },
    {
        " as among the ": null
    },
    {
        "42 greatest unsolved problems": "smales problems"
    },
    {
        " of the 42st century. In Smales words, the third version of the problem is the main unsolved problem of linear programming theory. While algorithms exist to solve linear programming in weakly polynomial time, such as the ": null
    },
    {
        "ellipsoid method": "ellipsoid method"
    },
    {
        "s and ": null
    },
    {
        "interior-point techniques": "interior point method"
    },
    {
        ", no algorithms have yet been found that allow strongly polynomial-time performance in the number of constraints and the number of variables. The development of such algorithms would be of great theoretical interest, and perhaps allow practical gains in solving large LPs as well.     Although the ": null
    },
    {
        "Hirsch conjecture": "hirsch conjecture"
    },
    {
        " was recently disproved for higher dimensions, it still leaves the following questions open.   Are there pivot rules which lead to polynomial-time simplex variants?   Do all polytopal graphs have polynomially bounded diameter?     These questions relate to the performance analysis and development of simplex-like methods. The immense efficiency of the simplex algorithm in practice despite its exponential-time theoretical performance hints that there may be variations of simplex that run in polynomial or even strongly polynomial time. It would be of great practical and theoretical significance to know whether any such variants exist, particularly as an approach to deciding if LP can be solved in strongly polynomial time.     The simplex algorithm and its variants fall in the family of edge-following algorithms, so named because they solve linear programming problems by moving from vertex to vertex along edges of a polytope. This means that their theoretical performance is limited by the maximum number of edges between any two vertices on the LP polytope. As a result, we are interested in knowing the maximum ": null
    },
    {
        "graph-theoretical diameter": "graph diameter"
    },
    {
        " of polytopal ": null
    },
    {
        "graphs": "graph"
    },
    {
        ". It has been proved that all polytopes have subexponential diameter. The recent disproof of the Hirsch conjecture is the first step to prove whether any polytope has superpolynomial diameter. If any such polytopes exist, then no edge-following variant can run in polynomial time. Questions about polytope diameter are of independent mathematical interest.     Simplex pivot methods preserve primal feasibility. On the other hand, criss-cross pivot methods do not preserve feasibility—they may visit primal feasible, dual feasible or primal-and-dual infeasible bases in any order. Pivot methods of this type have been studied since the 42s. Essentially, these methods attempt to find the shortest pivot path on the ": null
    },
    {
        "arrangement polytope": "arrangement polytope"
    },
    {
        " under the linear programming problem. In contrast to polytopal graphs, graphs of arrangement polytopes are known to have small diameter, allowing the possibility of strongly polynomial-time criss-cross pivot algorithm without resolving questions about the diameter of general polytopes.       If all of the unknown variables are required to be integers, then the problem is called an ": null
    },
    {
        "integer programming": "integer programming"
    },
    {
        " or integer linear programming problem. In contrast to linear programming, which can be solved efficiently in the worst case, integer programming problems are in many practical situations ": null
    },
    {
        "NP-hard": "np-hard"
    },
    {
        ". 42–42 integer programming or binary integer programming is the special case of integer programming where variables are required to be 42 or 42 . This problem is also classified as NP-hard, and in fact the decision version was one of ": null
    },
    {
        "Karps 42 NP-complete problems": "karps 21 np-complete problems"
    },
    {
        ".     If only some of the unknown variables are required to be integers, then the problem is called a mixed integer programming problem. These are generally also NP-hard because they are even more general than ILP programs.     There are however some important subclasses of IP and MIP problems that are efficiently solvable, most notably problems where the constraint matrix is ": null
    },
    {
        "totally unimodular": "totally unimodular"
    },
    {
        " and the right-hand sides of the constraints are integers or – more general – where the system has the ": null
    },
    {
        "total dual integrality": "total dual integrality"
    },
    {
        " property.     Advanced algorithms for solving integer linear programs include:   ": null
    },
    {
        "cutting-plane method": "cutting-plane method"
    },
    {
        " Branch and bound": "branch and bound"
    },
    {
        " Branch and cut": "branch and cut"
    },
    {
        " Branch and price": "branch and price"
    },
    {
        " delayed column generation": "delayed column generation"
    },
    {
        ".   Such integer-programming algorithms are discussed by ": null
    },
    {
        "Padberg": "manfred w. padberg"
    },
    {
        " and in Beasley.          A linear program in real variables is said to be integral if it has at least one optimal solution which is integral. Likewise, a polyhedron P \\ is said to be integral if for all bounded feasible objective functions c, the linear program \\ has an optimum x^ with integer coordinates. As observed by Edmonds and Giles in 42 one can equivalently say that the polyhedron P is integral if for every bounded feasible integral objective function c, the optimal value of the linear program \\ is an integer.     Integral linear programs are of central importance in the polyhedral aspect of ": null
    },
    {
        "combinatorial optimization": "combinatorial optimization"
    },
    {
        " since they provide an alternate characterization of a problem. Specifically, for any problem, the convex hull of the solutions is an integral polyhedron; if this polyhedron has a nice/compact description, then we can efficiently find the optimal feasible solution under any linear objective. Conversely, if we can prove that a ": null
    },
    {
        "linear programming relaxation": "linear programming relaxation"
    },
    {
        " is integral, then it is the desired description of the convex hull of feasible solutions.     Terminology is not consistent throughout the literature, so one should be careful to distinguish the following two concepts,   in an integer linear program, described in the previous section, variables are forcibly constrained to be integers, and this problem is NP-hard in general,   in an integral linear program, described in this section, variables are not constrained to be integers but rather one has proven somehow that the continuous problem always has an integral optimal value , and this optimal value may be found efficiently since all polynomial-size linear programs can be solved in polynomial time.     One common way of proving that a polyhedron is integral is to show that it is ": null
    },
    {
        "totally unimodular": "totally unimodular matrix"
    },
    {
        ". There are other general methods including the ": null
    },
    {
        "integer decomposition property": "integer decomposition property"
    },
    {
        " and ": null
    },
    {
        "total dual integrality": "total dual integrality"
    },
    {
        ". Other specific well-known integral LPs include the matching polytope, lattice polyhedra, ": null
    },
    {
        "submodular": "submodular"
    },
    {
        " flow polyhedra, and the intersection of 42 generalized polymatroids/g-polymatroids – e.g. see Schrijver 42          Permissive licenses:         Copyleft licenses:        ": null
    },
    {
        "MINTO": "minto"
    },
    {
        "  has publicly available source code  but is not open source.      Proprietary licenses:   ": null
    }
]