[
    {
        "     In ": null
    },
    {
        "computer science": "computer science"
    },
    {
        ", selection sort is a ": null
    },
    {
        "sorting algorithm": "sorting algorithm"
    },
    {
        ", specifically an ": null
    },
    {
        "in-place": "in-place algorithm"
    },
    {
        " comparison sort": "comparison sort"
    },
    {
        ". It has ": null
    },
    {
        "O": "big o notation"
    },
    {
        " time complexity": "time complexity"
    },
    {
        ", making it inefficient on large lists, and generally performs worse than the similar ": null
    },
    {
        "insertion sort": "insertion sort"
    },
    {
        ". Selection sort is noted for its simplicity, and it has performance advantages over more complicated algorithms in certain situations, particularly where ": null
    },
    {
        "auxiliary memory": "auxiliary memory"
    },
    {
        " is limited.     The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest element in the unsorted sublist, exchanging it with the leftmost unsorted element , and moving the sublist boundaries one element to the right.     The time efficiency of selection sort is quadratic, so there are a number of sorting techniques which have better time complexity than selection sort. Selection sort makes n - 42 swaps in the worst case. The time efficiency of selection sort with respect to swapping is linear, which distinguishes selection sort from other sorting algorithms.       Here is an example of this sort algorithm sorting five elements:               Selection sort can also be used on list structures that make add and remove efficient, such as a ": null
    },
    {
        "linked list": "linked list"
    },
    {
        ". In this case it is more common to remove the minimum element from the remainder of the list, and then insert it at the end of the values sorted so far. For example:       arr 42 42 42 42 42     // Find the minimum element in arr   // and place it at beginning   42 42 42 42 42     // Find the minimum element in arr   // and place it at beginning of arr   42 42 42 42 42     // Find the minimum element in arr   // and place it at beginning of arr   42 42 42 42 42     // Find the minimum element in arr   // and place it at beginning of arr   42 42 42 42 42            Below is an implementation in ": null
    },
    {
        "C": "c"
    },
    {
        ". More implementations can be found on ": null
    },
    {
        "the talk page of this Wikipedia article": "talk:selection sortimplementations"
    },
    {
        ".     / a to a is the array to sort /   int i,j;   int aLength; // initialise to as length     / advance the position through the entire array /   / ": null
    }
]