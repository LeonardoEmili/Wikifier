[
    {
        "In the ": null
    },
    {
        "mathematics": "mathematics"
    },
    {
        " of the ": null
    },
    {
        "real number": "real number"
    },
    {
        "s, the ": null
    },
    {
        "logarithm": "logarithm"
    },
    {
        " log b a is a number x such that , for given numbers a and b. Analogously, in any ": null
    },
    {
        "group": "group"
    },
    {
        " G, powers b k can be defined for all ": null
    },
    {
        "integer": "integer"
    },
    {
        "s k, and the discrete logarithm log b a is an integer k such that . In ": null
    },
    {
        "number theory": "number theory"
    },
    {
        ", the more commonly used term is index: we can write x ind r a   for r x ≡ a  if r is a ": null
    },
    {
        "primitive root": "primitive root modulo n"
    },
    {
        " of m and ": null
    },
    {
        "gcd": "greatest common divisor"
    },
    {
        "    42     Discrete logarithms are quickly computable in a few special cases. However, no efficient method is known for computing them in general. Several important algorithms in ": null
    },
    {
        "public-key cryptography": "public-key cryptography"
    },
    {
        " base their security on the assumption that the discrete logarithm problem over carefully chosen groups has no efficient solution.         Let G be any group. Denote its ": null
    },
    {
        "group operation": "group operation"
    },
    {
        " by multiplication and its identity element by 42 Let b be any element of G. For any positive integer k, the expression b k denotes the product of b with itself k times:   : b^k \\underbrace_.   Similarly, let b -k denote the product of b −42 with itself k times. For k 42 the kth power is the identity: .     Let a also be an element of G. An integer k that solves the equation  is termed a discrete logarithm  of a to the base b. One writes k    log b  a.           The powers of 42 form an infinite subset G of the ": null
    },
    {
        "rational number": "rational number"
    },
    {
        "s. This set G is a ": null
    },
    {
        "cyclic group": "cyclic group"
    },
    {
        " under multiplication, and 42 is a generator. For any element a of the group, one can compute log 42 a. For example, log 42 42 42 and log 42 42 −42 These are instances of the discrete logarithm problem.     Other base42 logarithms in the real numbers are not instances of the discrete logarithm problem, because they involve non-integer exponents. For example, the equation log 42 42 42… means that 42 42… 42 While integer exponents can be defined in any group using products and inverses, arbitrary real exponents in the real numbers require other concepts such as the ": null
    },
    {
        "exponential function": "exponential function"
    },
    {
        ".         A similar example holds for any non-zero real number b. The powers form a multiplicative subgroup G  of the non-zero real numbers. For any element a of G, one can compute log b a.         One of the simplest settings for discrete logarithms is the group ": null
    },
    {
        " × ": "multiplicative group of integers modulo n"
    },
    {
        ". This is the group of multiplication ": null
    },
    {
        "modulo": "modular arithmetic"
    },
    {
        " the ": null
    },
    {
        "prime": "prime number"
    },
    {
        " p. Its elements are ": null
    },
    {
        "congruence class": "congruence class"
    },
    {
        "es modulo p, and the group product of two elements may be obtained by ordinary integer multiplication of the elements followed by reduction modulo  p.     The kth ": null
    },
    {
        "power": "exponentiation"
    },
    {
        " of one of the numbers in this group may be computed by finding its kth power as an integer and then finding the remainder after division by p. When the numbers involved are large, it is more efficient to reduce modulo p multiple times during the computation. Regardless of the specific algorithm used, this operation is called ": null
    },
    {
        "modular exponentiation": "modular exponentiation"
    },
    {
        ". For example, consider  × . To compute 42 42 in this group, compute 42 42 42 and then divide 42 by 42 obtaining a remainder of 42 Thus 42 42 42 in the group  × .     The discrete logarithm is just the inverse operation. For example, consider the equation 42 k ≡ 42 for k. From the example above, one solution is k    42 but it is not the only solution. Since 42 42 ≡ 42 —as follows from ": null
    },
    {
        "Fermats little theorem": "fermats little theorem"
    },
    {
        "—it also follows that if n is an integer then 42 4242n ≡ 42 42 × n ≡ 42 × 42 n ≡ 42 . Hence the equation has infinitely many solutions of the form 42 + 42n. Moreover, because 42 is the smallest positive integer m satisfying 42 m ≡ 42 , these are the only solutions. Equivalently, the set of all possible solutions can be expressed by the constraint that k ≡ 42 .         In the special case where b is the identity element 42 of the group G, the discrete logarithm log b a is undefined for a other than 42 and every integer k is a discrete logarithm for a 42         Powers obey the usual algebraic identity b k + l b k b l . In other words, the function   : f : \\mathbf \\rightarrow G   defined by f b k is a ": null
    },
    {
        "group homomorphism": "group homomorphism"
    },
    {
        " from the integers Z under addition ": null
    },
    {
        "onto": "surjection"
    },
    {
        " the ": null
    },
    {
        "subgroup": "subgroup"
    },
    {
        " H of G ": null
    },
    {
        "generated": "generating set of a group"
    },
    {
        " by b. For all a in H, log b a exists. Conversely, log b a does not exist for a that are not in H.     If H is infinite, then log b a is also unique, and the discrete logarithm amounts to a ": null
    },
    {
        "group isomorphism": "group isomorphism"
    },
    {
        "     : \\log_b \\colon H \\rightarrow \\mathbf.     On the other hand, if H is finite of size n, then log b a is unique only up to congruence modulo n, and the discrete logarithm amounts to a group isomorphism   : \\log_b\\colon H \\rightarrow \\mathbf_n,   where Z n denotes the additive group of integers modulo n.     The familiar base change formula for ordinary logarithms remains valid: If c is another generator of H, then     : \\log_c a \\log_c b \\cdot \\log_b a.             The discrete logarithm problem is considered to be computationally intractable. That is, no efficient classical algorithm is known for computing discrete logarithms in general.     A general algorithm for computing log b a in finite groups G is to raise b to larger and larger powers k until the desired a is found. This algorithm is sometimes called trial multiplication. It requires ": null
    },
    {
        "running time": "running time"
    },
    {
        " linear in the size of the group G and thus exponential in the number of digits in the size of the group. Therefore, it is an ": null
    },
    {
        "exponential-time": "exponential time"
    },
    {
        " algorithm, practical only for small groups G.     More sophisticated algorithms exist, usually inspired by similar algorithms for integer factorization. These algorithms run faster than the naïve algorithm, some of them linear in the square root of the size of the group, and thus exponential in half the number of digits in the size of the group. However none of them run in ": null
    },
    {
        "polynomial time": "polynomial time"
    },
    {
        " .     ": null
    },
    {
        "Baby-step giant-step": "baby-step giant-step"
    },
    {
        " Function field sieve": "function field sieve"
    },
    {
        " Index calculus algorithm": "index calculus algorithm"
    },
    {
        " Number field sieve": "number field sieve"
    },
    {
        " Pohlig–Hellman algorithm": "pohlig–hellman algorithm"
    },
    {
        " Pollards rho algorithm for logarithms": "pollards rho algorithm for logarithms"
    },
    {
        " Pollards kangaroo algorithm": "pollards kangaroo algorithm"
    },
    {
        "     There is an efficient ": null
    },
    {
        "quantum algorithm": "shors algorithm"
    },
    {
        " due to ": null
    },
    {
        "Peter Shor": "peter shor"
    },
    {
        ".      Efficient classical algorithms also exist in certain special cases. For example, in the group of the integers modulo p under addition, the power b k becomes a product bk, and equality means congruence modulo p in the integers. The ": null
    },
    {
        "extended Euclidean algorithm": "extended euclidean algorithm"
    },
    {
        " finds k quickly.         While computing discrete logarithms and ": null
    },
    {
        "factoring integers": "integer factorization"
    },
    {
        " are distinct problems, they share some properties:   both are special cases of the ": null
    },
    {
        "hidden subgroup problem": "hidden subgroup problem"
    },
    {
        " for finite ": null
    },
    {
        "Abelian group": "abelian group"
    },
    {
        "s,   both problems seem to be difficult ,   for both problems efficient algorithms on quantum computers are known,   algorithms from one problem are often adapted to the other, and   the difficulty of both problems has been used to construct various ": null
    },
    {
        "cryptographic": "cryptography"
    },
    {
        " systems.       There exist groups for which computing discrete logarithms is apparently difficult. In some cases  there is not only no efficient algorithm known for the worst case, but the ": null
    },
    {
        "average-case complexity": "average-case complexity"
    },
    {
        " can be shown to be about as hard as the worst case using ": null
    },
    {
        "random self-reducibility": "random self-reducibility"
    },
    {
        ".     At the same time, the inverse problem of discrete exponentiation is not difficult . This asymmetry is analogous to the one between integer factorization and integer ": null
    },
    {
        "multiplication": "multiplication"
    },
    {
        ". Both asymmetries  have been exploited in the construction of cryptographic systems.     Popular choices for the group G in discrete logarithm ": null
    },
    {
        "cryptography": "cryptography"
    },
    {
        " are the cyclic groups  ×  and cyclic subgroups of ": null
    },
    {
        "elliptic curve": "elliptic curve"
    },
    {
        "s over ": null
    },
    {
        "finite field": "finite field"
    },
    {
        "s .     While there is no publicly known algorithm for solving the discrete logarithm problem in general, the first three steps of the ": null
    },
    {
        "number field sieve": "number field sieve"
    },
    {
        " algorithm only depend on the group G, not on the specific elements of G whose finite log is desired. By ": null
    },
    {
        "precomputing": "precomputing"
    },
    {
        " these three steps for a specific group, one need only carry out the last step, which is much less computationally expensive than the first three, to obtain a specific logarithm in that group.     It turns out that much Internet traffic uses one of a handful of groups that are of order 42 bits or less, e.g. cyclic groups with order of the Oakley primes specified in RFC 42 The ": null
    },
    {
        "Logjam": "logjam"
    },
    {
        " attack used this vulnerability to compromise a variety of Internet services that allowed the use of groups whose order was a 42-bit prime number, so called ": null
    },
    {
        "export grade": "export of cryptography"
    },
    {
        ".     The authors of the ": null
    },
    {
        "Logjam": "logjam"
    },
    {
        " attack estimate that the much more difficult precomputation needed to solve the discrete log problem for a 42-bit prime would be within the budget of a large national ": null
    },
    {
        "intelligence agency": "intelligence agency"
    },
    {
        " such as the U.S. ": null
    },
    {
        "National Security Agency": "national security agency"
    },
    {
        " . The Logjam authors speculate that precomputation against widely reused 42 DH primes is behind claims in ": null
    },
    {
        "leaked NSA documents": "global surveillance disclosures"
    },
    {
        " that NSA is able to break much of current cryptography. ": null
    }
]