[
    {
        "   In ": null
    },
    {
        "computer science": "computer science"
    },
    {
        ", a linked list is a linear collection of data elements, whose order is not given by their physical placement in memory. Instead, each element ": null
    },
    {
        "points": "pointer"
    },
    {
        " to the next. It is a ": null
    },
    {
        "data structure": "data structure"
    },
    {
        " consisting of a collection of ": null
    },
    {
        "nodes": "node"
    },
    {
        "which together represent a ": null
    },
    {
        "sequence": "sequence"
    },
    {
        ". In its most basic form, each node contains: ": null
    },
    {
        "data": "data"
    },
    {
        ", and a ": null
    },
    {
        "reference": "reference"
    },
    {
        "  to the next node in the sequence. This structure allows for efficient insertion or removal of elements from any position in the sequence during iteration. More complex variants add additional links, allowing more efficient insertion or removal of nodes at arbitrary positions. A drawback of linked lists is that access time is linear . Faster access, such as random access, is not feasible. ": null
    },
    {
        "Arrays": "array data structure"
    },
    {
        " have better ": null
    },
    {
        "cache locality": "locality of reference"
    },
    {
        " compared to linked lists.      A linked list whose nodes contain two fields: an integer value and a link to the next node. The last node is linked to a terminator used to signify the end of the list.     Linked lists are among the simplest and most common data structures. They can be used to implement several other common ": null
    },
    {
        "abstract data type": "abstract data type"
    },
    {
        "s, including ": null
    },
    {
        "lists": "list"
    },
    {
        ", ": null
    },
    {
        "stacks": "stack"
    },
    {
        ", ": null
    },
    {
        "queues": "queue"
    },
    {
        ", ": null
    },
    {
        "associative array": "associative array"
    },
    {
        "s, and ": null
    },
    {
        "S-expression": "s-expression"
    },
    {
        "s, though it is not uncommon to implement those data structures directly without using a linked list as the basis.     The principal benefit of a linked list over a conventional ": null
    },
    {
        "array": "array data structure"
    },
    {
        " is that the list elements can be easily inserted or removed without reallocation or reorganization of the entire structure because the data items need not be stored ": null
    },
    {
        "contiguously": "wikt:contiguous"
    },
    {
        " in memory or on disk, while restructuring an array at ": null
    },
    {
        "run-time": "run time"
    },
    {
        " is a much more expensive operation. Linked lists allow insertion and removal of nodes at any point in the list, and allow doing so with a constant number of operations by keeping the link previous to the link being added or removed in memory during list traversal.     On the other hand, since simple linked lists by themselves do not allow ": null
    },
    {
        "random access": "random access"
    },
    {
        " to the data or any form of efficient indexing, many basic operations—such as obtaining the last node of the list, finding a node that contains a given datum, or locating the place where a new node should be inserted—may require iterating through most or all of the list elements. The advantages and disadvantages of using linked lists are given below. Linked list are dynamic, so the length of list can increase or decrease as necessary. Each node does not necessarily follow the previous one physically in the memory.         They use more memory than ": null
    },
    {
        "arrays": "array data structure"
    },
    {
        " because of the storage used by their ": null
    },
    {
        "pointers": "pointer"
    },
    {
        ".   Nodes in a linked list must be read in order from the beginning as linked lists are inherently ": null
    },
    {
        "sequential access": "sequential access"
    },
    {
        ".   Nodes are stored incontiguously, greatly increasing the time periods required to access individual elements within the list, especially with a ": null
    },
    {
        "CPU cache": "cpu cache"
    },
    {
        ".   Difficulties arise in linked lists when it comes to reverse traversing. For instance, singly linked lists are cumbersome to navigate backwards  and while doubly linked lists are somewhat easier to read, memory is consumed in allocating space for a ": null
    },
    {
        "back-pointer": "back-pointer"
    },
    {
        ".       Linked lists were developed in 1955–1956 by ": null
    },
    {
        "Allen Newell": "allen newell"
    },
    {
        ", ": null
    },
    {
        "Cliff Shaw": "cliff shaw"
    },
    {
        " and ": null
    },
    {
        "Herbert A. Simon": "herbert a. simon"
    },
    {
        " at ": null
    },
    {
        "RAND Corporation": "rand corporation"
    },
    {
        " as the primary ": null
    },
    {
        "data structure": "data structure"
    },
    {
        " for their ": null
    },
    {
        "Information Processing Language": "information processing language"
    },
    {
        ". IPL was used by the authors to develop several early ": null
    },
    {
        "artificial intelligence": "artificial intelligence"
    },
    {
        " programs, including the Logic Theory Machine, the ": null
    },
    {
        "General Problem Solver": "general problem solver"
    },
    {
        ", and a computer chess program. Reports on their work appeared in IRE Transactions on Information Theory in 1956, and several conference proceedings from 1957 to 1959, including Proceedings of the Western Joint Computer Conference in 1957 and 1958, and Information Processing  in 1959. The now-classic diagram consisting of blocks representing list nodes with arrows pointing to successive list nodes appears in Programming the Logic Theory Machine by Newell and Shaw in Proc. WJCC, February 1957. Newell and Simon were recognized with the ACM ": null
    },
    {
        "Turing Award": "turing award"
    },
    {
        " in 1975 for having made basic contributions to artificial intelligence, the psychology of human cognition, and list processing .   The problem of ": null
    },
    {
        "machine translation": "machine translation"
    },
    {
        " for ": null
    },
    {
        "natural language": "natural language"
    },
    {
        " processing led ": null
    },
    {
        "Victor Yngve": "victor yngve"
    },
    {
        " at ": null
    },
    {
        "Massachusetts Institute of Technology": "massachusetts institute of technology"
    },
    {
        " to use linked lists as data structures in his COMIT programming language for computer research in the field of ": null
    },
    {
        "linguistics": "linguistics"
    },
    {
        ". A report on this language entitled A programming language for mechanical translation appeared in Mechanical Translation in 1958.     ": null
    },
    {
        "LISP": "lisp"
    },
    {
        ", standing for list processor, was created by ": null
    },
    {
        "John McCarthy": "john mccarthy"
    },
    {
        " in 1958 while he was at MIT and in 1960 he published its design in a paper in the ": null
    },
    {
        "Communications of the ACM": "communications of the acm"
    },
    {
        ", entitled Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I . One of LISPs major data structures is the linked list.     By the early 1960s, the utility of both linked lists and languages which use these structures as their primary data representation was well established. Bert Green of the ": null
    },
    {
        "MIT Lincoln Laboratory": "mit lincoln laboratory"
    },
    {
        " published a review article entitled Computer languages for symbol manipulation in IRE Transactions on Human Factors in Electronics in March 1961 which summarized the advantages of the linked list approach. A later review article, A Comparison of list-processing computer languages by Bobrow and Raphael, appeared in Communications of the ACM in April 1964.     Several operating systems developed by ": null
    },
    {
        "Technical Systems Consultants": "technical systems consultants"
    },
    {
        " used singly linked lists as file structures. A directory entry pointed to the first sector of a file, and succeeding portions of the file were located by traversing pointers. Systems using this technique included Flex , mini-Flex , and Flex9 . A variant developed by TSC for and marketed by Smoke Signal Broadcasting in California, used doubly linked lists in the same manner.     The TSS/360 operating system, developed by IBM for the System 360/370 machines, used a double linked list for their file system catalog. The directory structure was similar to Unix, where a directory could contain files and other directories and extend to any depth.       Each record of a linked list is often called an element or ": null
    },
    {
        "node": "node"
    },
    {
        ".     The field of each node that contains the address of the next node is usually called the next link or next pointer. The remaining fields are known as the data, information, value, cargo, or payload fields.     The head of a list is its first node. The tail of a list may refer either to the rest of the list after the head, or to the last node in the list. In ": null
    },
    {
        "Lisp": "lisp"
    },
    {
        " and some derived languages, the next node may be called the ": null
    },
    {
        "cdr": "car and cdr"
    },
    {
        "  of the list, while the payload of the head node may be called the car.       Singly linked lists contain nodes which have a data field as well as next field, which points to the next node in line of nodes. Operations that can be performed on singly linked lists include insertion, deletion and traversal.     ": null
    },
    {
        "Image:Singly-linked-list.svg": "image:singly-linked-list.svg"
    },
    {
        " A singly linked list whose nodes contain two fields: an integer value and a link to the next node The following code demonstrates how to add a new node with data value to the end of a singly linked list:   node addNode ": null
    }
]