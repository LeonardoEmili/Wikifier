[
    {
        "      In ": null
    },
    {
        "mathematics": "mathematics"
    },
    {
        ", and in other disciplines involving ": null
    },
    {
        "formal language": "formal language"
    },
    {
        "s, including ": null
    },
    {
        "mathematical logic": "mathematical logic"
    },
    {
        " and ": null
    },
    {
        "computer science": "computer science"
    },
    {
        ", a free variable is a ": null
    },
    {
        "notation": "mathematical notation"
    },
    {
        " that specifies places in an ": null
    },
    {
        "expression": "expression"
    },
    {
        " where ": null
    },
    {
        "substitution": "substitution"
    },
    {
        " may take place and is not a parameter of this or any container expression. Some older books use the terms real variable and apparent variable for free variable and bound variable, respectively. The idea is related to a placeholder , or a ": null
    },
    {
        "wildcard character": "wildcard character"
    },
    {
        " that stands for an unspecified symbol.     In ": null
    },
    {
        "computer programming": "computer programming"
    },
    {
        ", the term free variable refers to ": null
    },
    {
        "variables": "variable"
    },
    {
        " used in a ": null
    },
    {
        "function": "function"
    },
    {
        " that are neither ": null
    },
    {
        "local variable": "local variable"
    },
    {
        "s nor ": null
    },
    {
        "parameter": "parameter"
    },
    {
        "s of that function. The term ": null
    },
    {
        "non-local variable": "non-local variable"
    },
    {
        " is often a synonym in this context.     A bound variable is a variable that was previously free, but has been bound to a specific value or set of values called ": null
    },
    {
        "domain of discourse": "domain of discourse"
    },
    {
        " or ": null
    },
    {
        "universe": "universe"
    },
    {
        ". For example, the variable x becomes a bound variable when we write:     :": null
    },
    {
        "For all": "for all"
    },
    {
        " x,  42 x 42 + 42x + 42     or     :": null
    },
    {
        "There exists": "there exists"
    },
    {
        " x such that x 42 42     In either of these propositions, it does not matter logically whether we use x or some other letter. However, it could be confusing to use the same letter again elsewhere in some compound ": null
    },
    {
        "proposition": "proposition"
    },
    {
        ". That is, free variables become bound, and then in a sense retire from being available as stand-in values for other values in the creation of formulae.     The term dummy variable is also sometimes used for a bound variable , but that use can create an ambiguity with the definition of ": null
    },
    {
        "dummy variables in regression analysis": "dummy variable"
    },
    {
        ".       Before stating a precise definition of free variable and bound variable, the following are some examples that perhaps make these two concepts clearer than the definition would:     In the expression     : \\sum_^ f,     n is a free variable and k is a bound variable; consequently the value of this expression depends on the value of n, but there is nothing called k on which it could depend.     In the expression     : \\int_42^\\infty x^ e^\\,dx,     y is a free variable and x is a bound variable; consequently the value of this expression depends on the value of y, but there is nothing called x on which it could depend.     In the expression     : \\lim_\\frac,     x is a free variable and h is a bound variable; consequently the value of this expression depends on the value of x, but there is nothing called h on which it could depend.     In the expression     : \\forall x\\ \\exists y\\ \\Big     z is a free variable and x and y are bound variables, associated with ": null
    },
    {
        "logical quantifier": "logical quantifier"
    },
    {
        "s; consequently the ": null
    },
    {
        "logical value": "logical value"
    },
    {
        " of this expression depends on the value of z, but there is nothing called x or y on which it could depend.       The following     : \\sum_   \\quad\\quad \\prod_   \\quad\\quad \\int_42^\\infty \\cdots \\,dx   \\quad\\quad \\lim_   \\quad\\quad \\forall x   \\quad\\quad \\exists x     are some common variable-binding operators. Each of them binds the variable x for some set S.     Note that many of these are ": null
    },
    {
        "operators": "operator"
    },
    {
        " which act on functions of the bound variable. In more complicated contexts, such notations can become awkward and confusing. It can be useful to switch to notations which make the binding explicit, such as     : \\sum_ \\left     for sums or     : D \\left     for differentiation.            Variable-binding mechanisms occur in different contexts in mathematics, logic and computer science. In all cases, however, they are purely ": null
    },
    {
        "syntactic": "syntax"
    },
    {
        " properties of expressions and variables in them. For this section we can summarize syntax by identifying an expression with a ": null
    },
    {
        "tree": "abstract syntax tree"
    },
    {
        " whose leaf nodes are variables, constants, function constants or predicate constants and whose non-leaf nodes are logical operators. This expression can then be determined by doing an ": null
    },
    {
        "inorder traversal": "tree traversal"
    },
    {
        " of the tree. Variable-binding operators are ": null
    },
    {
        "logical operator": "logical operator"
    },
    {
        "s that occur in almost every formal language. Languages that do not have them may be either extremely inexpressive or extremely difficult to use. A binding operator Q takes two arguments: a variable v and an expression P, and when applied to its arguments produces a new expression Q. The meaning of binding operators is supplied by the ": null
    },
    {
        "semantics": "semantics"
    },
    {
        " of the language and does not concern us here.     Variable binding relates three things: a variable v, a location a for that variable in an expression and a non-leaf node n of the form Q. Note: we define a location in an expression as a leaf node in the syntax tree. Variable binding occurs when that location is below the node n.     In the ": null
    },
    {
        "lambda calculus": "lambda calculus"
    },
    {
        ", x is a bound variable in the term M λx. T , and a free variable of T . We say x is bound in M and free in T . If T contains a subterm λx. U then x is rebound in this term. This nested, inner binding of x is said to shadow the outer binding. Occurrences of x in U are free occurrences of the new x .     Variables bound at the top level of a program are technically free variables within the terms to which they are bound but are often treated specially because they can be compiled as fixed addresses. Similarly, an identifier bound to a ": null
    },
    {
        "recursive function": "computable function"
    },
    {
        " is also technically a free variable within its own body but is treated specially.     A closed term is one containing no free variables.       To give an example from mathematics, consider an expression which defines a function     : f \\left     where t is an expression. t may contain some, all or none of the x 42 , ..., x n and it may contain other variables. In this case we say that function definition binds the variables   x 42 , ..., x n .     In this manner, function definition expressions of the kind shown above can be thought of as the variable binding operator, analogous to the lambda expressions of ": null
    },
    {
        "lambda calculus": "lambda calculus"
    },
    {
        ". Other binding operators, like the ": null
    },
    {
        "summation": "summation"
    },
    {
        " sign, can be thought of as ": null
    },
    {
        "higher-order functions": "higher-order functions"
    },
    {
        " applying to a function. So, for example, the expression     : \\sum_     could be treated as a notation for     : \\sum_     where \\sum_ is an operator with two parameters—a one-parameter function, and a set to evaluate that function over. The other operators listed above can be expressed in similar ways; for example, the ": null
    },
    {
        "universal quantifier": "universal quantifier"
    },
    {
        " \\forall x \\in \\mathbb\\ P can be thought of as an operator that evaluates to the ": null
    },
    {
        "logical conjunction": "logical conjunction"
    },
    {
        " of the ": null
    },
    {
        "boolean-valued function": "boolean-valued function"
    },
    {
        " P applied over the set S.              When analyzed in ": null
    },
    {
        "formal semantics": "formal semantics"
    },
    {
        ", natural languages can be seen to have free and ": null
    },
    {
        "bound": "bound variable pronoun"
    },
    {
        " variables. In English, ": null
    },
    {
        "personal pronoun": "personal pronoun"
    },
    {
        "s like he, she, they, etc. can act as free variables.     : Lisa found her book.     In the sentence above, the possessive pronoun her is a free variable. It may ": null
    },
    {
        "refer": "referencesemantics"
    },
    {
        " to the previously mentioned Lisa or to any other female. In other words, her book could be referring to Lisas book  or to a book that belongs to a different female . Whoever the ": null
    },
    {
        "referent": "referent"
    },
    {
        " of her is can be established according to the situational  context. The identity of the referent can be shown using coindexing subscripts where i indicates one referent and j indicates a second referent . Thus, the sentence Lisa found her book has the following interpretations:     : Lisa i found her i book.    : Lisa i found her j book.      The distinction is not purely of academic interest, as some languages do actually have different forms for her i  and her j : for example, ": null
    },
    {
        "Norwegian": "norwegian language"
    },
    {
        " and ": null
    },
    {
        "Swedish": "swedish language"
    },
    {
        " translates coreferent her i  as sin and noncoreferent her j  as hennes.     English does allow specifying coreference, but it is optional, as both interpretations of the previous example are valid :     : Lisa i found her i own book.    : Lisa i found her j own book.      However, ": null
    },
    {
        "reflexive pronoun": "reflexive pronoun"
    },
    {
        "s, such as himself, herself, themselves, etc., and ": null
    },
    {
        "reciprocal pronoun": "reciprocal pronoun"
    },
    {
        "s, such as each other, act as bound variables. In a sentence like the following:     : Jane hurt herself.     the reflexive herself can only refer to the previously mentioned ": null
    },
    {
        "antecedent": "antecedent"
    },
    {
        " Jane. It can never refer to a different female person. In other words, the person being hurt and the person doing the hurting are both the same person, i.e. Jane. The semantics of this sentence is abstractly: JANE hurt JANE. And it cannot be the case that this sentence could mean JANE hurt LISA. The reflexive herself must refer and can only refer to the previously mentioned Jane. In this sense, the variable herself is bound to the noun Jane that occurs in ": null
    },
    {
        "subject": "subject"
    },
    {
        " position. Indicating the coindexation, the first interpretation with Jane and herself coindexed is permissible, but the other interpretation where they are not coindexed is ": null
    },
    {
        "ungrammatical": "grammaticality"
    },
    {
        ":     : Jane i hurt herself i .    : Jane i hurt herself j .      Note that the coreference binding can be represented using a ": null
    },
    {
        "lambda expression": "lambda calculus"
    },
    {
        " as mentioned in the previous ": null
    },
    {
        "Formal explanation section": "formal explanation"
    },
    {
        ". The sentence with the reflexive could be represented as     : Jane     in which Jane is the subject referent argument and λx.x hurt x is the predicate function with the lambda notation and x indicating both the semantic subject and the semantic object of sentence as being bound. This returns the semantic interpretation JANE hurt JANE with JANE being the same person.     Pronouns can also behave in a different way. In the sentence below     : Ashley hit her.     the pronoun her can only refer to a female that is not Ashley. This means that it can never have a reflexive meaning equivalent to Ashley hit herself. The grammatical and ungrammatical interpretations are:     : Ashley i hit her i .    : Ashley i hit her j .      The first interpretation is impossible. Only the second interpretation is permitted by the grammar.     Thus, it can be seen that reflexives and reciprocals are bound variables  while true pronouns are free variables in some grammatical structures but variables that cannot be bound in other grammatical structures. The binding phenomena found in natural languages was particularly important to the syntactic ": null
    },
    {
        "government and binding theory": "government and binding theory"
    },
    {
        " ": null
    }
]