[
    {
        "        Code refactoring is the process of restructuring existing computer code—changing the  factoring —without changing its external behavior. Refactoring is intended to improve  nonfunctional  attributes of the ": null
    },
    {
        "software": "software"
    },
    {
        ". Advantages include improved code ": null
    },
    {
        "readability": "readability"
    },
    {
        " and reduced ": null
    },
    {
        "complexity": "cyclomatic complexity"
    },
    {
        "; these can improve ": null
    },
    {
        "source-code": "source code"
    },
    {
        " maintainability": "maintainability"
    },
    {
        " and create a more expressive internal ": null
    },
    {
        "architecture": "software architecture"
    },
    {
        " or ": null
    },
    {
        "object model": "object model"
    },
    {
        " to improve ": null
    },
    {
        "extensibility": "extensibility"
    },
    {
        ".     Typically, refactoring applies a series of standardised basic micro-refactorings, each of which is a tiny change in a ": null
    },
    {
        "computer programs": "computer program"
    },
    {
        "source code that either preserves the behaviour of the software, or at least does not modify its conformance to ": null
    },
    {
        "functional requirement": "functional requirement"
    },
    {
        "s. Many ": null
    },
    {
        "development environments": "development environment"
    },
    {
        " provide automated support for performing the mechanical aspects of these basic refactorings. If done well, code refactoring may help software developers discover and fix hidden or dormant ": null
    },
    {
        "bugs": "software bug"
    },
    {
        " or ": null
    },
    {
        "vulnerabilities": "vulnerability"
    },
    {
        " in the system by simplifying the underlying logic and eliminating unnecessary levels of complexity. If done poorly it may fail the requirement that external functionality not be changed, introduce new bugs, or both.            Refactoring is usually motivated by noticing a ": null
    },
    {
        "code smell": "code smell"
    },
    {
        ". For example, the method at hand may be very long, or it may be a near ": null
    },
    {
        "duplicate": "duplicate code"
    },
    {
        " of another nearby method. Once recognized, such problems can be addressed by refactoring the source code, or transforming it into a new form that behaves the same as before but that no longer smells .     For a long routine, one or more smaller subroutines can be extracted; or for duplicate routines, the duplication can be removed and replaced with one shared function. Failure to perform refactoring can result in accumulating ": null
    },
    {
        "technical debt": "technical debt"
    },
    {
        "; on the other hand, refactoring is one of the primary means of repaying technical debt.        There are two general categories of benefits to the activity of refactoring.   Maintainability. It is easier to fix bugs because the source code is easy to read and the intent of its author is easy to grasp.  This might be achieved by reducing large monolithic routines into a set of individually concise, well-named, single-purpose methods. It might be achieved by moving a method to a more appropriate class, or by removing misleading comments.   Extensibility. It is easier to extend the capabilities of the application if it uses recognizable ": null
    },
    {
        "design pattern": "design pattern"
    },
    {
        "s, and it provides some flexibility where none before may have existed.       Automatic ": null
    },
    {
        "unit tests": "unit testing"
    },
    {
        " should be set up before refactoring to ensure routines still behave as expected.  Unit tests can bring stability to even large refactors when performed with a single ": null
    },
    {
        "atomic commit": "atomic_commitrevision_control"
    },
    {
        ". A common strategy to allow safe and atomic refactors spanning multiple projects is to store all projects in a single ": null
    },
    {
        "repository": "repository"
    },
    {
        ", known as ": null
    },
    {
        "monorepo": "monorepo"
    },
    {
        ".      With unit testing in place, refactoring is then an iterative cycle of making a small ": null
    },
    {
        "program transformation": "program transformation"
    },
    {
        ", testing it to ensure correctness, and making another small transformation. If at any point a test fails, the last small change is undone and repeated in a different way. Through many small steps the program moves from where it was to where you want it to be. For this very iterative process to be practical, the tests must run very quickly, or the programmer would have to spend a large fraction of their time waiting for the tests to finish. Proponents of ": null
    },
    {
        "extreme programming": "extreme programming"
    },
    {
        " and other ": null
    },
    {
        "agile software development": "agile software development"
    },
    {
        " describe this activity as an integral part of the ": null
    },
    {
        "software development cycle": "software development process"
    },
    {
        ".       Here are some examples of micro-refactorings; some of these may only apply to certain languages or language types. A longer list can be found in ": null
    },
    {
        "Martin Fowlers": "martin fowler"
    },
    {
        "refactoring book   and website. . Many development environments provide automated support for these micro-refactorings. For instance, a programmer could click on the name of a variable and then select the Encapsulate field refactoring from a ": null
    },
    {
        "context menu": "context menu"
    },
    {
        ". The IDE would then prompt for additional details, typically with sensible defaults and a preview of the code changes. After confirmation by the programmer it would carry out the required changes throughout the code.   Techniques that allow for more ": null
    },
    {
        "abstraction": "abstraction"
    },
    {
        " Encapsulate field": "field encapsulation"
    },
    {
        " – force code to access the field with getter and setter methods   ": null
    },
    {
        "Generalize type": "type generalization"
    },
    {
        " – create more general types to allow for more code sharing   Replace type-checking code with state/strategy    Replace conditional with ": null
    },
    {
        "polymorphism": "polymorphism"
    },
    {
        "    Techniques for breaking code apart into more logical pieces   Componentization breaks code down into reusable semantic units that present clear, well-defined, simple-to-use interfaces.   ": null
    },
    {
        "Extract class": "extract class"
    },
    {
        " moves part of the code from an existing class into a new class.   Extract method, to turn part of a larger ": null
    },
    {
        "method": "method"
    },
    {
        " into a new method. By breaking down code in smaller pieces, it is more easily understandable. This is also applicable to ": null
    },
    {
        "function": "function"
    },
    {
        "s.   Techniques for improving names and location of code   Move method or move field – move to a more appropriate ": null
    },
    {
        "class": "class"
    },
    {
        " or source file   ": null
    },
    {
        "Rename method": "rename method"
    },
    {
        " or rename field – changing the name into a new one that better reveals its purpose   Pull up – in ": null
    },
    {
        "object-oriented programming": "object-oriented programming"
    },
    {
        " , move to a ": null
    },
    {
        "superclass": "superclass"
    },
    {
        " subclass": "subclass"
    },
    {
        "   Automatic ": null
    },
    {
        "clone detection": "clone detection"
    },
    {
        " Bruntink, Magiel, et al. . Software Maintenance, 2004. Proceedings. 20th IEEE International Conference on. IEEE, 2004.       While the term refactoring originally referred exclusively to refactoring of software code, in recent years code written in ": null
    },
    {
        "hardware description languages": "hardware description language"
    },
    {
        " has also been refactored. The term hardware refactoring is used as a shorthand term for refactoring of code in hardware description languages. Since HDLs are not considered to be ": null
    },
    {
        "programming languages": "programming language"
    },
    {
        "by most hardware engineers, ": null
    },
    {
        "Hardware description languagesHDL and programming languages": "hardware description languageshdl and programming languages"
    },
    {
        " hardware refactoring is to be considered a separate field from traditional code refactoring.     Automated refactoring of analog hardware descriptions  has been proposed by Zeng and Huss. Kaiping Zeng, Sorin A. Huss, Architecture refinements by code refactoring of behavioral VHDL-AMS models . ISCAS 2006 In their approach, refactoring preserves the simulated behavior of a hardware design. The non-functional measurement that improves is that refactored code can be processed by standard synthesis tools, while the original code cannot.   Refactoring of digital HDLs, albeit manual refactoring, has also been investigated by ": null
    },
    {
        "Synopsys": "synopsys"
    },
    {
        " fellow": "fellow"
    },
    {
        " Mike Keating. M. Keating : Complexity, Abstraction, and the Challenges of Designing Complex Systems , in DAC08 tutorial  Bridging a Verification Gap: C++ to RTL for Practical Design M. Keating, P. Bricaud: Reuse Methodology Manual for System-on-a-Chip Designs, Kluwer Academic Publishers, 1999. His target is to make complex systems easier to understand, which increases the designers productivity.       Although refactoring code has been done informally for decades, ": null
    },
    {
        "William Griswolds": "bill griswold"
    },
    {
        "1991 Ph.D. dissertation is one of the first major academic works on refactoring functional and procedural programs, followed by ": null
    },
    {
        "William Opdykes": "william opdyke"
    },
    {
        "1992 dissertation on the refactoring of object-oriented programs,  although all the theory and machinery have long been available as ": null
    },
    {
        "program transformation": "program transformation"
    },
    {
        " systems. All of these resources provide a catalog of common methods for refactoring; a refactoring method has a description of how to apply the ": null
    },
    {
        "method": "scientific method"
    },
    {
        " and indicators for when you should apply the method.     ": null
    },
    {
        "Martin Fowlers": "martin fowler"
    },
    {
        "book Refactoring: Improving the Design of Existing Code is the canonical reference.     The first known use of the term refactoring in the published literature was in a September, 1990 article by ": null
    },
    {
        "William Opdyke": "william opdyke"
    },
    {
        " and ": null
    },
    {
        "Ralph Johnson": "ralph johnson"
    },
    {
        ".    Griswolds Ph.D. thesis,    Opdykes Ph.D. thesis,  published in 1992, also used this term.     The term factoring has been used in the ": null
    },
    {
        "Forth": "forth"
    },
    {
        " community since at least the early 1980s. Chapter Six of ": null
    },
    {
        "Leo Brodies": "leo brodie"
    },
    {
        "book  Thinking Forth  is dedicated to the subject.     In extreme programming, the Extract Method refactoring technique has essentially the same meaning as factoring in Forth; to break down a word  into smaller, more easily maintained functions.     Refactorings can also be reconstructed  posthoc to produce concise descriptions of complex software changes recorded in software repositories like CVS or SVN.          Many software ": null
    },
    {
        "editors": "text editor"
    },
    {
        " and ": null
    },
    {
        "IDEs": "integrated development environment"
    },
    {
        " have automated refactoring support. It is possible to refactor application code as well as test code.  Here is a list of a few of these editors, or so-called ": null
    },
    {
        "refactoring browsers": "refactoring browser"
    },
    {
        ".   ": null
    },
    {
        "DMS Software Reengineering Toolkit": "dms software reengineering toolkit"
    },
    {
        "   Eclipse based:   ": null
    },
    {
        "Eclipse": "eclipse"
    },
    {
        "    PyDev": "pydev"
    },
    {
        "    Photran": "photran"
    },
    {
        "    Embarcadero Delphi": "embarcadero delphi"
    },
    {
        " AppCode": "appcode"
    },
    {
        "    IntelliJ IDEA": "intellij idea"
    },
    {
        "    PyCharm": "pycharm"
    },
    {
        "    WebStorm": "webstorm"
    },
    {
        "    Android Studio": "android studio"
    },
    {
        "    JDeveloper": "jdeveloper"
    },
    {
        "    NetBeans": "netbeans"
    },
    {
        "    Smalltalk": "smalltalk"
    },
    {
        ": Most dialects include powerful refactoring tools. Many use the original refactoring browser produced in the early 90s by ": null
    },
    {
        "Ralph Johnson": "ralph johnson"
    },
    {
        ".   Visual Studio based:   ": null
    },
    {
        "Visual Studio": "visual studio"
    },
    {
        "   CodeRush": "coderush"
    },
    {
        "   Visual Assist": "visual assist"
    },
    {
        "   Wing IDE": "wing ide"
    },
    {
        "    Xcode": "xcode"
    },
    {
        "  ": null
    }
]