[
    {
        "The Cyclone ": null
    },
    {
        "programming language": "Programming Language"
    },
    {
        " is intended to be a safe dialect of the ": null
    },
    {
        "C language": "C"
    },
    {
        ". Cyclone is designed to avoid ": null
    },
    {
        "buffer overflows": "Buffer Overflow"
    },
    {
        "and other vulnerabilities that are possible in C programs, without losing the power and convenience of C as a tool for ": null
    },
    {
        "system programming": "System Programming"
    },
    {
        ".     Cyclone development was started as a joint project of AT & T Labs Research and ": null
    },
    {
        "Greg Morrisetts": "Greg Morrisett"
    },
    {
        "group at Cornell in 2001. Version 1.0 was released on May 8, 2006.       Cyclone attempts to avoid some of the common pitfalls of ": null
    },
    {
        "C": "C"
    },
    {
        ", while still maintaining its look and performance. To this end, Cyclone places the following limits on programs:   ": null
    },
    {
        "NULL": "Null Pointer"
    },
    {
        " checks are inserted to prevent ": null
    },
    {
        "segmentation faults": "Segmentation Fault"
    },
    {
        "  Pointer arithmetic": "Pointer Arithmetic"
    },
    {
        " is limited   Pointers must be initialized before use    ": null
    },
    {
        "Dangling pointers": "Dangling Pointer"
    },
    {
        "are prevented through region analysis and limits on ": null
    },
    {
        " free ": "Malloc"
    },
    {
        "  goto ": "Control Flow"
    },
    {
        " into scopes is disallowed   ": null
    },
    {
        " switch ": "Control Flow"
    },
    {
        " labels in different scopes are disallowed   Pointer-returning functions must execute return   ": null
    },
    {
        " setjmp ": "Setjmp/Longjmp"
    },
    {
        " and ": null
    },
    {
        " longjmp ": "Setjmp/Longjmp"
    },
    {
        " are not supported     To maintain the tool set that C programmers are used to, Cyclone provides the following extensions:   Never- NULL pointers do not require NULL checks   Fat pointers support pointer arithmetic with run-time ": null
    },
    {
        "bounds checking": "Bounds Checking"
    },
    {
        " Garbage collection": "Garbage Collection"
    },
    {
        " for heap-allocated values   ": null
    },
    {
        "Tagged unions": "Tagged Union"
    },
    {
        "support type-varying arguments   Injections help automate the use of tagged unions for programmers   ": null
    },
    {
        "Polymorphism": "Polymorphism"
    },
    {
        " replaces some uses of ": null
    },
    {
        " void ": "Void Pointer"
    },
    {
        " Exceptions": "Exception Handling"
    },
    {
        " replace some uses of setjmp and longjmp     For a better high-level introduction to Cyclone, the reasoning behind Cyclone and the source of these lists, see .     Cyclone looks, in general, much like ": null
    },
    {
        "C": "C"
    },
    {
        ", but it should be viewed as a C-like language.       Cyclone implements three kinds of ": null
    },
    {
        "pointer": "Pointer"
    },
    {
        ":     @ , and   ? .   The purpose of introducing these new pointer types is to avoid common problems when using pointers. Take for instance a function, called foo that takes a pointer to an int:     int foo;     Although the person who wrote the function foo could have inserted NULL checks, let us assume that for performance reasons they did not. Calling foo; will result in ": null
    },
    {
        "undefined behavior": "Undefined Behavior"
    },
    {
        " . To avoid such problems, Cyclone introduces the @ pointer type, which can never be NULL . Thus, the safe version of foo would be:     int foo;     This tells the Cyclone compiler that the argument to foo should never be NULL , avoiding the aforementioned undefined behavior. The simple change of to @ saves the programmer from having to write NULL checks and the operating system from having to trap NULL pointer dereferences. This extra limit, however, can be a rather large stumbling block for most C programmers, who are used to being able to manipulate their pointers directly with arithmetic. Although this is desirable, it can lead to ": null
    },
    {
        "buffer overflows": "Buffer Overflow"
    },
    {
        "and other off-by-one -style mistakes. To avoid this, the ? pointer type is delimited by a known bound, the size of the array. Although this adds overhead due to the extra information stored about the pointer, it improves safety and security. Take for instance a simple strlen function, written in C:     int strlen   ": null
    }
]