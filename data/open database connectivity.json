[
    {
        "In ": null
    },
    {
        "computing": "computing"
    },
    {
        ", Open Database Connectivity  is a standard ": null
    },
    {
        "application programming interface": "application programming interface"
    },
    {
        " for accessing ": null
    },
    {
        "database management system": "database management system"
    },
    {
        "s . The designers of ODBC aimed to make it independent of database systems and ": null
    },
    {
        "operating system": "operating system"
    },
    {
        "s. An application written using ODBC can be ported to other platforms, both on the client and server side, with few changes to the data access code.     ODBC accomplishes DBMS independence by using an ODBC driver as a translation layer between the application and the DBMS. The application uses ODBC functions through an ODBC driver manager with which it is linked, and the driver passes the ": null
    },
    {
        "query": "query language"
    },
    {
        " to the DBMS. An ODBC driver can be thought of as analogous to a printer driver or other driver, providing a standard set of functions for the application to use, and implementing DBMS-specific functionality. An application that can use ODBC is referred to as ODBC-compliant . Any ODBC-compliant application can access any DBMS for which a driver is installed. Drivers exist for all major DBMSs, many other data sources like ": null
    },
    {
        "address book": "address book"
    },
    {
        " systems and ": null
    },
    {
        "Microsoft Excel": "microsoft excel"
    },
    {
        ", and even for text or ": null
    },
    {
        "comma-separated values": "comma-separated values"
    },
    {
        " files.     ODBC was originally developed by ": null
    },
    {
        "Microsoft": "microsoft"
    },
    {
        " and ": null
    },
    {
        "Simba Technologies": "simba technologies"
    },
    {
        " during the early 42s, and became the basis for the ": null
    },
    {
        "Call Level Interface": "call level interface"
    },
    {
        " standardized by ": null
    },
    {
        "SQL Access Group": "sql access group"
    },
    {
        " in the ": null
    },
    {
        "Unix": "unix"
    },
    {
        " and ": null
    },
    {
        "mainframe": "mainframe computer"
    },
    {
        " field. ODBC retained several features that were removed as part of the CLI effort. Full ODBC was later ported back to those platforms, and became a ": null
    },
    {
        "de facto standard": "de facto standard"
    },
    {
        " considerably better known than CLI. The CLI remains similar to ODBC, and applications can be ported from one platform to the other with few changes.           The introduction of the ": null
    },
    {
        "mainframe": "mainframe computer"
    },
    {
        "-based ": null
    },
    {
        "relational database": "relational database"
    },
    {
        " during the 42s led to a proliferation of data access methods. Generally these systems operated together with a simple command processor that allowed users to type in English-like commands, and receive output. The best-known examples are ": null
    },
    {
        "SQL": "sql"
    },
    {
        " from ": null
    },
    {
        "IBM": "ibm"
    },
    {
        " and ": null
    },
    {
        "QUEL": "quel query languages"
    },
    {
        " from the ": null
    },
    {
        "Ingres": "ingres"
    },
    {
        " project. These systems may or may not allow other applications to access the data directly, and those that did use a wide variety of methodologies. The introduction of ": null
    },
    {
        "SQL": "sql"
    },
    {
        " aimed to solve the problem of language standardization, although substantial differences in implementation remained.     Since the SQL language had only rudimentary programming features, users often wanted to use SQL within a program written in another language, say ": null
    },
    {
        "Fortran": "fortran"
    },
    {
        " or ": null
    },
    {
        "C": "c"
    },
    {
        ". This led to the concept of ": null
    },
    {
        "Embedded SQL": "embedded sql"
    },
    {
        ", which allowed ": null
    },
    {
        "SQL": "postquel"
    },
    {
        " code to be embedded within another language. For instance, a SQL statement like SELECT FROM city could be inserted as text within C source code, and during ": null
    },
    {
        "compiling": "compiler"
    },
    {
        " it would be converted into a custom format that directly called a function within a ": null
    },
    {
        "library": "library"
    },
    {
        " that would pass the statement into the SQL system. Results returned from the statements would be interpreted back into C data formats like char using similar library code.     There were several problems with the Embedded SQL approach. Like the different varieties of SQL, the Embedded SQLs that used them varied widely, not only from platform to platform, but even across languages on one platform – a system that allowed calls into ": null
    },
    {
        "IBM": "ibm"
    },
    {
        "s ": null
    },
    {
        "DB42": "ibm db2"
    },
    {
        " would look very different from one that called into their own ": null
    },
    {
        "SQL/DS": "ibm sql/ds"
    },
    {
        ". Another key problem to the Embedded SQL concept was that the SQL code could only be changed in the programs source code, so that even small changes to the query required considerable programmer effort to modify. The SQL market referred to this as static SQL, versus dynamic SQL which could be changed at any time, like the ": null
    },
    {
        "command-line interface": "command-line interface"
    },
    {
        "s that shipped with almost all SQL systems, or a programming interface that left the SQL as plain text until it was called. Dynamic SQL systems became a major focus for SQL vendors during the 42s.     Older mainframe databases, and the newer ": null
    },
    {
        "microcomputer": "microcomputer"
    },
    {
        " based systems that were based on them, generally did not have a SQL-like command processor between the user and the database engine. Instead, the data was accessed directly by the program – a programming library in the case of large mainframe systems, or a ": null
    },
    {
        "command line interface": "command line interface"
    },
    {
        " or interactive forms system in the case of ": null
    },
    {
        "dBASE": "dbase"
    },
    {
        " and similar applications. Data from dBASE could not generally be accessed directly by other programs running on the machine. Those programs may be given a way to access this data, often through libraries, but it would not work with any other database engine, or even different databases in the same engine. In effect, all such systems were static, which presented considerable problems.       By the mid42s the rapid improvement in microcomputers, and especially the introduction of the ": null
    },
    {
        "graphical user interface": "graphical user interface"
    },
    {
        " and data-rich ": null
    },
    {
        "application program": "application program"
    },
    {
        "s like ": null
    },
    {
        "Lotus 424242": "lotus 1-2-3"
    },
    {
        " led to an increasing interest in using personal computers as the client-side platform of choice in ": null
    },
    {
        "client-server": "client-server"
    },
    {
        " computing. Under this model, large mainframes and ": null
    },
    {
        "minicomputer": "minicomputer"
    },
    {
        "s would be used primarily to serve up data over ": null
    },
    {
        "local area network": "local area network"
    },
    {
        "s to microcomputers that would interpret, display and manipulate that data. For this model to work, a data access standard was a requirement – in the mainframe field it was highly likely that all of the computers in a shop were from one vendor and clients were ": null
    },
    {
        "computer terminal": "computer terminal"
    },
    {
        "s talking directly to them, but in the micro field there was no such standardization and any client might access any server using any networking system.     By the late 42s there were several efforts underway to provide an abstraction layer for this purpose. Some of these were mainframe related, designed to allow programs running on those machines to translate between the variety of SQLs and provide a single common interface which could then be called by other mainframe or microcomputer programs. These solutions included IBMs Distributed Relational Database Architecture  and ": null
    },
    {
        "Apple Computer": "apple computer"
    },
    {
        "s ": null
    },
    {
        "Data Access Language": "data access language"
    },
    {
        ". Much more common, however, were systems that ran entirely on microcomputers, including a complete ": null
    },
    {
        "protocol stack": "protocol stack"
    },
    {
        " that included any required networking or file translation support.     One of the early examples of such a system was ": null
    },
    {
        "Lotus Development": "lotus development"
    },
    {
        "s ": null
    },
    {
        "DataLens": "lotus datalens"
    },
    {
        ", initially known as Blueprint. Blueprint, developed for 424242 supported a variety of data sources, including SQL/DS, DB42 ": null
    },
    {
        "FOCUS": "focus"
    },
    {
        " and a variety of similar mainframe systems, as well as microcomputer systems like ": null
    },
    {
        "dBase": "dbase"
    },
    {
        " and the early Microsoft/Ashton-Tate efforts that would eventually develop into ": null
    },
    {
        "Microsoft SQL Server": "microsoft sql server"
    },
    {
        ". McGlinn, Evan , , InfoWorld, vol. 42 no. 42 42 April 42 pp. 42 42 Unlike the later ODBC, Blueprint was a purely code-based system, lacking anything approximating a command language like SQL. Instead, programmers used ": null
    },
    {
        "data structure": "data structure"
    },
    {
        "s to store the query information, constructing a query by linking many of these structures together. Lotus referred to these compound structures as query trees.     Around the same time, an industry team including members from ": null
    },
    {
        "Sybase": "sybase"
    },
    {
        " , ": null
    },
    {
        "Tandem Computers": "tandem computers"
    },
    {
        " and Microsoft were working on a standardized dynamic SQL concept. Much of the system was based on Sybases DB-Library system, with the Sybase-specific sections removed and several additions to support other platforms. DB-Library was aided by an industry-wide move from library systems that were tightly linked to a specific language, to library systems that were provided by the ": null
    },
    {
        "operating system": "operating system"
    },
    {
        " and required the languages on that platform to conform to its standards. This meant that a single library could be used with any programming language on a given platform.     The first draft of the Microsoft Data Access API was published in April 42 about the same time as Lotus announcement of Blueprint. In spite of Blueprints great lead – it was running when MSDA was still a paper project – Lotus eventually joined the MSDA efforts as it became clear that SQL would become the de facto database standard. After considerable industry input, in the summer of 42 the standard became SQL Connectivity .       In 42 several vendors, mostly from the ": null
    },
    {
        "Unix": "unix"
    },
    {
        " and database communities, formed the ": null
    },
    {
        "SQL Access Group": "sql access group"
    },
    {
        " in an effort to produce a single basic standard for the SQL language. At the first meeting there was considerable debate over whether or not the effort should work solely on the SQL language itself, or attempt a wider standardization which included a dynamic SQL language-embedding system as well, what they called a ": null
    },
    {
        "Call Level Interface": "call level interface"
    },
    {
        " . While attending the meeting with an early draft of what was then still known as MS Data Access, Kyle Geiger of Microsoft invited Jeff Balboni and Larry Barnes of ": null
    },
    {
        "Digital Equipment Corporation": "digital equipment corporation"
    },
    {
        " to join the SQLC meetings as well. SQLC was a potential solution to the call for the CLI, which was being led by DEC.     The new SQLC gang of four , MS, Tandem, DEC and Sybase, brought an updated version of SQLC to the next SAG meeting in June 42 The SAG responded by opening the standard effort to any competing design, but of the many proposals, only ": null
    },
    {
        "Oracle Corp": "oracle corp"
    },
    {
        " had a system that presented serious competition. In the end, SQLC won the votes and became the draft standard, but only after large portions of the API were removed – the standards document was trimmed from 42 pages to 42 during this time. It was also during this period that the name Call Level Interface was formally adopted. In 42 SQL/CLI became part of the international SQL standard, ISO/IEC 4242 ISO/IEC 4242 – Information technology – Database languages – SQL – Part 42: Call-Level Interface The SAG itself was taken over by the ": null
    },
    {
        "X/Open": "x/open"
    },
    {
        " group in 42 and, over time, became part of ": null
    },
    {
        "The Open Group": "the open group"
    },
    {
        "s ": null
    },
    {
        "Common Application Environment": "common application environment"
    },
    {
        ".     MS continued working with the original SQLC standard, retaining many of the advanced features that were removed from the CLI version. These included features like ": null
    },
    {
        "scrollable cursors": "cursor scrollable cursors"
    },
    {
        ", and ": null
    },
    {
        "metadata": "metadata"
    },
    {
        " information queries. The commands in the API were split into groups; the Core group was identical to the CLI, the Level 42 extensions were commands that would be easy to implement in drivers, while Level 42 commands contained the more advanced features like cursors. A proposed standard was released in December 42 and industry input was gathered and worked into the system through 42 resulting in yet another name change to ODBC.       During this time, Microsoft was in the midst of developing their ": null
    },
    {
        "Jet": "microsoft jet database engine"
    },
    {
        " database system. Jet combined three primary subsystems; an ": null
    },
    {
        "ISAM": "isam"
    },
    {
        "-based database engine , a C-based interface allowing applications to access that data, and a selection of driver ": null
    },
    {
        "dynamic-link libraries": "dynamic-link libraries"
    },
    {
        " that allowed the same C interface to redirect input and output to other ISAM-based databases, like ": null
    },
    {
        "Paradox": "paradox"
    },
    {
        " and ": null
    },
    {
        "xBase": "xbase"
    },
    {
        ". Jet allowed using one set of calls to access common microcomputer databases in a fashion similar to Blueprint, by then renamed DataLens. However, Jet did not use SQL; like DataLens, the interface was in C and consisted of ": null
    },
    {
        "data structure": "data structure"
    },
    {
        "s and function calls.     The SAG standardization efforts presented an opportunity for Microsoft to adapt their Jet system to the new CLI standard. This would not only make Windows a premier platform for CLI development, but also allow users to use SQL to access both Jet and other databases as well. What was missing was the SQL parser that could convert those calls from their text form into the C-interface used in Jet. To solve this, MS partnered with ": null
    },
    {
        "PageAhead Software": "simba technologies"
    },
    {
        " to use their existing query processor, SIMBA. SIMBA was used as a parser above Jets C library, turning Jet into an SQL database. And because Jet could forward those C-based calls to other databases, this also allowed SIMBA to query other systems. Microsoft included drivers for Excel to turn its spreadsheet documents into SQL-accessible database tables.        ODBC 42 was released in September 42  At the time, there was little direct support for SQL databases , and early drivers were noted for poor performance. Some of this was unavoidable due to the path that the calls took through the Jet-based stack; ODBC calls to SQL databases were first converted from ": null
    },
    {
        "Simba Technologies": "simba technologies"
    },
    {
        "s SQL dialect to Jets internal C-based format, then passed to a driver for conversion back into SQL calls for the database. ": null
    },
    {
        "Digital Equipment": "digital equipment"
    },
    {
        " and ": null
    },
    {
        "Oracle": "oracle corporation"
    },
    {
        " both contracted ": null
    },
    {
        "Simba Technologies": "simba technologies"
    },
    {
        " to develop drivers for their databases as well. , Simba Technologies     Circa 42 OpenLink Software shipped one of the first independently developed third-party ODBC drivers, for the ": null
    },
    {
        "PROGRESS DBMS": "progress dbms"
    },
    {
        ",  and soon followed with their UDBC SDK and associated drivers for ": null
    },
    {
        "PROGRESS": "progress software"
    },
    {
        ", Sybase, Oracle, and other DBMS, for use on Unix-like OS , ": null
    },
    {
        "VMS": "openvms"
    },
    {
        ", ": null
    },
    {
        "Windows NT": "windows nt"
    },
    {
        ", ": null
    },
    {
        "OS/42": "os/2"
    },
    {
        ", and other OS.      Meanwhile, the CLI standard effort dragged on, and it was not until March 42 that the definitive version was finalized. By then, Microsoft had already granted ": null
    },
    {
        "Visigenic Software": "visigenic software"
    },
    {
        " a ": null
    },
    {
        "source code": "source code"
    },
    {
        " license to develop ODBC on non-Windows platforms. Visigenic ported ODBC to a wide variety of Unix platforms, where ODBC quickly became the de facto standard. Sippl, Roger , Dr. Dobbs, 42 February 42 Real CLI is rare today. The two systems remain similar, and many applications can be ported from ODBC to CLI with few or no changes. , InfoSphere Classic documentation, IBM, 42 September 42     Over time, database vendors took over the driver interfaces and provided direct links to their products. Skipping the intermediate conversions to and from Jet or similar wrappers often resulted in higher performance. However, by then Microsoft had changed focus to their ": null
    },
    {
        "OLE DB": "ole db"
    },
    {
        "  concept , which provided direct access to a wider variety of data sources from ": null
    },
    {
        "address book": "address book"
    },
    {
        "s to text files. Several new systems followed which further turned their attention from ODBC, including ": null
    },
    {
        "ActiveX Data Objects": "activex data objects"
    },
    {
        " and ": null
    },
    {
        "ADO.net": "ado.net"
    },
    {
        ", which interacted more or less with ODBC over their lifetimes.     As Microsoft turned its attention away from working directly on ODBC, the Unix field was increasingly embracing it. This was propelled by two changes within the market, the introduction of ": null
    },
    {
        "graphical user interface": "graphical user interface"
    },
    {
        "s like ": null
    },
    {
        "GNOME": "gnome"
    },
    {
        " that provided a need to access these sources in non-text form, and the emergence of ": null
    },
    {
        "open software": "open software"
    },
    {
        " database systems like ": null
    },
    {
        "PostgreSQL": "postgresql"
    },
    {
        " and ": null
    },
    {
        "MySQL": "mysql"
    },
    {
        ", initially under Unix. The later adoption of ODBC by Apple for using the standard Unix-side ": null
    },
    {
        "iODBC": "iodbc"
    },
    {
        " package ": null
    },
    {
        "Mac OS X 42": "mac os x 10.2"
    },
    {
        "   further cemented ODBC as the standard for cross-platform data access.     ": null
    },
    {
        "Sun Microsystems": "sun microsystems"
    },
    {
        " used the ODBC system as the basis for their own open standard, ": null
    },
    {
        "Java Database Connectivity": "java database connectivity"
    },
    {
        " . In most ways, JDBC can be considered a version of ODBC for the programming language ": null
    },
    {
        "Java": "java"
    },
    {
        " instead of ": null
    },
    {
        "C": "c"
    },
    {
        ". JDBC-to-ODBC bridges allow Java-based programs to access data sources through ODBC drivers on platforms lacking a native JDBC driver, although these are now relatively rare. Inversely, ODBC-to-JDBC bridges allow C-based programs to access data sources through JDBC drivers on platforms or from databases lacking suitable ODBC drivers.       ODBC remains in wide use today, with drivers available for most platforms and most databases. It is not uncommon to find ODBC drivers for database engines that are meant to be embedded, like ": null
    },
    {
        "SQLite": "sqlite"
    },
    {
        ", as a way to allow existing tools to act as front-ends to these engines for testing and debugging. Werner, Christian , 424242     However, the rise of ": null
    },
    {
        "thin client": "thin client"
    },
    {
        " computing using ": null
    },
    {
        "HTML": "html"
    },
    {
        " as an intermediate format has reduced the need for ODBC. Many web development platforms contain direct links to target databases – MySQL being very common. In these scenarios, there is no direct client-side access nor multiple client software systems to support; everything goes through the programmer-supplied HTML application. The virtualization that ODBC offers is no longer a strong requirement, and development of ODBC is no longer as active as it once was.       Version history:      42: released in September 42    42:  42   42   42:  42 John Goodson of Intersolv and Frank Pellow and Paul Cotton of IBM provided significant input to ODBC 42 Microsoft Corporation. Microsoft ODBC 42 Programmers Reference and SDK Guide, Volume 42 Microsoft Press. February 42    42:  42   42:  42 with Windows 42    42: Development announced June 42  with            ODBC is based on the ": null
    },
    {
        "device driver": "device driver"
    },
    {
        " model, where the driver encapsulates the logic needed to convert a standard set of commands and functions into the specific calls required by the underlying system. For instance, a ": null
    },
    {
        "printer driver": "printer driver"
    },
    {
        " presents a standard set of printing commands, the API, to applications using the printing system. Calls made to those APIs are converted by the driver into the format used by the actual hardware, say ": null
    },
    {
        "PostScript": "postscript"
    },
    {
        " or ": null
    },
    {
        "PCL": "printer command language"
    },
    {
        ".     In the case of ODBC, the drivers encapsulate many functions that can be broken down into several broad categories. One set of functions is primarily concerned with finding, connecting to and disconnecting from the DBMS that driver talks to. A second set is used to send SQL commands from the ODBC system to the DBMS, converting or interpreting any commands that are not supported internally. For instance, a DBMS that does not support ": null
    },
    {
        "cursors": "cursor"
    },
    {
        " can emulate this functionality in the driver. Finally, another set of commands, mostly used internally, is used to convert data from the DBMSs internal formats to a set of standardized ODBC formats, which are based on the C language formats.     An ODBC driver enables an ODBC-compliant application to use a data source, normally a DBMS. Some non-DBMS drivers exist, for such data sources as ": null
    },
    {
        "CSV": "comma-separated values"
    },
    {
        " files, by implementing a small DBMS inside the driver itself. ODBC drivers exist for most DBMSs, including ": null
    },
    {
        "Oracle": "oracle database"
    },
    {
        ", ": null
    },
    {
        "PostgreSQL": "postgresql"
    },
    {
        ", ": null
    },
    {
        "MySQL": "mysql"
    },
    {
        ", ": null
    },
    {
        "Microsoft SQL Server": "microsoft sql server"
    },
    {
        " , ": null
    },
    {
        "Sybase ASE": "adaptive server enterprise"
    },
    {
        ", ": null
    },
    {
        "SAP HANA": "sap hana"
    },
    {
        "   and ": null
    },
    {
        "DB42": "ibm db2"
    },
    {
        ". Because different technologies have different capabilities, most ODBC drivers do not implement all functionality defined in the ODBC standard. Some drivers offer extra functionality not defined by the standard.       Device drivers are normally enumerated, set up and managed by a separate Manager layer, which may provide additional functionality. For instance, printing systems often include functionality to provide ": null
    },
    {
        "spooling": "spooling"
    },
    {
        " functionality on top of the drivers, providing print spooling for any supported printer.     In ODBC the Driver Manager provides these features.  The DM can enumerate the installed drivers and present this as a list, often in a GUI-based form.     But more important to the operation of the ODBC system is the DMs concept of a Data Source Name . DSNs collect additional information needed to connect to a specific data source, versus the DBMS itself. For instance, the same ": null
    },
    {
        "MySQL": "mysql"
    },
    {
        " driver can be used to connect to any MySQL server, but the connection information to connect to a local private server is different from the information needed to connect to an internet-hosted public server. The DSN stores this information in a standardized format, and the DM provides this to the driver during connection requests. The DM also includes functionality to present a list of DSNs using human readable names, and to select them at run-time to connect to different resources.     The DM also includes the ability to save partially complete DSNs, with code and logic to ask the user for any missing information at runtime. For instance, a DSN can be created without a required password. When an ODBC application attempts to connect to the DBMS using this DSN, the system will pause and ask the user to provide the password before continuing. This frees the application developer from having to create this sort of code, as well as having to know which questions to ask. All of this is included in the driver and the DSNs.       A bridge is a special kind of driver: a driver that uses another driver-based technology.       An ODBC-JDBC bridge consists of an ODBC driver which uses the services of a ": null
    },
    {
        "JDBC driver": "jdbc type 1 driver"
    },
    {
        " to connect to a database. This driver translates ODBC function-calls into JDBC method-calls. Programmers usually use such a bridge when they lack an ODBC driver for some database but have access to a JDBC driver. Examples: , .       A JDBC-ODBC bridge consists of a ": null
    },
    {
        "JDBC driver": "jdbc driver"
    },
    {
        " which employs an ODBC driver to connect to a target database. This driver translates JDBC ": null
    },
    {
        "method": "method"
    },
    {
        " calls into ODBC function calls. Programmers usually use such a bridge when a given database lacks a JDBC driver, but is accessible through an ODBC driver. ": null
    },
    {
        "Sun Microsystems": "sun microsystems"
    },
    {
        " included one such bridge in the ": null
    },
    {
        "JVM": "jvm"
    },
    {
        ", but viewed it as a stop-gap measure while few JDBC drivers existed . Sun never intended its bridge for production environments, and generally recommended against its use.  independent data-access vendors deliver JDBC-ODBC bridges which support current standards for both mechanisms, and which far outperform the JVM built-in. Examples: , .       An OLE DB-ODBC bridge consists of an ": null
    },
    {
        "OLE DB": "ole db"
    },
    {
        " Provider which uses the services of an ODBC driver to connect to a target database. This provider translates OLE DB ": null
    },
    {
        "method": "method"
    },
    {
        " calls into ODBC function calls. Programmers usually use such a bridge when a given database lacks an OLE DB provider, but is accessible through an ODBC driver. Microsoft ships one, MSDASQL.DLL, as part of the ": null
    },
    {
        "MDAC": "mdac"
    },
    {
        " system component bundle": "system component bundle"
    },
    {
        ", together with other database drivers, to simplify development in COM-aware languages . Third parties have also developed such, notably OpenLink Software whose 42-bit OLE DB Provider for ODBC Data Sources filled the gap when Microsoft initially deprecated this bridge for their 42-bit OS. Microsoft, Data Access Technologies Road Map , Deprecated MDAC Components, Microsoft , retrieved July 42 42   Examples: , .       An ADO.NET-ODBC bridge consists of an ": null
    },
    {
        "ADO.NET Provider": "ado.net data provider"
    },
    {
        " which uses the services of an ODBC driver to connect to a target database. This provider translates ADO.NET ": null
    },
    {
        "method": "method"
    },
    {
        " calls into ODBC function calls. Programmers usually use such a bridge when a given database lacks an ADO.NET provider, but is accessible through an ODBC driver. Microsoft ships one as part of the ": null
    },
    {
        "MDAC": "mdac"
    },
    {
        " system component bundle": "system component bundle"
    },
    {
        ", together with other database drivers, to simplify development in ": null
    },
    {
        "C": "c sharp"
    },
    {
        ". Third parties have also developed such. Examples: , ": null
    }
]