[
    {
        "Merge algorithms are a family of ": null
    },
    {
        "algorithms": "algorithm"
    },
    {
        "that take multiple ": null
    },
    {
        "sorted": "sorting algorithm"
    },
    {
        " lists as input and produce a single list as output, containing all the elements of the inputs lists in sorted order. These algorithms are used as ": null
    },
    {
        "subroutines": "subroutine"
    },
    {
        "in various ": null
    },
    {
        "sorting algorithm": "sorting algorithm"
    },
    {
        "s, most famously ": null
    },
    {
        "merge sort": "merge sort"
    },
    {
        ".          The merge algorithm plays a critical role in the ": null
    },
    {
        "merge sort": "merge sort"
    },
    {
        " algorithm, a ": null
    },
    {
        "comparison-based sorting algorithm": "comparison sort"
    },
    {
        ". Conceptually, merge sort algorithm consists of two steps:     ": null
    },
    {
        "Recursively": "recursion"
    },
    {
        " divide the list into sublists of equal length, until each sublist contains only one element, or in the case of iterative merge sort, consider a list of n elements as n sub-lists of size 1. A list containing a single element is, by definition, sorted.   Repeatedly merge sublists to create a new sorted sublist until the single list contains all elements. The single list is the sorted list.     The merge algorithm is used repeatedly in the merge sort algorithm.     An example merge sort is given in the illustration. It starts with an unsorted array of 7 integers. The array is divided into 7 partitions; each partition contains 1 element and is sorted. The sorted partitions are then merged to produce larger, sorted, partitions, until 1 partition, the sorted array, is left.         Merging two sorted lists into one can be done in ": null
    },
    {
        "linear time": "linear time"
    },
    {
        " and linear space. The following ": null
    },
    {
        "pseudocode": "pseudocode"
    },
    {
        " demonstrates an algorithm that merges input lists   and  into a new list .   The function  yields the first element of a list; dropping an element means removing it from its list, typically by incrementing a pointer or index.     algorithm merge is   inputs A, B : list   returns list     C : new empty list   while A is not empty and B is not empty do   if head ≤ head then   append head to C   drop the head of A   else   append head to C   drop the head of B     // By now, either A or B is empty. It remains to empty the other input list.   while A is not empty do   append head to C   drop the head of A   while B is not empty do   append head to C   drop the head of B     return C     When the inputs are linked lists, this algorithm can be implemented to use only a constant amount of working space; the pointers in the lists nodes can be reused for bookkeeping and for constructing the final merged list.     In the merge sort algorithm, this ": null
    },
    {
        "subroutine": "subroutine"
    },
    {
        " is typically used to merge two sub-arrays ,  of a single array . This can be done by copying the sub-arrays into a temporary array, then applying the merge algorithm above. The allocation of a temporary array can be avoided, but at the expense of speed and programming ease. Various in-place merge algorithms have been devised,  sometimes sacrificing the linear-time bound to produce an  algorithm;  see  for discussion.          -way merging generalizes binary merging to an arbitrary number  of sorted input lists. Applications of -way merging arise in various sorting algorithms, including ": null
    },
    {
        "patience sorting": "patience sorting"
    },
    {
        "  and an ": null
    },
    {
        "external sorting": "external sorting"
    },
    {
        " algorithm that divides its input into  blocks that fit in memory, sorts these one by one, then merges these blocks.     Several solutions to this problem exist. A naive solution is to do a loop over the  lists to pick off the minimum element each time, and repeat this loop until all lists are empty:         lists.   While any of the lists is non-empty:   Loop over the lists to find the one with the minimum first element.   Output the minimum element and remove it from its list.          ": null
    },
    {
        "In the worst case": "best, worst and average case"
    },
    {
        ", this algorithm performs  element comparisons to perform its work if there are a total of  elements in the lists.    It can be improved by storing the lists in a ": null
    },
    {
        "priority queue": "priority queue"
    },
    {
        "  keyed by their first element:         of the  lists, using the first element as the key.   While any of the lists is non-empty:   Let .   Output the first element of list  and remove it from its list.   Re-heapify .          Searching for the next smallest element to be output and restoring heap order can now be done in  time , and the full problem can be solved in  time .       A third algorithm for the problem is a ": null
    },
    {
        "divide and conquer": "divide and conquer algorithm"
    },
    {
        " solution that builds on the binary merge algorithm:        , output the single input list.   If , perform a binary merge.   Else, recursively merge the first  lists and the final  lists, then binary merge these.          When the input lists to this algorithm are ordered by length, shortest first, it requires fewer than  comparisons, i.e., less than half the number used by the heap-based algorithm; in practice, it may be about as fast or slow as the heap-based algorithm.       A ": null
    },
    {
        "parallel": "task parallelism"
    },
    {
        " version of the binary merge algorithm can serve as a building block of a ": null
    },
    {
        "parallel merge sort": "merge sortparallel merge sort"
    },
    {
        ". The following pseudocode demonstrates this algorithm in a ": null
    },
    {
        "parallel divide-and-conquer": "fork-join model"
    },
    {
        " style . It operates on two sorted arrays  and  and writes the sorted output to array . The notation  denotes the part of  from index  through , exclusive.     algorithm merge is   inputs A, B, C : array   i, j, k, ℓ, p, q : indices     let m j - i,   n ℓ - k     if m ": null
    }
]