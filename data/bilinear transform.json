[
    {
        "The bilinear transform  is used in ": null
    },
    {
        "digital signal processing": "Digital Signal Processing"
    },
    {
        " and discrete-time ": null
    },
    {
        "control theory": "Control Theory"
    },
    {
        " to transform continuous-time system representations to discrete-time and vice versa.     The bilinear transform is a special case of a ": null
    },
    {
        "conformal map": "Conformal Map"
    },
    {
        "ping , often used to convert a ": null
    },
    {
        "transfer function": "Transfer Function"
    },
    {
        " H_a \\ of a ": null
    },
    {
        "linear": "Linear"
    },
    {
        ", ": null
    },
    {
        "time-invariant": "Time-Invariant"
    },
    {
        "  filter in the ": null
    },
    {
        "continuous": "Continuous Function"
    },
    {
        "-time domain  to a transfer function H_d \\ of a linear, shift-invariant filter in the ": null
    },
    {
        "discrete": "Discrete Signal"
    },
    {
        "-time domain . It maps positions on the j \\omega \\ axis, Re \\ , in the ": null
    },
    {
        "s-plane": "S-Plane"
    },
    {
        " to the ": null
    },
    {
        "unit circle": "Unit Circle"
    },
    {
        ", |z| 1 \\ , in the ": null
    },
    {
        "z-plane": "Complex Plane"
    },
    {
        ". Other bilinear transforms can be used to warp the ": null
    },
    {
        "frequency response": "Frequency Response"
    },
    {
        " of any discrete-time linear system and are implementable in the discrete domain by replacing a systems unit delays \\left \\ with first order ": null
    },
    {
        "all-pass filter": "All-Pass Filter"
    },
    {
        "s.     The transform preserves ": null
    },
    {
        "stability": "Bibo Stability"
    },
    {
        " and maps every point of the ": null
    },
    {
        "frequency response": "Frequency Response"
    },
    {
        " of the continuous-time filter, H_a \\ to a corresponding point in the frequency response of the discrete-time filter, H_d \\ although to a somewhat different frequency, as shown in the ": null
    },
    {
        "Frequency warping": "Frequency Warping"
    },
    {
        " section below. This means that for every feature that one sees in the frequency response of the analog filter, there is a corresponding feature, with identical gain and phase shift, in the frequency response of the digital filter but, perhaps, at a somewhat different frequency. This is barely noticeable at low frequencies but is quite evident at frequencies close to the ": null
    },
    {
        "Nyquist frequency": "Nyquist Frequency"
    },
    {
        ".       The bilinear transform is a first-order approximation of the natural logarithm function that is an exact mapping of the z-plane to the s-plane. When the ": null
    },
    {
        "Laplace transform": "Laplace Transform"
    },
    {
        " is performed on a discrete-time signal , the result is precisely the ": null
    },
    {
        "Z transform": "Z Transform"
    },
    {
        " of the discrete-time sequence with the substitution of     :   \\begin   z & e^ \\\\   & \\frac \\\\   & \\approx \\frac   \\end       where T \\ is the ": null
    },
    {
        "numerical integration": "Numerical Integration"
    },
    {
        " step size of the ": null
    },
    {
        "trapezoidal rule": "Trapezoidal Rule"
    },
    {
        " used in the bilinear transform derivation;  or, in other words, the sampling period. The above bilinear approximation can be solved for s \\ or a similar approximation for s \\ln \\ \\ can be performed.     The inverse of this mapping  is     :   \\begin   s & \\frac \\ln \\\\   & \\frac \\left \\\\   & \\approx \\frac \\frac \\\\   & \\frac \\frac   \\end       The bilinear transform essentially uses this first order approximation and substitutes into the continuous-time transfer function, H_a \\     : s \\leftarrow \\frac \\frac.     That is     : H_d H_a \\bigg|_ H_a \\left. \\       A continuous-time causal filter is ": null
    },
    {
        "stable": "Bibo Stability"
    },
    {
        " if the ": null
    },
    {
        "poles": "Pole"
    },
    {
        " of its transfer function fall in the left half of the ": null
    },
    {
        "complex": "Complex Number"
    },
    {
        " s-plane": "S-Plane"
    },
    {
        ". A discrete-time causal filter is stable if the poles of its transfer function fall inside the ": null
    },
    {
        "unit circle": "Unit Circle"
    },
    {
        " in the ": null
    },
    {
        "complex z-plane": "Complex Plane"
    },
    {
        ". The bilinear transform maps the left half of the complex s-plane to the interior of the unit circle in the z-plane. Thus, filters designed in the continuous-time domain that are stable are converted to filters in the discrete-time domain that preserve that stability.     Likewise, a continuous-time filter is ": null
    },
    {
        "minimum-phase": "Minimum-Phase"
    },
    {
        " if the ": null
    },
    {
        "zeros": "Zero"
    },
    {
        " of its transfer function fall in the left half of the complex s-plane. A discrete-time filter is minimum-phase if the zeros of its transfer function fall inside the unit circle in the complex z-plane. Then the same mapping property assures that continuous-time filters that are minimum-phase are converted to discrete-time filters that preserve that property of being minimum-phase.       As an example take a simple ": null
    },
    {
        "low-pass": "Low-Pass"
    },
    {
        " RC filter": "Rc Filter"
    },
    {
        ". This continuous-time filter has a transfer function     : \\begin   H_a & \\frac \\\\   & \\frac.   \\end     If we wish to implement this filter as a digital filter, we can apply the bilinear transform by substituting for s the formula above; after some reworking, we get the following filter representation:     :     The coefficients of the denominator are the feed-backward coefficients and the coefficients of the numerator are the feed-forward coefficients used to implement a real-time ": null
    },
    {
        "digital filter": "Digital Filter"
    },
    {
        ".       It is possible to relate the coefficients of a continuous-time, analog filter with those of a similar discrete-time digital filter created through the bilinear transform process. Transforming a general, first-order continuous-time filter with the given transfer function     : H_a \\frac \\frac     using the bilinear transform requires the substitution of     : s \\leftarrow K \\frac     where     : K \\triangleq \\frac .     However, if the frequency warping compensation as described below is used in the bilinear transform, so that both analog and digital filter gain and phase agree at frequency \\omega_0 , then     : K \\triangleq \\frac .     This results in a discrete-time digital filter with coefficients expressed in terms of the coefficients of the original continuous time filter:   : H_d\\frac     Normally the constant term in the denominator must be normalized to 1 before deriving the corresponding ": null
    },
    {
        "difference equation": "Difference Equation"
    },
    {
        ". This results in     : H_d\\frac.     The difference equation  is     :   y \\frac \\cdot x + \\frac \\cdot x - \\frac \\cdot y \\ .         A similar process can be used for a general second-order filter with the given transfer function     : H_a \\frac \\frac \\ .     This results in a discrete-time ": null
    },
    {
        "digital biquad filter": "Digital Biquad Filter"
    },
    {
        " with coefficients expressed in terms of the coefficients of the original continuous time filter:   : H_d\\frac     Again, the constant term in the denominator is generally normalized to 1 before deriving the corresponding ": null
    },
    {
        "difference equation": "Difference Equation"
    },
    {
        ". This results in     : H_d\\frac.     The difference equation  is     :   y \\frac \\cdot x + \\frac \\cdot x + \\frac \\cdot x - \\frac \\cdot y - \\frac \\cdot y \\ .         To determine the frequency response of a continuous-time filter, the ": null
    },
    {
        "transfer function": "Transfer Function"
    },
    {
        " H_a is evaluated at s j \\omega_a which is on the j \\omega axis. Likewise, to determine the frequency response of a discrete-time filter, the transfer function H_d is evaluated at z e^ which is on the unit circle, |z| 1 . The bilinear transform maps the j \\omega axis of the s-plane to the unit circle of the z-plane, |z| 1 , but it is not the same mapping z e^ which also maps the j \\omega axis to the unit circle. When the actual frequency of \\omega_d is input to the discrete-time filter designed by use of the bilinear transform, then it is desired to know at what frequency, \\omega_a , for the continuous-time filter that this \\omega_d is mapped to.     : H_d H_a \\left     :     This shows that every point on the unit circle in the discrete-time filter z-plane, z e^ is mapped to a point on the j \\omega axis on the continuous-time filter s-plane, s j \\omega_a . That is, the discrete-time to continuous-time frequency mapping of the bilinear transform is     : \\omega_a \\frac \\tan \\left     and the inverse mapping is     : \\omega_d \\frac \\arctan \\left.     The discrete-time filter behaves at frequency \\omega_d the same way that the continuous-time filter behaves at frequency \\tan . Specifically, the gain and phase shift that the discrete-time filter has at frequency \\omega_d is the same gain and phase shift that the continuous-time filter has at frequency \\tan . This means that every feature, every bump that is visible in the frequency response of the continuous-time filter is also visible in the discrete-time filter, but at a different frequency. For low frequencies , then the features are mapped to a slightly different frequency; \\omega_d \\approx \\omega_a .     One can see that the entire continuous frequency range     : -\\infty ": null
    }
]