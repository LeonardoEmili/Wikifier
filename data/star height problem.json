[
    {
        "The star height problem in ": null
    },
    {
        "formal language theory": "formal language theory"
    },
    {
        " is the question whether all ": null
    },
    {
        "regular languages": "regular language"
    },
    {
        "can be expressed using ": null
    },
    {
        "regular expressions": "regular expressionformal language theory"
    },
    {
        "of limited ": null
    },
    {
        "star height": "star height"
    },
    {
        ", i.e. with a limited nesting depth of ": null
    },
    {
        "Kleene star": "kleene star"
    },
    {
        "s. Specifically, is a nesting depth of one always sufficient? If not, is there an ": null
    },
    {
        "algorithm": "algorithm"
    },
    {
        " to determine how many are required? The problem was raised by .       The first question was answered in the negative when in 1963, Eggan gave examples of regular languages of ": null
    },
    {
        "star height": "star height"
    },
    {
        " n for every n. Here, the star height h of a regular language L is defined as the minimum star height among all regular expressions representing L. The first few languages found by  are described in the following, by means of giving a regular expression for each language:     : \\begin   e_1 & a_1^ \\\\   e_2 & \\left^\\\\   e_3 & \\left^\\\\   e_4 & \\left^   \\end       The construction principle for these expressions is that expression e_ is obtained by concatenating two copies of e_n , appropriately renaming the letters of the second copy using fresh alphabet symbols, concatenating the result with another fresh alphabet symbol, and then by surrounding the resulting expression with a Kleene star. The remaining, more difficult part, is to prove that for e_n there is no equivalent regular expression of star height less than n; a proof is given in .     However, Eggans examples use a large ": null
    },
    {
        "alphabet": "alphabet"
    },
    {
        ", of size 2 n -1 for the language with star height n. He thus asked whether we can also find examples over binary alphabets. This was proved to be true shortly afterwards by .   Their examples can be described by an ": null
    },
    {
        "inductively defined": "inductive definition"
    },
    {
        " family of regular expressions over the binary alphabet \\ as follows & ndash;cf. :     : \\begin   e_1 & ^ \\\\   e_2 & \\left^ \\\\   e_3 & \\left^ \\\\   \\, & \\cdots \\\\   e_ & ^   \\end       Again, a rigorous proof is needed for the fact that e_n does not admit an equivalent regular expression of lower star height. Proofs are given by  and by .       In contrast, the second question turned out to be much more difficult, and the question became a famous open problem in formal language theory for over two decades . For years, there was only little progress. The ": null
    },
    {
        "pure-group languages": "pure-group language"
    },
    {
        "were the first interesting family of regular languages for which the star height problem was proved to be ": null
    },
    {
        "decidable": "decidable language"
    },
    {
        " . But the general problem remained open for more than 25 years until it was settled by ": null
    },
    {
        "Hashiguchi": "kosaburo hashiguchi"
    },
    {
        ", who in 1988 published an algorithm to determine the ": null
    },
    {
        "star height": "star height"
    },
    {
        " of any regular language. The algorithm wasnt at all practical, being of non-": null
    },
    {
        "elementary": "elementary"
    },
    {
        " complexity. To illustrate the immense resource consumptions of that algorithm, Lombardy and Sakarovitch give some actual numbers:          Notice that alone the number 10^ has 10 billion zeros when written down in ": null
    },
    {
        "decimal notation": "decimal notation"
    },
    {
        ", and is already by far larger than the ": null
    },
    {
        "number of atoms in the observable universe": "observable universematter content"
    },
    {
        ".     A much more efficient algorithm than Hashiguchis procedure was devised by Kirsten in 2005. This algorithm runs, for a given ": null
    },
    {
        "nondeterministic finite automaton": "nondeterministic finite automaton"
    },
    {
        " as input, within double-": null
    },
    {
        "exponential space": "expspace"
    },
    {
        ". Yet the resource requirements of this algorithm still greatly exceed the margins of what is considered practically feasible.     This algorithm has been optimized and generalized to trees by Colcombet and Löding in 2008 , as part of the theory of regular cost functions.   It has been implemented in 2017 in the tool suite Stamina. Nathanaël Fijalkow, Hugo Gimbert, Edon Kelmendi, Denis Kuperberg:  . CIAA 2017: 101-112 Tool available at ": null
    }
]