[
    {
        "   Object Linking & Embedding   is a ": null
    },
    {
        "proprietary": "proprietary format"
    },
    {
        " technology developed by ": null
    },
    {
        "Microsoft": "microsoft"
    },
    {
        " that allows embedding and ": null
    },
    {
        "linking": "hyperlinking"
    },
    {
        " to ": null
    },
    {
        "document": "document"
    },
    {
        "s and other objects. For developers, it brought OLE Control Extension , a way to develop and use custom user interface elements. On a technical level, an OLE object is any object that implements the IOleObject interface, possibly along with a wide range of other interfaces, depending on the objects needs.       OLE allows an editing application to export part of a document to another editing ": null
    },
    {
        "application": "software application"
    },
    {
        " and then import it with additional content. For example, a ": null
    },
    {
        "desktop publishing": "desktop publishing"
    },
    {
        " system might send some text to a ": null
    },
    {
        "word processor": "word processor"
    },
    {
        " or a picture to a ": null
    },
    {
        "bitmap editor": "bitmap editor"
    },
    {
        " using OLE. The main benefit of OLE is to add different kinds of data to a document from different applications, like a text editor and an image editor. This creates a ": null
    },
    {
        "Compound File Binary Format": "compound file binary format"
    },
    {
        " document and a master file to which the document makes reference. Changes to data in the master file immediately affect the document that references it. This is called linking .     OLE is also used for transferring data between different ": null
    },
    {
        "applications": "application software"
    },
    {
        " using ": null
    },
    {
        "drag and drop": "drag and drop"
    },
    {
        " and ": null
    },
    {
        "clipboard": "clipboard"
    },
    {
        " operations.             OLE 42, released in 42 was an evolution of the original ": null
    },
    {
        "Dynamic Data Exchange": "dynamic data exchange"
    },
    {
        " concept that ": null
    },
    {
        "Microsoft": "microsoft"
    },
    {
        " developed for earlier versions of ": null
    },
    {
        "Windows": "microsoft windows"
    },
    {
        ". While DDE was limited to transferring limited amounts of data between two running applications, OLE was capable of maintaining active links between two documents or even ": null
    },
    {
        "embedding": "compound document"
    },
    {
        " one type of document within another.     OLE servers and clients communicate with system libraries using ": null
    },
    {
        "virtual function table": "virtual function table"
    },
    {
        "s, or VTBLs. The VTBL consists of a structure of ": null
    },
    {
        "function pointer": "function pointer"
    },
    {
        "s that the system library can use to communicate with the server or client. The server and client libraries, OLESVR.DLL and OLECLI.DLL , were originally designed to communicate between themselves using the WM_DDE_EXECUTE message.     OLE 42 later evolved to become an architecture for ": null
    },
    {
        "software components": "software componentry"
    },
    {
        " known as the ": null
    },
    {
        "Component Object Model": "component object model"
    },
    {
        " , and later ": null
    },
    {
        "DCOM": "distributed component object model"
    },
    {
        ".     When an OLE object is placed on the clipboard or embedded in a document, both a visual representation in native Windows formats  is stored, as well as the underlying data in its own format. This allows applications to display the object without loading the application used to create the object, while also allowing the object to be edited, if the appropriate application is installed.     The Object Packager, a component of OLE, shipping from ": null
    },
    {
        "Windows 42": "windows 3.1"
    },
    {
        " up to ": null
    },
    {
        "Windows XP": "windows xp"
    },
    {
        " allows a non-OLE object to be packaged so it can be embedded into an OLE client.         OLE 42 was the next evolution of OLE, sharing many of the same goals as version 42, but was re-implemented on top of the COM instead of using VTBLs directly. New features were ": null
    },
    {
        "OLE automation": "ole automation"
    },
    {
        ", ": null
    },
    {
        "drag-and-drop": "drag-and-drop"
    },
    {
        ", ": null
    },
    {
        "in-place activation": "in-place activation"
    },
    {
        " and ": null
    },
    {
        "structured storage": "com structured storage"
    },
    {
        ". ": null
    },
    {
        "Monikers": "monikercomputer science"
    },
    {
        " evolved from OLE 42 object names, and provided a hierarchical object and resource naming system similar to ": null
    },
    {
        "URLs or URIs": "uri"
    },
    {
        ", which were independently invented. Windows now has merged the two technologies supporting a URL Moniker type, and a Moniker URL scheme.       OLE custom controls were introduced in 42 as a replacement for the now deprecated ": null
    },
    {
        "Visual Basic Extension": "visual basic extension"
    },
    {
        " controls. Instead of upgrading these, the new architecture was based on OLE. In particular, any container that supported OLE 42 could already embed OLE custom controls, although these controls cannot react to events unless the container supports this. OLE custom controls are usually shipped in the form of a ": null
    },
    {
        "dynamic link library": "dynamic link library"
    },
    {
        " with the .ocx extension. In 42 all interfaces for controls were made optional to keep the file size of controls down, so they would download faster; these were then called ": null
    },
    {
        "ActiveX Control": "activex control"
    },
    {
        "s.         OLE objects and containers are implemented on top of the ": null
    },
    {
        "Component Object Model": "component object model"
    },
    {
        "; they are objects that can implement interfaces to export their functionality. Only the IOleObject interface is compulsory, but other interfaces may also need to be implemented if the functionality exported by those interfaces is required.     To ease understanding of what follows, some terminology has to be explained. The view status of an object is whether the object is transparent, opaque, or opaque with a solid background, and whether it supports drawing with a specified aspect. The site of an object is an object representing the location of the object in its container. A container supports a site object for every object contained.     What follows is a list of interfaces, grouped by the object that usually needs to implement them. Interfaces usually implemented by the OLE object are usually called on by the OLE container, and vice versa. Note that in the following list indentation indicates interface inheritance. All non-indented interfaces derive from  IUnknown .       ;DataObject   :When implemented, enables the transfer of data, and notification of data changes. It must be implemented by objects that are to support drag-and-drop, being copied to or pasted from the clipboard, or being linked or embedded in a containing document.   ;ObjectWithSite   :Allows the caller to inform the OLE object of its site. This functionality is also provided by OleObject, but ObjectWithSite can be used, when supported, if OleObject is not used for other matters.   ;OleCache   :Allows visual presentations from a DataObject to be cached. This allows an embedded object to store its visual representation, thus enabling it to be displayed later without needing to start the application that was used to create the object.   :Usually the stock implementation is used.   :;OleCache42   ::Provides more fine-grained control over caching.   ::Usually the stock implementation is used.   ;OleCacheControl   :This interface is not called by the container, but internally by the object to allow it to receive notifications of when its DataObject is running, thereby allowing it to subscribe to notifications of data changes of that object and thus allowing it to update the cached presentation properly.   :Usually the stock implementation is used.   ;OleDocument   :Allows the OLE object to support multiple views of its data, as well as a few related functions.   ;OleDocumentView   :A document object  implements this interface for every view. It allows the caller to set the site of the object, query and set the size of the object and to show and activate it, as well as some related functions.   ;OleWindow   :;OleInPlaceActiveObject   ::Called by the outermost container of an object to interact with it while its active, e.g. to process accelerator keys in the containers message queue that are meant for the contained object.   :;OleInPlaceObject   ::Called by the container to activate or deactivate the object.   ::;IOleInPlaceObjectWindowless   :::A windowless object is an object that doesnt have its own window but it instead displayed in its containers window. It is used by the container to relay messages received by the containers window that are intended for the contained object. For example, if the mouse is moved over a window, Windows places a mouse move message along with the mouse coordinates in the message queue of the window. If this window contains windowless embedded objects, the message may have to be relayed to such an object if the coordinates of the mouse-pointer are over this object. For similar reasons this interface also provides access to the objects DropTarget interface.   ;OleLink   :Allows the object to support linking, e.g. by allowing the container to set the source of a linked object.   :Usually the stock implementation is used.   ;OleObject   :Arguably the most important interface for an OLE object. For example, it allows the container to inform the object of its site, initialize the object from data, to open and close it, to query and set the size of the object, to ask for notifications on the containers AdviseSink and to execute objects defined as verbs on the object. These verbs often include Open or Edit , but can also include other verbs. One of the verbs is defined to be the principal verb, and it is executed when the user double-clicks an object.   ;ViewObject   :Allows an object to draw itself directly, without passing a DataObject to the container. For objects that support both DataObject and this interface, the underlying implementation is usually shared.   :;ViewObject42   ::Additionally allows the caller to query the size of the object.   ::;ViewObjectEx   :::Adds support for flicker-free drawing of transparent objects, ": null
    },
    {
        "hit-testing": "hit-testing"
    },
    {
        " for objects with irregular shapes and setting the size of an object.       ;IAdviseSink   :Allows the implementer to receive notifications when the object is saved, closed, or renamed, or when its data or visual presentation changes.   :;IAdviseSink42   ::Additionally allows the implementer to receive notifications when the link source of the OLE object changes.   :;IAdviseSinkEx   ::Additionally allows the implementer to receive notifications when the view status of the OLE object changes.   ;IOleClientSite   :This interface allows the caller to obtain information on the container and location of an object, as well requesting that the object be saved, resized, shown, hidden, et cetera.   ;IOleDocumentSite   :Allows the caller to ask for the object on this site to be activated immediately. If this interface is implemented, IOleClientSite, IOleInPlaceSite and IAdviseSink must be implemented as well.   ;IOleContainer   :This interface allows the caller to enumerate embedded objects in a container, or to find such objects by name. It is primarily useful if the container wishes to support links to embedded objects.   ;IOleWindow   :;IOleInPlaceUIWindow   ::Enables embedded objects to negotiate space for toolbars on the containers window.   ::;IOleInPlaceFrame   :::Allows the caller to ask the container to insert its menu items in an empty menu that will become the cooperative menu. Also allows the caller to ask the container to show or hide this menu, to show or hide dialog boxes, and to process accelerator keys received by the contained object intended for the container.   :;IOleInPlaceSite   ::If a container implements this interface, it allows embedded objects to be activated in place, i.e. without opening in a separate window. It provides access to the containers IOleInPlaceUIWindow.   ::;IOleInPlaceSiteEx   :::If a container implements this interface, it allows embedded objects to check whether they need to redraw on activation or deactivation. It also allows them to request their UI to activate.   :::;IOleInPlaceSiteWindowless   ::::If a container wishes to support windowless embedded objects, it needs to provide functionality to embedded objects to replace the functionality normally provided by an embedded objects window. For example this interface provides a way to access the containers windows device context, thereby enabling the embedded object to draw in the containers window.   ;IOleUILinkContainer   :Contains the methods that the standard OLE dialog boxes that manage linked objects use to update linked objects in a container, or to query and change their sources. Used by the Links , Change source , Update links and Object properties dialog boxes.   :;IOleUILinkInfo   ::Additionally allows the dialog boxes to query when linked objects were last updated, and whether this was done automatically or manually.   :;IOleUIObjInfo   ::Contains the methods needed by the Object properties dialog box. For example if the user opens the Object properties dialog box and asks for the object to be converted to another type, a method on this interface is called.   ;IOleUndoManager   :Provides a centralized undo service to both the container itself and to embedded objects. When an undoable action is performed, an IOleUndoUnit is created and added to the IOleUndoManager       ;IDataAdviseHolder   :The methods of IDataObject that pertain to data change notifications can be implemented by calling the methods of this interface.   :Usually the stock implementation is used.   ;IOleAdviseHolder   :The methods of IOleObject that pertain to notifications can be implemented by calling the methods of this interface.   :Usually the stock implementation is used.   ;IDropSource   :Implemented by objects that can be dragged, i.e. that can be the source of a drag-and-drop operations. When implemented it allows the object to draw drag-and-drop effects, and to specify when the object is dropped, or the drag-and-drop operation is cancelled.   ;IDropTarget   :Implemented by objects that accept dropped objects, i.e. that can be the target of drag-and-drop operations. When implemented it allows the target to specify if a dropped object will be accepted, and what happens to an object after it is dropped.   ;IOleCommandTarget   :Can be implemented by objects that wish to support certain standard commands. It allows callers to query if commands are supported, and to execute commands. Commands that an object might typically wish to implement may include things like delete , cut , copy , paste , undo , find , print , save , zoom , and so on. Currently 42 standard commands have been defined, and they include commands commonly used by office software, web browsers and similar applications.   ;IOleUndoUnit   :Represents an action that can be undone. It contains all information necessary to undo an action. It is created by objects and containers, so that undoable actions can be added to the containers IOleUndoManager.   :;IOleParentUndoUnit   ::Allows an undo unit to contain other undo units. In essence this allows the undo unit to act as an undo stack, grouping undo units together. For example, if a macro is run, all undo-able actions performed by the macro may be grouped together in one undo unit.   ;IOleWindow   :This interface represents a window of a container or contained object. It allows callers to obtain the handle of the window, and to toggle the context-sensitive help function. When the context-sensitive help function is turned on, typically the mouse-pointer changes to an arrow with a question mark to indicate that clicking a user interface element will result in opening a help window.       ": null
    },
    {
        "OpenDoc": "opendoc"
    },
    {
        " technology tried to compete with OLE. Some of Microsofts competitors considered OpenDoc to be more robust and easier to use; however, OpenDoc ": null
    },
    {
        "does have some known problems": "opendocproblems"
    },
    {
        ". OpenDoc allowed users to view and edit information across applications, directly in competition with Microsofts proprietary OLE standard. In 42 some Microsoft competitors established a consortium called the Component Integration Laboratories to develop OpenDoc as an ": null
    },
    {
        "open standard": "open standard"
    },
    {
        " for cross-platform linking and embedding.       Microsoft required OLE compatibility as a condition of Microsofts certification of an applications compatibility with ": null
    },
    {
        "Windows 42": "windows 95"
    },
    {
        ". Microsoft initially announced that applications using OpenDoc would be deemed compatible with OLE, and would receive certification for Windows 42 Microsoft later reversed the decision and said that applications using OpenDoc might not receive certification at all. Microsoft withheld specifications and debugged versions of OLE until after it had released its competing applications.       Use of Microsoft Object Linking and Embedding objects limits interoperability, because these objects are not widely supported in programs for viewing or editing files .      If software that understands an OLE object is not available, the object is usually replaced by a picture or not displayed at all.   ": null
    }
]