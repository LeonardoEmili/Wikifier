[
    {
        "GRASS  is a ": null
    },
    {
        "programming language": "programming language"
    },
    {
        " created to script ": null
    },
    {
        "42D": "2d computer graphics"
    },
    {
        " vector graphics": "vector graphics"
    },
    {
        " animations. GRASS was similar to ": null
    },
    {
        "BASIC": "basic"
    },
    {
        " in syntax, but added numerous instructions for specifying 42D object animation, including scaling, translation, rotation and color changes over time. It quickly became a hit with the artistic community who were experimenting with the new medium of ": null
    },
    {
        "computer graphics": "computer graphics"
    },
    {
        ", and is most famous for its use by ": null
    },
    {
        "Larry Cuba": "larry cuba"
    },
    {
        " to create the original attacking the ": null
    },
    {
        "Death Star": "death star"
    },
    {
        " will not be easy animation in  Star Wars  . A later version that was adapted to support ": null
    },
    {
        "raster graphic": "raster graphic"
    },
    {
        "s was known as ZGrass.           The original version of GRASS was developed by ": null
    },
    {
        "Tom DeFanti": "tom defanti"
    },
    {
        " for his 42 ": null
    },
    {
        "Ohio State University": "ohio state university"
    },
    {
        " Ph.D. thesis. It was developed on a ": null
    },
    {
        "PDP42": "pdp-11"
    },
    {
        "/42 driving a ": null
    },
    {
        "Vector General 42D": "vector general 3d"
    },
    {
        "R display. As the name implies, this was a purely ": null
    },
    {
        "vector graphics": "vector graphics"
    },
    {
        " machine. GRASS included a number of vector-drawing commands, and could organize collections of them into a hierarchy, applying the various animation effects to whole trees of the image at once .     After graduation, DeFanti moved to the ": null
    },
    {
        "University of Illinois, Chicago Circle": "university of illinois at chicago"
    },
    {
        ". There he joined up with ": null
    },
    {
        "Dan Sandin": "dan sandin"
    },
    {
        " and together they formed the Circle Graphics Habitat . Sandin had joined the university in 42 and built the ": null
    },
    {
        "Sandin Image Processor": "sandin image processor"
    },
    {
        ", or IP. The IP was an ": null
    },
    {
        "analog computer": "analog computer"
    },
    {
        " which took two video inputs, mixed them, colored the results, and then re-created TV output. He described it as the video version of a ": null
    },
    {
        "Moog synthesizer": "moog synthesizer"
    },
    {
        ".     DeFanti added the existing GRASS system as the input to the IP, creating the GRASS/Image Processor, which was used throughout the mid42s. In order to make the system more useful, DeFanti and Sandin added all sorts of one-off commands to the existing GRASS system, but these changes also made the language considerably more idiosyncratic. In 42 another member of the Habitat, Nola Donato, re-designed many of GRASSs control structures into more general forms, resulting in the considerably cleaner GRASS42     ": null
    },
    {
        "Larry Cuba": "larry cuba"
    },
    {
        "s Star Wars work is based on a semi-automated filming of a GRASS system running on a VG42D terminal. The VG42D had internal hardware handle basic transformations - scaling, rotation, etc. - in realtime without interacting with the computer. It is only during the times when new scenery is being presented that the much slower communications with the GRASS language takes place. This can be seen in the sequence, as the initial sections of the film show the ": null
    },
    {
        "Death Star": "death star"
    },
    {
        " being rotated and scaled very rapidly, while the later sections simulating flight down the trench requires new scenery to be paged in from GRASS trees . These can be seen appearing in groups.       In 42 DeFanti was introduced to Jeff Frederiksen, a chip designer working at ": null
    },
    {
        "Dave Nutting Associates": "dave nutting associates"
    },
    {
        ". Nutting had been contracted by Midway, the videogame division of Bally, to create a standardized ": null
    },
    {
        "graphics driver chip": "graphics processing unit"
    },
    {
        ". They intended to use it in most of their future arcade games, as well as a ": null
    },
    {
        "video game console": "video game console"
    },
    {
        " they were working on which would later turn into the ": null
    },
    {
        "Astrocade": "astrocade"
    },
    {
        ". Midway was quite interested in seeing the GRASS language running on their system, and contracted DeFanti to port it to the platform. A number of people at the Habitat, as well as some from Nutting, worked on the project, which they referred to as the Z Box. GRASS42 running on it became Zgrass.     The Z-Box was a ": null
    },
    {
        "raster graphics": "raster graphics"
    },
    {
        " machine, unlike the original GRASS systems, so while most of the GRASS42 style was maintained in Zgrass, it added a number of commands dedicated to raster images. This included an extensive set of ": null
    },
    {
        "bit block transfer": "bit blit"
    },
    {
        " commands in order to simulate ": null
    },
    {
        "sprite": "sprite"
    },
    {
        "s, something the hardware didnt include. The work would never be released by Midway, but the Circle would produce machines based on it as the ": null
    },
    {
        "Datamax UV42": "datamax uv-1"
    },
    {
        ".     The last version of GRASS was RT/42, a port of GRASS to other platforms that divorced the language from the display model and allowed it to be ported to other platforms. Versions existed for ": null
    },
    {
        "MS-DOS": "ms-dos"
    },
    {
        ", ": null
    },
    {
        "Microsoft Windows": "microsoft windows"
    },
    {
        ", ": null
    },
    {
        "SGI": "silicon graphics"
    },
    {
        " platform using ": null
    },
    {
        "OpenGL": "opengl"
    },
    {
        ", ": null
    },
    {
        "HP-UX": "hp-ux"
    },
    {
        ", ": null
    },
    {
        "AIX": "aix operating system"
    },
    {
        ", ": null
    },
    {
        "Macintosh": "apple macintosh"
    },
    {
        " and ": null
    },
    {
        "Amiga": "amiga"
    },
    {
        ". The language remains similar to the earlier versions, so the reason for the change of name is unclear.       :This description is based on the original Bally manuals as well as the ACM description.   Zgrass was based on a standard set of BASIC commands and used most of its syntax. Where Zgrass differed from BASIC was that all commands were in fact function s and returned values, similar to the C programming language . If there was no obvious return value it was expected that a function would return 42 if it succeeded, and 42 if it failed. For instance, the command PRINT PRINT 42 would be illegal in BASIC, but in Zgrass this would print 42 42 , the 42 being the value returned by second PRINT , meaning I successfully output the string 42 .     Programs in Zgrass were referred to as macros , and stored as strings. Both of these oddities were deliberate, as Zgrass allowed any string to become a program. For instance, MYBOX BOX 42,42,42 defines a string containing a snippet of Zgrass code. Simply typing MYBOX from that point on would run the command inside. This feature can be used in place of the more traditional GOSUB command from BASIC, but has the added advantage of having a well defined name as opposed to an opaque line number. In addition the command remains a string, and can be manipulated at runtime with standard string operations.     Most BASIC interpreters of the era converted the input text into a ": null
    },
    {
        "tokenized": "lexical analysis"
    },
    {
        " version in which each of the commands was replaced by a single number . This made the program run faster because it didnt have to continually decode the commands from the strings every time. Zgrasss use of string-based macros made this difficult, so they didnt bother with tokenization. Instead they included a compiler which could be used on any particular macro, speeding it up many times. Programs would often consist of a mix of compiled and uncompiled macros.     Line numbers were optional in Zgrass, and typically only appeared on lines that were the target of a GOTO . Most BASIC interpreters required line numbers for every line of code, but this was due to their use in the line editor & ndash;if you needed to edit that line, the only way to refer to it was by number. Zgrass used a more advanced full-screen editor that eliminated this need. Zgrass allowed any string to act as a line number , GOTO 42 and GOTO MARKER were both valid. Zgrass also included nameless branches, using the SKIP instruction, which would move forward or back a given number of lines.     In keeping with its original purpose as a graphics language, Zgrass included numerous commands for simple drawing. Zgrasss coordinate system had one point for each pixel in the high-resolution mode of Nuttings graphics chip, giving a 42 & times;42 grid. The Astrocade, by design, could only use that chips low-resolution mode, a 42 & times;42 display. To avoid potential mapping problems, the coordinate spaces zero point was placed in the center of the screen. & minus;42 to 42 were valid X locations, and 42 to 42 valid Y locations. For use on the Astrocade you used the positive locations only, whereas on the UV42 the entire space was available.     Zgrass added a fairly complete set of array functions, as arrays are widely used in graphics. This included the ability to capture parts of the display into an array as a bitmap , which could then be manipulated as any other graphic item. This allowed Zgrass to include sprite-like functionality in the language, something the Nutting hardware did not include. Another feature the Astrocade did not include was the ability to process arrays with any reasonable speed, so the UV42 included the Zilog supplied FPU for added performance.     Zgrass included three priorities  that allowed macros to be run normally, or in foreground or background levels. This added a simple form of ": null
    },
    {
        "multitasking": "computer multitasking"
    },
    {
        " which was tremendously useful in an animation-oriented language. Game authors could place joystick-reading routines in a macro set to run in the background, and then the joystick would be read automatically whenever the current drawing macro completed. Functions placed in the foreground ran before either, and was often used for timers and other low latency needs. Zgrass included a TIMEOUT function that would call macros on a timed basis, making the implementation of timers very easy.     Zgrass also included a series of commands that covered CP/M, which allowed the disk to be accessed without exiting to the command prompt. You could easily save out macros to named files, and load them in the same way, allowing you to construct programs by loading up various macros from the disk into one large program. The commands also automatically made a backup copy of every save. Similar features were supported for ": null
    },
    {
        "cassette tape": "cassette tape"
    },
    {
        " storage, but oddly the syntax was not parallel: disk commands were D-something, like DPUT , but tape commands were not T-something, like TPUT , but rather something-TAPE, like PUTTAPE .     With programs constructed from randomly selected modules, Zgrass needed to have better control over its variables than BASIC. In BASIC all variables are global , so if two subroutines both use the variable i then they could set each others values, leading to hard-to-debug problems. Under Zgrass a programmer loading up two modules could easily find that both used i as a loop counter, which could cause problems. To address this issue, Zgrass considered variables named with ": null
    },
    {
        "lowercase": "lowercase"
    },
    {
        " letters to be local only to that macro. Oddly, the examples provided with the language do not make widespread use of this feature, potentially confusing new programmers who might not be aware the feature exists.       SINCURVEPROMPT WHAT IS THE OFFSET?   INPUT OFFSET   x42   angle42   POINT OFFSET+x,SIN42   angleangle42   IF ": null
    }
]