[
    {
        "        In ": null
    },
    {
        "computing": "computing"
    },
    {
        " and ": null
    },
    {
        "electronic": "electronics"
    },
    {
        " systems, binary-coded decimal  is a class of ": null
    },
    {
        "binary": "binary numeral system"
    },
    {
        " encodings of ": null
    },
    {
        "decimal": "decimal"
    },
    {
        " numbers where each decimal ": null
    },
    {
        "digit": "numerical digit"
    },
    {
        " is represented by a fixed number of ": null
    },
    {
        "bit": "bit"
    },
    {
        "s, usually four or eight. Special bit patterns are sometimes used for a ": null
    },
    {
        "sign": "sign"
    },
    {
        " or for other indications .     In byte-oriented systems , the term unpacked BCD usually implies a full ": null
    },
    {
        "byte": "byte"
    },
    {
        " for each digit , whereas packed BCD typically encodes two decimal digits within a single byte by taking advantage of the fact that four bits are enough to represent the range 0 to 9. The precise 4-bit encoding may vary however, for technical reasons, see ": null
    },
    {
        "Excess-3": "excess-3"
    },
    {
        " for instance. The ten states representing a BCD decimal digit are sometimes called tetrades  with those ": null
    },
    {
        "dont care": "dont care"
    },
    {
        "-states unused named  or pseudo-decimal digit such as ": null
    },
    {
        "ARM": "arm architecture"
    },
    {
        "; ": null
    },
    {
        "x86": "x86"
    },
    {
        " does not support ": null
    },
    {
        "its BCD instructions": "intel bcd opcode"
    },
    {
        "in ": null
    },
    {
        "long mode": "long mode"
    },
    {
        " any more": null
    },
    {
        "themati": "themati"
    },
    {
        " two encodings are possible6+39bits 0 through 3bits 4 through 7but formatting routines might replace or remove leading zeroswith the leading zero": null
    },
    {
        "mputi": "mputi"
    },
    {
        "or simply packed decimalresiding at the lowest memory address": null
    },
    {
        "hex": "hexadecimal"
    },
    {
        " C+Dâˆ’AEBABFFD127C127DDthe processors will normalize a positive sign to 1100  ": null
    },
    {
        "ta ty": "ta ty"
    },
    {
        "2nd+132-bitabout one-sixth of the memory used is wasted": null
    },
    {
        "aracter encodi": "aracter encodi"
    },
    {
        "an IBM extension adopted by many other compiler vendorspart of the 1985 COBOL standarddescended from the 1950s ": null
    },
    {
        "Electrodata 200 series": "burroughs 205"
    },
    {
        "and otherinclusiveAs with ": null
    },
    {
        "twos complement": "twos complement"
    },
    {
        " binary numbers, the range is not symmetric about zero.such as ": null
    },
    {
        "COBOL": "cobol"
    },
    {
        ", ": null
    },
    {
        "PL/I": "pl/i"
    },
    {
        " and ": null
    },
    {
        "Ada": "ada"
    },
    {
        "1,0241,000DPDhex Fhexhex 3hexleast significantsee above such as ": null
    },
    {
        "COBOL": "cobol"
    },
    {
        " and ": null
    },
    {
        "PL/I": "pl/i"
    },
    {
        "BCDIC, sometimes just called BCD": null
    },
    {
        "70/7072/70": "70/7072/70"
    },
    {
        "CMa 0 punch combined with any others12,1B,A,111,8,3B,8,2,18,2using ": null
    },
    {
        "two-out-of-five code": "two-out-of-five code"
    },
    {
        " in the digits, not BCDe.g., lowercase lettersas in EBCDIC or ASCIItwo decimal digits per ": null
    },
    {
        "byte": "byte"
    },
    {
        "one decimal digit stored as BCD in the low four bits of each byte": null
    },
    {
        "n-by": "n-by"
    },
    {
        "written in ": null
    },
    {
        "C": "c"
    },
    {
        "uint32_t a,uint32_t b   uint32_t t1, t2; // unsigned 32-bit intermediate values     t1 a + 0x06666666;   t2 t1 ^ b; // sum without carry propagation   t1 t1 + b; // provisional sum   t2 t1 ^ t2; // all the binary carry bits   t2 ~t2 & 0x11111110; // just the BCD carry bits   t2 ": null
    }
]