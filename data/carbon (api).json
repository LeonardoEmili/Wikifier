[
    {
        "     Carbon is one of ": null
    },
    {
        "Apple": "apple inc."
    },
    {
        "’s ": null
    },
    {
        "C-based": "c"
    },
    {
        " application programming interface": "application programming interface"
    },
    {
        "s for ": null
    },
    {
        "macOS": "macos"
    },
    {
        " , the ": null
    },
    {
        "operating system": "operating system"
    },
    {
        " that powers ": null
    },
    {
        "Macintosh": "macintosh"
    },
    {
        " computers. Carbon provided a good degree of ": null
    },
    {
        "backward compatibility": "backward compatibility"
    },
    {
        " for ": null
    },
    {
        "program": "computer program"
    },
    {
        "s that ran on ": null
    },
    {
        "Mac OS 42": "mac os 8"
    },
    {
        " and ": null
    },
    {
        "42": "mac os 9"
    },
    {
        ". Developers could use the Carbon APIs to port their ": null
    },
    {
        "“classic” Mac": "classic mac os"
    },
    {
        " software to the Mac OS X platform with little effort, compared to ": null
    },
    {
        "porting": "porting"
    },
    {
        " the app to the entirely different ": null
    },
    {
        "Cocoa": "cocoa"
    },
    {
        " system, which originated in ": null
    },
    {
        "OPENSTEP": "openstep"
    },
    {
        ".     Carbon was an important part of Apples strategy for bringing Mac OS X to market, offering a path for quick porting of existing software applications, as well as a means of shipping applications that would run on either Mac OS X or the classic Mac OS. As the market has increasingly moved to the Cocoa-based frameworks, especially after the release of ": null
    },
    {
        "iOS": "ios"
    },
    {
        ", the need for a porting library was diluted. Apple did not create a ": null
    },
    {
        "42-bit": "64-bit"
    },
    {
        " version of Carbon while updating their other frameworks in the 42 time-frame, and eventually ": null
    },
    {
        "deprecated": "deprecated"
    },
    {
        " the entire API in ": null
    },
    {
        "OS X 42 Mountain Lion": "os x mountain lion"
    },
    {
        ", which was released on July 42 42 Carbon was officially discontinued and removed entirely with the release of ": null
    },
    {
        "macOS 42 Catalina": "macos catalina"
    },
    {
        ".              The ": null
    },
    {
        "original Mac OS": "classic mac os"
    },
    {
        " used ": null
    },
    {
        "Pascal": "pascal"
    },
    {
        " as its primary development platform, and the APIs were heavily based on Pascals ": null
    },
    {
        "call semantics": "call semantics"
    },
    {
        ". Much of the ": null
    },
    {
        "Macintosh Toolbox": "macintosh toolbox"
    },
    {
        " consisted of ": null
    },
    {
        "procedure calls": "subroutine"
    },
    {
        ", passing information back and forth between the API and program using a variety of ": null
    },
    {
        "data structure": "data structure"
    },
    {
        "s based on Pascals ": null
    },
    {
        "variant record": "variant record"
    },
    {
        " concept.     Over time, a number of ": null
    },
    {
        "object libraries": "object library"
    },
    {
        " evolved on the Mac, notably the ": null
    },
    {
        "Object Pascal": "object pascal"
    },
    {
        " library ": null
    },
    {
        "MacApp": "macapp"
    },
    {
        " and the ": null
    },
    {
        "Think Class Library": "think c"
    },
    {
        " in Pascal, and later versions of MacApp and ": null
    },
    {
        "CodeWarrior": "codewarrior"
    },
    {
        "s PowerPlant in ": null
    },
    {
        "C++": "c++"
    },
    {
        ". By the mid42s, most Mac software was written in C++ using CodeWarrior.       With the purchase of ": null
    },
    {
        "NeXT": "next"
    },
    {
        " in late 42 Apple developed a new operating system strategy based largely on the existing ": null
    },
    {
        "OpenStep": "openstep"
    },
    {
        " platform. The new ": null
    },
    {
        "Rhapsody": "rhapsody"
    },
    {
        " was relatively simple; it retained most of OpenSteps existing object libraries under the name Yellow Box , ported OpenSteps existing ": null
    },
    {
        "GUI": "gui"
    },
    {
        " and made it look more Mac-like, ported several major ": null
    },
    {
        "API": "api"
    },
    {
        "s from the Mac OS to Rhapsodys underlying ": null
    },
    {
        "Unix-like": "unix-like"
    },
    {
        " system , and added an emulator known as the Blue Box that ran existing Mac OS software.     When this plan was unveiled at the ": null
    },
    {
        "Worldwide Developers Conference": "worldwide developers conference"
    },
    {
        " in 42 there was some push-back from existing Mac OS developers, who were upset that their code bases would effectively be locked into an emulator that was unlikely to ever be updated. They took to calling the Blue Box the penalty box . Larger developers like ": null
    },
    {
        "Microsoft": "microsoft"
    },
    {
        " and ": null
    },
    {
        "Adobe": "adobe systems"
    },
    {
        " balked outright, and refused to consider porting to OpenStep, which was so different from the existing Mac OS that there was little or no compatibility.     Apple took these concerns to heart. When ": null
    },
    {
        "Steve Jobs": "steve jobs"
    },
    {
        " announced this change in direction at the 42 WWDC, he stated that what developers really wanted was a modern version of the Mac OS, and Apple going to deliver it . The statement was met with thunderous applause.     The original Rhapsody concept, with only the Blue Box for running existing Mac OS software, was eventually released in 42 as ": null
    },
    {
        "Mac OS X Server 42": "mac os x server 1.0"
    },
    {
        ". This was the only release based on the original Rhapsody concept.       In order to offer a real and well supported upgrade path for existing Mac OS code bases, Apple introduced the Carbon system. Carbon consists of many libraries and functions that offer a Mac-like API, but running on top of the underlying Unix-like OS, rather than a copy of the Mac OS running in emulation. The Carbon libraries are extensively cleaned up, modernized and better protected . While the Mac OS was filled with APIs that shared memory to pass data, under Carbon all such access was re-implemented using ": null
    },
    {
        "accessor": "mutator method"
    },
    {
        " subroutine": "subroutine"
    },
    {
        "s on ": null
    },
    {
        "opaque data type": "opaque data type"
    },
    {
        "s. This allowed Carbon to support true ": null
    },
    {
        "multitasking": "multitasking"
    },
    {
        " and ": null
    },
    {
        "memory protection": "memory protection"
    },
    {
        ", features Mac developers had been requesting for a decade. Other changes from the pre-existing API removed features which were conceptually incompatible with Mac OS X, or simply obsolete. For example, applications could no longer install ": null
    },
    {
        "interrupt handler": "interrupt handler"
    },
    {
        "s or ": null
    },
    {
        "device driver": "device driver"
    },
    {
        "s.     In order to support Carbon, the entire Rhapsody model changed. Whereas Rhapsody would effectively be OpenStep with an emulator, under the new system both the OpenStep and Carbon API would, where possible, share common code. To do this, many of the useful bits of code from the lower-levels of the OpenStep system, written in Objective-C and known as Foundation, were re-implemented in pure C. This code became known as ": null
    },
    {
        "Core Foundation": "core foundation"
    },
    {
        ", or CF for short. A version of the Yellow Box ported to call CF became the new ": null
    },
    {
        "Cocoa": "cocoa"
    },
    {
        " API, and the Mac-like calls of Carbon also called the same functions. Under the new system, Carbon and Cocoa were peers. This conversion would normally have slowed the performance of Cocoa as the object methods called into the underlying C libraries, but Apple used a technique they called toll-free bridging  to reduce this impact.      As part of this conversion, Apple also ported the ": null
    },
    {
        "graphics engine": "2d computer graphics"
    },
    {
        " from the licence-encumbered ": null
    },
    {
        "Display PostScript": "display postscript"
    },
    {
        " to the licence-free ": null
    },
    {
        "Quartz": "quartz"
    },
    {
        " .  Quartz provided native calls that could be used from either Carbon or Cocoa, as well as offering ": null
    },
    {
        "Java 42D": "java 2d"
    },
    {
        "-like interfaces as well. The underlying operating system itself was further isolated and released as ": null
    },
    {
        "Darwin": "darwin"
    },
    {
        ".       Carbon was introduced in incomplete form in 42 as a shared library backward-compatible with 42s Mac OS 42. This version allowed developers to port their code to Carbon without losing the ability for those programs to run on existing Mac OS machines. Porting to Carbon became known as Carbonization . Official Mac OS X support arrived in 42 with the release of ": null
    },
    {
        "Mac OS X v42": "mac os x v10.0"
    },
    {
        ", the first public version of the new OS. Carbon was very widely used in early versions of Mac OS X by almost all major software houses, even by Apple. The ": null
    },
    {
        "Finder": "finder"
    },
    {
        ", for instance, remained a Carbon application for many years, only being ported to Cocoa with the release of Mac OS 42 in 42      The transition to ": null
    },
    {
        "42-bit": "64-bit computing"
    },
    {
        " Macintosh applications beginning with ": null
    },
    {
        "Mac OS X v42": "mac os x leopard"
    },
    {
        ", released October 42 42 brought the first major limitations to Carbon. Apple does not provide compatibility between the Macintosh ": null
    },
    {
        "graphical user interface": "graphical user interface"
    },
    {
        " and the C programming language in the 42-bit environment, instead requiring the use of the ": null
    },
    {
        "Objective-C": "objective-c"
    },
    {
        " dialect with the Cocoa API.  Many commentaries took this to be the first sign of Carbons eventual disappearance, a position that was re-enforced when Apple stated no new major additions would be added to the Carbon system,  and further reinforced with its deprecation in 42       Despite the purported advantages of Cocoa, the need to rewrite large amounts of legacy code slowed the transition of Carbon-based applications, famously with ": null
    },
    {
        "Adobe Photoshop": "adobe photoshop"
    },
    {
        ",  which was eventually updated to Cocoa in April 42 This also extended to Apples own flagship software packages, as ": null
    },
    {
        "iTunes": "itunes"
    },
    {
        "  and ": null
    },
    {
        "Final Cut Pro": "final cut pro"
    },
    {
        "  remained written in Carbon for many years. Both iTunes and Final Cut Pro X have since been released in Cocoa versions.       In 42 with the release of OS X 42 Mountain Lion, most Carbon APIs were considered deprecated. The APIs are still accessible to developers and all Carbon applications will run, but the APIs will no longer be updated. On June 42 42 Apple announced that 42-bit software for macOS, such as all Carbon applications, would no longer be supported “without compromise” on versions of macOS after ": null
    },
    {
        "macOS 42 High Sierra": "macos high sierra"
    },
    {
        ".  ": null
    },
    {
        "macOS 42 Catalina": "macos catalina"
    },
    {
        " officially removes support for 42-bit applications, and thus all Carbon applications are no longer supported as well.        Carbon descends from the ": null
    },
    {
        "Toolbox": "macintosh toolbox"
    },
    {
        ", and as such, is composed of Managers . Each Manager is a functionally related API, defining sets of data structures and functions to manipulate them. Managers are often interdependent or layered. Carbon consists of a broad set of functions for managing files, memory, data, the user interface, and other system services. It is implemented as any other API: in macOS, it is spread over several frameworks , principally Carbon.framework , ApplicationServices.framework , and CoreServices.framework , and in classic Mac OS, it resides in a single shared library named CarbonLib .     As an ": null
    },
    {
        "umbrella term": "umbrella term"
    },
    {
        " encompassing all C-language API procedures accessing Mac-specific functionality, Carbon is not designed as a discrete system. Rather, it opens nearly all the functionality of macOS to developers who do not know the ": null
    },
    {
        "Objective-C": "objective-c"
    },
    {
        " language required for the broadly equivalent ": null
    },
    {
        "Cocoa API": "cocoa"
    },
    {
        ".      Carbon is compatible with all of the several ": null
    },
    {
        "executable format": "object file"
    },
    {
        "s available for PowerPC Mac OS. Binary compatibility between Mac OS X and previous versions requires use of a ": null
    },
    {
        "Preferred Executable Format": "preferred executable format"
    },
    {
        " file, which Apple never supported in their ": null
    },
    {
        "Xcode": "xcode"
    },
    {
        " IDE": "integrated development environment"
    },
    {
        ".     Newer parts of Carbon tend to be much more object-oriented in their conception, most of them based on ": null
    },
    {
        "Core Foundation": "core foundation"
    },
    {
        ". Some Managers, such as the HIView Manager , are implemented in ": null
    },
    {
        "C++": "c++"
    },
    {
        ", but Carbon remains a ": null
    },
    {
        "C": "c"
    },
    {
        " API.     Some examples of Carbon Managers:     File Manager & mdash; manages access to the file system, opening, closing, reading and writing files.   Resource Manager & mdash; manages access to resources, which are predefined chunks of data a program may require. Calls File Manager to read and write resources from disk files. Examples of resources include icons, sounds, images, templates for widgets, etc.   Font Manager & mdash; manages ": null
    },
    {
        "font": "typeface"
    },
    {
        "s. Deprecated  since ": null
    },
    {
        "Mac OS X v42": "mac os x tiger"
    },
    {
        ", in favor of ": null
    },
    {
        "Apple Type Services": "apple type services"
    },
    {
        " .   ": null
    },
    {
        "QuickDraw": "quickdraw"
    },
    {
        " & mdash; 42D graphics primitives. Deprecated since ": null
    },
    {
        "Mac OS X v42": "mac os x tiger"
    },
    {
        ", in favor of Quartz 42D.   Carbon Event Manager & mdash; converts user and system activity into events that code can recognise and respond to.   HIObject & mdash; a completely new object-oriented API which brings to Carbon an ": null
    },
    {
        "OO": "object-oriented programming"
    },
    {
        " model for building GUIs. HIToolbox in Mac OS Classic and ": null
    },
    {
        "Copland": "copland"
    },
    {
        "  relied on abandoned ": null
    },
    {
        "IBM System Object Model": "ibm system object model"
    },
    {
        ", so Carbon had to provide quick-and-dirty replacement to enable porting of legacy code. This is available in ": null
    },
    {
        "Mac OS X v42": "mac os x v10.2"
    },
    {
        " or later, and gives Carbon programmers some of the tools that Cocoa developers have long been familiar with. Starting with ": null
    },
    {
        "Mac OS X v42": "mac os x v10.2"
    },
    {
        ", HIObject is the base class for all GUI elements in Carbon. HIView is supported by ": null
    },
    {
        "Interface Builder": "interface builder"
    },
    {
        ", part of Apples developer tools. Traditionally GUI architectures of this sort have been left to third-party application frameworks to provide. Starting with Mac OS X v42, HIObjects are NSObjects and inherit the ability to be serialized into data streams for transport or saving to disk.   HITheme & mdash; uses QuickDraw and Quartz to render ": null
    },
    {
        "graphical user interface": "graphical user interface"
    },
    {
        " elements to the screen. HITheme was introduced in ": null
    },
    {
        "Mac OS X v42": "mac os x v10.3"
    },
    {
        ", and Appearance Manager is a compatibility layer on top of HITheme since that version.   HIView Manager & mdash; manages creation, drawing, ": null
    },
    {
        "hit-testing": "hit-testing"
    },
    {
        ", and manipulation of controls. Since Mac OS X v42, all controls are HIViews. In Mac OS X v42, the Control Manager was renamed HIView Manager.   Window Manager & mdash; manages creation, positioning, updating, and manipulation of windows. Since Mac OS X v42, windows have a root HIView.   Menu Manager & mdash; manages creation, selection, and manipulation of menus. Since Mac OS X v42, menus are HIObjects. Since Mac OS X v42, menu content may be drawn using HIViews, and all standard menus use HIViews to draw.       The Mac Toolboxs Event Manager originally used a ": null
    },
    {
        "polling": "polling"
    },
    {
        " model for application design. The applications main ": null
    },
    {
        "event loop": "event loop"
    },
    {
        " asks the Event Manager for an event using GetNextEvent. If there is an event in the queue, the Event Manager passes it back to the application, where it is handled, otherwise it returns immediately. This behavior is called ": null
    },
    {
        "busy-waiting": "busy waiting"
    },
    {
        " , running the event loop unnecessarily. Busy-waiting reduces the amount of CPU time available for other applications and decreases battery power on laptops. The classic Event Manager dates from the original Mac OS in 42 when whatever application was running was guaranteed to be the only application running, and where power management was not a concern.     With the advent of MultiFinder and the ability to run more than one application simultaneously came a new Event Manager call, WaitNextEvent, which allows an application to specify a sleep interval. One easy trick for legacy code to adopt a more efficient model without major changes to its source code is simply to set the sleep parameter passed to WaitNextEvent to a very large value—on macOS, this puts the thread to sleep whenever there is nothing to do, and only returns an event when there is one to process. In this way, the polling model is quickly inverted to become equivalent to the callback model, with the application performing its own event dispatching in the original manner. There are loopholes, though. For one, the legacy toolbox call ModalDialog, for example, calls the older GetNextEvent function internally, resulting in polling in a tight loop without blocking.     Carbon introduces a replacement system, called the Carbon Event Manager. . Carbon Event Manager provides the event loop for the developer ; the developer sets up event handlers and enters the event loop in the main function, and waits for Carbon Event Manager to dispatch events to the application.       In the classic Mac OS, there was no operating system support for application level timers . Timers were usually left to application developers to implement, and this was usually done by counting elapsed time during the idle event - that is, an event that was returned by WaitNextEvent when any other event wasnt available. In order for such timers to have reasonable resolution, developers could not afford WaitNextEvent": null
    }
]