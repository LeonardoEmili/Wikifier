[
    {
        "   In ": null
    },
    {
        "computability theory": "computability theory"
    },
    {
        " and ": null
    },
    {
        "computational complexity theory": "computational complexity theory"
    },
    {
        ", a decision problem is a problem that can be posed as a ": null
    },
    {
        "yes-no question": "yes-no question"
    },
    {
        " of the input values. An example of a decision problem is deciding whether a given natural number is ": null
    },
    {
        "prime": "prime"
    },
    {
        ". Another is the problem given two numbers x and y, does x evenly divide y? . The answer is either yes or no depending upon the values of x and y. A method for solving a decision problem, given in the form of an ": null
    },
    {
        "algorithm": "algorithm"
    },
    {
        ", is called a decision procedure for that problem. A decision procedure for the decision problem given two numbers x and y, does x evenly divide y? would give the steps for determining whether x evenly divides y. One such algorithm is ": null
    },
    {
        "long division": "long division"
    },
    {
        ". If the remainder is zero the answer is yes, otherwise it is no. A decision problem which can be solved by an algorithm is called decidable.     Decision problems typically appear in mathematical questions of ": null
    },
    {
        "decidability": "decidability"
    },
    {
        ", that is, the question of the existence of an ": null
    },
    {
        "effective method": "effective method"
    },
    {
        " to determine the existence of some object or its membership in a set; some of the most important problems in mathematics are ": null
    },
    {
        "undecidable": "undecidable problem"
    },
    {
        ".     The field of computational complexity categorizes decidable decision problems by how difficult they are to solve. Difficult , in this sense, is described in terms of the ": null
    },
    {
        "computational resources": "computational resource"
    },
    {
        "needed by the most efficient algorithm for a certain problem. The field of ": null
    },
    {
        "recursion theory": "recursion theory"
    },
    {
        ", meanwhile, categorizes undecidable decision problems by ": null
    },
    {
        "Turing degree": "turing degree"
    },
    {
        ", which is a measure of the noncomputability inherent in any solution.       A decision problem is a yes-or-no question on an ": null
    },
    {
        "infinite set": "infinite set"
    },
    {
        " of inputs. It is traditional to define the decision problem as the set of possible inputs together with the set of inputs for which the answer is yes.      These inputs can be natural numbers, but can also be values of some other kind, like binary ": null
    },
    {
        "strings": "string"
    },
    {
        "or strings over some other ": null
    },
    {
        "alphabet": "alphabet"
    },
    {
        ". The subset of strings for which the problem returns yes is a ": null
    },
    {
        "formal language": "formal language"
    },
    {
        ", and often decision problems are defined as formal languages.     Using an encoding such as ": null
    },
    {
        "Gödel numbering": "gödel numbering"
    },
    {
        "s, any string can be encoded as a natural number, via which a decision problem can be defined as a subset of the natural numbers.       A classic example of a decidable decision problem is the set of prime numbers. It is possible to effectively decide whether a given natural number is prime by testing every possible nontrivial factor. Although much more efficient methods of ": null
    },
    {
        "primality testing": "primality testing"
    },
    {
        " are known, the existence of any effective method is enough to establish decidability.              A decision problem A is decidable or effectively solvable if A is a ": null
    },
    {
        "recursive set": "recursive set"
    },
    {
        ". A problem is partially decidable, semidecidable, solvable, or provable if A is a ": null
    },
    {
        "recursively enumerable set": "recursively enumerable set"
    },
    {
        ". Problems that are not decidable are undecidable. For those it is not possible to create an algorithm, efficient or otherwise, that solves them.     The ": null
    },
    {
        "halting problem": "halting problem"
    },
    {
        " is an important undecidable decision problem; for more examples, see ": null
    },
    {
        "list of undecidable problems": "list of undecidable problems"
    },
    {
        ".              Decision problems can be ordered according to ": null
    },
    {
        "many-one reducibility": "many-one reduction"
    },
    {
        " and related to feasible reductions such as ": null
    },
    {
        "polynomial-time reduction": "polynomial-time reduction"
    },
    {
        "s. A decision problem P is said to be  complete  for a set of decision problems S if P is a member of S and every problem in S can be reduced to P. Complete decision problems are used in ": null
    },
    {
        "computational complexity theory": "computational complexity theory"
    },
    {
        " to characterize ": null
    },
    {
        "complexity class": "complexity class"
    },
    {
        "es of decision problems. For example, the ": null
    },
    {
        "Boolean satisfiability problem": "boolean satisfiability problem"
    },
    {
        " is complete for the class ": null
    },
    {
        "NP": "np"
    },
    {
        " of decision problems under polynomial-time reducibility.            Decision problems are closely related to ": null
    },
    {
        "function problem": "function problem"
    },
    {
        "s, which can have answers that are more complex than a simple yes or no. A corresponding function problem is given two numbers x and y, what is x divided by y? .     A ": null
    },
    {
        "function problem": "function problem"
    },
    {
        " consists of a ": null
    },
    {
        "partial function": "partial function"
    },
    {
        " f; the informal problem is to compute the values of f on the inputs for which it is defined.     Every function problem can be turned into a decision problem; the decision problem is just the graph of the associated function.  If this decision problem were effectively solvable then the function problem would be as well. This reduction does not respect computational complexity, however. For example, it is possible for the graph of a function to be decidable in polynomial time  when the function is not computable in ": null
    },
    {
        "polynomial time": "polynomial time"
    },
    {
        " . The function f 2 x has this property.     Every decision problem can be converted into the function problem of computing the ": null
    },
    {
        "characteristic function": "indicator function"
    },
    {
        " of the set associated to the decision problem. If this function is computable then the associated decision problem is decidable. However, this reduction is more liberal than the standard reduction used in computational complexity ; for example, the complexity of the characteristic functions of an ": null
    },
    {
        "NP-complete": "np-complete"
    },
    {
        " problem and its ": null
    },
    {
        "co-NP-complete": "co-np-complete"
    },
    {
        " complement": "complement"
    },
    {
        " is exactly the same even though the underlying decision problems may not be considered equivalent in some typical models of computation.            Unlike decision problems, for which there is only one correct answer for each input, optimization problems are concerned with finding the best answer to a particular input. Optimization problems arise naturally in many applications, such as the ": null
    },
    {
        "traveling salesman problem": "traveling salesman problem"
    },
    {
        " and many questions in ": null
    },
    {
        "linear programming": "linear programming"
    },
    {
        ".     There are standard techniques for transforming function and optimization problems into decision problems. For example, in the traveling salesman problem, the optimization problem is to produce a tour with minimal weight. The associated decision problem is: for each N, to decide whether the graph has any tour with weight less than N. By repeatedly answering the decision problem, it is possible to find the minimal weight of a tour.     Because the theory of decision problems is very well developed, research in complexity theory has typically focused on decision problems. Optimization problems themselves are still of interest in computability theory, as well as in fields such as ": null
    },
    {
        "operations research": "operations research"
    }
]