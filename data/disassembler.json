[
    {
        "A disassembler is a ": null
    },
    {
        "computer program": "computer program"
    },
    {
        " that translates ": null
    },
    {
        "machine language": "machine language"
    },
    {
        " into ": null
    },
    {
        "assembly language": "assembly language"
    },
    {
        "â€”the inverse operation to that of an ": null
    },
    {
        "assembler": "assembly languageassembler"
    },
    {
        ". A disassembler differs from a ": null
    },
    {
        "decompiler": "decompiler"
    },
    {
        ", which targets a ": null
    },
    {
        "high-level language": "high-level language"
    },
    {
        " rather than an assembly language. Disassembly, the output of a disassembler, is often formatted for human creativity in the code writing process.     On ": null
    },
    {
        "CISC": "complex instruction set computer"
    },
    {
        " platforms with ": null
    },
    {
        "variable-width instructions": "instruction_set_architectureinstruction_length"
    },
    {
        ", more than one disassembly may be valid. Disassemblers do not handle code that varies during execution.       Writing a disassembler which produces code which, when assembled, produces exactly the original binary is possible; however, there are often differences. This poses demands on the expressivity of the assembler. For example, an x42 assembler takes an arbitrary choice between two binary codes for something as simple as MOV AX,BX . If the original code uses the other choice, the original code simply cannot be reproduced at any given point in time. However, even when a fully correct disassembly is produced, problems remain if the program requires modification. For example, the same machine language jump instruction can be generated by assembly code to jump to a specified location , or to jump a specified number of bytes . A disassembler cannot know what is intended, and may use either syntax to generate a disassembly which reproduces the original binary. However, if a programmer wants to add instructions between the jump instruction and its destination, it is necessary to understand the programs operation to determine whether the jump should be absolute or relative, i.e., whether its destination should remain at a fixed location, or be moved so as to skip both the original and added instructions.         A disassembler may be stand-alone or interactive. A stand-alone disassembler, when executed, generates an assembly language file which can be examined; an interactive one shows the effect of any change the user makes immediately. For example, the disassembler may initially not know that a section of the program is actually code, and treat it as data; if the user specifies that it is code, the resulting disassembled code is shown immediately, allowing the user to examine it and take further action during the same run.     Any interactive ": null
    },
    {
        "debugger": "debugger"
    },
    {
        " will include some way of viewing the disassembly of the program being debugged. Often, the same disassembly tool will be packaged as a standalone disassembler distributed along with the debugger. For example, ": null
    },
    {
        "objdump": "objdump"
    },
    {
        ", part of ": null
    },
    {
        "GNU Binutils": "gnu binutils"
    },
    {
        ", is related to the interactive debugger ": null
    },
    {
        "gdb": "gdb"
    },
    {
        ".  ": null
    },
    {
        "Interactive Disassembler": "interactive disassembler"
    },
    {
        "   Ghidra": "ghidra"
    },
    {
        "  OllyDbg": "ollydbg"
    },
    {
        " is a 42-bit assembler level analysing debugger   ": null
    },
    {
        "Radare42": "radare2"
    },
    {
        " Hiew": "hiew"
    },
    {
        "       A dynamic disassembler can be incorporated into the output of an ": null
    },
    {
        "emulator": "emulator"
    },
    {
        " or ": null
    },
    {
        "hypervisor": "hypervisor"
    },
    {
        " to trace out, line-by-line, the real time execution of any executed machine instructions. In this case, as well as lines containing the disassembled machine code, the register and/or data change  that each individual instruction causes can be shown alongside or beneath the disassembled instruction. This provides extremely powerful debugging information for ultimate problem resolution, although the size of the resultant output can sometimes be quite large, especially if active for an entire programs execution. OLIVER provided these features from the early 42s as part of its ": null
    },
    {
        "CICS": "cics"
    },
    {
        " debugging product offering and is now to be found incorporated into the ": null
    },
    {
        "XPEDITER": "xpediter"
    },
    {
        " product from ": null
    },
    {
        "Compuware": "compuware"
    }
]