[
    {
        "In ": null
    },
    {
        "formal logic": "formal logic"
    },
    {
        " and related branches of ": null
    },
    {
        "mathematics": "mathematics"
    },
    {
        ", a functional predicate, or function symbol, is a logical symbol that may be applied to an object term to produce another object term.   Functional predicates are also sometimes called mappings, but that term has other meanings as well.   In a ": null
    },
    {
        "model": "model"
    },
    {
        ", a function symbol will be modelled by a ": null
    },
    {
        "function": "function"
    },
    {
        ".     Specifically, the symbol F in a ": null
    },
    {
        "formal language": "formal language"
    },
    {
        " is a functional symbol if, ": null
    },
    {
        "given any": "given any"
    },
    {
        " symbol X representing an object in the language, F is again a symbol representing an object in that language.   In ": null
    },
    {
        "typed logic": "typed logic"
    },
    {
        ", F is a functional symbol with domain type T and codomain type U if, given any symbol X representing an object of type T, F is a symbol representing an object of type U.   One can similarly define function symbols of more than one variable, analogous to functions of more than one variable; a function symbol in ": null
    },
    {
        "zero": "0"
    },
    {
        " variables is simply a ": null
    },
    {
        "constant": "logical constant"
    },
    {
        " symbol.     Now consider a model of the formal language, with the types T and U modelled by ": null
    },
    {
        "sets": "set"
    },
    {
        " T and U and each symbol X of type T modelled by an element X in T.   Then F can be modelled by the set   : \\big\\,   which is simply a ": null
    },
    {
        "function": "function"
    },
    {
        " with domain T and codomain U.   It is a requirement of a consistent model that F F whenever X Y.       In a treatment of ": null
    },
    {
        "predicate logic": "predicate logic"
    },
    {
        " that allows one to introduce new predicate symbols, one will also want to be able to introduce new function symbols. Given the function symbols F and G, one can introduce a new function symbol F ∘ G, the  composition  of F and G, satisfying  F, ": null
    },
    {
        "for all": "for all"
    },
    {
        " X.   Of course, the right side of this equation doesnt make sense in typed logic unless the domain type of F matches the codomain type of G, so this is required for the composition to be defined.     One also gets certain function symbols automatically.   In untyped logic, there is an identity predicate id that satisfies id X for all X.   In typed logic, given any type T, there is an identity predicate id T with domain and codomain type T; it satisfies id T  X for all X of type T.   Similarly, if T is a ": null
    },
    {
        "subtype": "subtype"
    },
    {
        " of U, then there is an inclusion predicate of domain type T and codomain type U that satisfies the same equation; there are additional function symbols associated with other ways of constructing new types out of old ones.     Additionally, one can define functional predicates after proving an appropriate ": null
    },
    {
        "theorem": "theorem"
    },
    {
        ".      Specifically, if you can prove that for every X , ": null
    },
    {
        "there exists": "there exists"
    },
    {
        " a ": null
    },
    {
        "unique": "unique"
    },
    {
        " Y satisfying some condition P, then you can introduce a function symbol F to indicate this.   Note that P will itself be a relational ": null
    },
    {
        "predicate": "predicate"
    },
    {
        " involving both X and Y.   So if there is such a predicate P and a theorem:   : For all X of type T, for some unique Y of type U, P,   then you can introduce a function symbol F of domain type T and codomain type U that satisfies:   : For all X of type T, for all Y of type U, P ": null
    },
    {
        "if and only if": "if and only if"
    },
    {
        " Y F.       Many treatments of predicate logic dont allow functional predicates, only relational ": null
    },
    {
        "predicate": "predicate"
    },
    {
        "s.   This is useful, for example, in the context of proving ": null
    },
    {
        "metalogic": "metalogic"
    },
    {
        "al theorems , where one doesnt want to allow the introduction of new functional symbols .   But there is a method of replacing functional symbols with relational symbols wherever the former may occur; furthermore, this is algorithmic and thus suitable for applying most metalogical theorems to the result.     Specifically, if F has domain type T and ": null
    },
    {
        "codomain": "codomain"
    },
    {
        " type U, then it can be replaced with a predicate P of type .   Intuitively, P means F Y.   Then whenever F would appear in a statement, you can replace it with a new symbol Y of type U and include another statement P.   To be able to make the same deductions, you need an additional proposition:   : ": null
    },
    {
        "For all": "for all"
    },
    {
        " X of type T, for some ": null
    },
    {
        "unique": "unique"
    },
    {
        " Y of type U, P.       Because the elimination of functional predicates is both convenient for some purposes and possible, many treatments of formal logic do not deal explicitly with function symbols but instead use only relation symbols; another way to think of this is that a functional predicate is a special kind of predicate, specifically one that satisfies the proposition above.   This may seem to be a problem if you wish to specify a proposition ": null
    },
    {
        "schema": "schema"
    },
    {
        " that applies only to functional predicates F; how do you know ahead of time whether it satisfies that condition?   To get an equivalent formulation of the schema, first replace anything of the form F with a new variable Y.   Then ": null
    },
    {
        "universally quantify": "universally quantify"
    },
    {
        " over each Y immediately after the corresponding X is introduced , and guard the quantification with P.   Finally, make the entire statement a ": null
    },
    {
        "material consequence": "material conditional"
    },
    {
        " of the uniqueness condition for a functional predicate above.     Let us take as an example the ": null
    },
    {
        "axiom schema of replacement": "axiom schema of replacement"
    },
    {
        " in ": null
    },
    {
        "Zermelo–Fraenkel set theory": "zermelo–fraenkel set theory"
    },
    {
        ".      This schema states , for any functional predicate F in one variable:   : \\forall A, \\exists B, \\forall C, C \\in A \\rightarrow F\\in B.   First, we must replace F with some other variable D:   : \\forall A, \\exists B, \\forall C, C \\in A\\rightarrow D \\in B.   Of course, this statement isnt correct; D must be quantified over just after C:   : \\forall A, \\exists B, \\forall C, \\forall D, C \\in A \\rightarrow D\\in B.   We still must introduce P": null
    }
]