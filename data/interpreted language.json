[
    {
        "   An interpreted language is a type of ": null
    },
    {
        "programming language": "programming language"
    },
    {
        " for which most of its implementations execute instructions directly and freely, without previously ": null
    },
    {
        "compiling": "compiler"
    },
    {
        " a ": null
    },
    {
        "program": "computer program"
    },
    {
        " into ": null
    },
    {
        "machine-language": "machine language"
    },
    {
        " instructions. The ": null
    },
    {
        "interpreter": "interpreter"
    },
    {
        " executes the program directly, translating each statement into a sequence of one or more ": null
    },
    {
        "subroutines": "subroutines"
    },
    {
        ", and then into another language .     The terms interpreted language and  compiled language  are not well defined because, in theory, any programming language can be either interpreted or compiled. In modern programming language implementation, it is increasingly popular for a platform to provide both options.     Interpreted languages can also be contrasted with machine languages. Functionally, both execution and interpretation mean the same thing â€” fetching the next instruction/statement from the program and executing it. Although interpreted ": null
    },
    {
        "byte code": "byte code"
    },
    {
        " is additionally identical to machine code in form and has an ": null
    },
    {
        "assembler": "assembly language"
    },
    {
        " representation, the term interpreted is sometimes reserved for software processed languages  on top of the native  processor.     In principle, programs in many languages may be compiled or interpreted, emulated or executed natively, so this designation is applied solely based on common implementation practice, rather than representing an essential property of a language.     Many languages have been implemented using both compilers and interpreters, including ": null
    },
    {
        "BASIC": "basic"
    },
    {
        ", ": null
    },
    {
        "C": "c"
    },
    {
        ", ": null
    },
    {
        "Lisp": "lisp"
    },
    {
        ", and ": null
    },
    {
        "Pascal": "pascal"
    },
    {
        ". ": null
    },
    {
        "Java": "java"
    },
    {
        " and ": null
    },
    {
        "C": "c sharp"
    },
    {
        " are compiled into ": null
    },
    {
        "bytecode": "bytecode"
    },
    {
        ", the ": null
    },
    {
        "virtual-machine-friendly interpreted language": "interpreted languagelanguages usually compiled to a bytecode"
    },
    {
        ". ": null
    },
    {
        "Lisp implementations": "list of lisp-family programming languages"
    },
    {
        " can freely mix interpreted and compiled code.     The distinction between a compiler and an interpreter is not always well defined, and many language processors do a combination of both.       In the early days of computing, language design was heavily influenced by the decision to use compiling or interpreting as a mode of execution. For example, ": null
    },
    {
        "Smalltalk": "smalltalk"
    },
    {
        " , which was designed to be interpreted at run-time, allows generic objects to dynamically interact with each other.     Initially, interpreted languages were compiled line-by-line; that is, each line was compiled as it was about to be executed, and if a loop or subroutine caused certain lines to be executed multiple times, they would be recompiled every time. This has become much less common. Most so-called interpreted languages use an ": null
    },
    {
        "intermediate representation": "intermediate representation"
    },
    {
        ", which combines compiling and interpreting.     Examples include:   ": null
    },
    {
        "JavaScript": "javascript"
    },
    {
        " Perl": "perl"
    },
    {
        " Python": "python"
    },
    {
        " BASIC": "basic"
    },
    {
        " Forth": "forth"
    },
    {
        "     The intermediate representation can be compiled once and for all , each time before execution , or each time a change in the source is detected before execution .       Interpreting a language gives implementations some additional flexibility over compiled implementations. Features that are often easier to implement in interpreters than in compilers include:   ": null
    },
    {
        "platform independence": "platform independent"
    },
    {
        "   reflection": "reflection"
    },
    {
        " and reflective use of the evaluator    ": null
    },
    {
        "dynamic typing": "dynamic typing"
    },
    {
        " dynamic scoping": "scope dynamic scoping"
    },
    {
        "     Furthermore, source code can be read and copied, giving users more freedom.            Disadvantages of interpreted languages are:   Without ": null
    },
    {
        "static type-checking": "static type-checking"
    },
    {
        ", which is usually performed by a compiler, programs can be less reliable, because type checking eliminates a class of programming errors    Interpreters can be susceptible to ": null
    },
    {
        "Code injection": "code injection"
    },
    {
        " attacks.   Slower execution compared to direct native ": null
    },
    {
        "machine code": "machine code"
    },
    {
        " execution on the host ": null
    },
    {
        "CPU": "cpu"
    },
    {
        ". A technique used to improve performance is ": null
    },
    {
        "just-in-time compilation": "just-in-time compilation"
    },
    {
        " which converts frequently executed sequences of interpreted instruction to host machine code. JIT is most often combined with compilation to byte-code as in ": null
    },
    {
        "Java": "java"
    },
    {
        ".   Source code can be read and copied , or more easily reverse engineered through ": null
    },
    {
        "reflection": "reflection"
    },
    {
        " in applications where intellectual property has a commercial advantage. In some cases, ": null
    },
    {
        "obfuscation": "obfuscation"
    },
    {
        " is used as a partial defense against this.            Several criteria can be used to determine whether a particular language is likely to be called compiled or interpreted by its users:     If a subroutine can be invoked prior to where its defined in the source code, the entire source is likely being compiled to an intermediate representation before execution. Examples: ": null
    },
    {
        "Perl": "perl"
    },
    {
        ", ": null
    },
    {
        "Java": "java"
    },
    {
        " Java": "java"
    },
    {
        ", ": null
    },
    {
        "C": "c"
    },
    {
        " Unix shell": "unix shell"
    },
    {
        " languages     These are not definitive. Compiled languages can have interpreter-like properties and vice versa.       ": null
    },
    {
        "APL": "apl"
    },
    {
        " A vector oriented language using an unusual character set   ": null
    },
    {
        "J": "j"
    },
    {
        " An APL variant in which tacit definition provides some of the benefits of compiling   ": null
    },
    {
        "BASIC": "basic"
    },
    {
        "   Equation manipulation and solving systems   ": null
    },
    {
        "GNU Octave": "gnu octave"
    },
    {
        " Interactive Data Language": "idl"
    },
    {
        "   TK Solver": "tk solver"
    },
    {
        " Mathematica": "mathematica"
    },
    {
        " MATLAB": "matlab"
    },
    {
        " Euphoria": "euphoria"
    },
    {
        " Interpreted or compiled.   ": null
    },
    {
        "GameMaker Language": "gamemaker studio"
    },
    {
        " Bytecode after GameMaker: Studio.   ": null
    },
    {
        "JavaScript": "javascript"
    },
    {
        " Forth": "forth"
    },
    {
        " Lava": "lava"
    },
    {
        " Lisp": "lisp"
    },
    {
        " Logo": "logo"
    },
    {
        " Scheme": "scheme"
    },
    {
        " MUMPS": "mumps"
    },
    {
        " PHP": "php"
    },
    {
        " PostScript": "postscript"
    },
    {
        " PowerShell": "powershell"
    },
    {
        " Ruby": "ruby"
    },
    {
        " REXX": "rexx"
    },
    {
        " Seed42": "seed7"
    },
    {
        " Smalltalk": "smalltalk"
    },
    {
        " Spreadsheet": "spreadsheet"
    },
    {
        "s   ": null
    },
    {
        "Excel": "microsoft excel"
    },
    {
        " S": "s"
    },
    {
        " R": "r"
    },
    {
        " Tcl": "tcl"
    },
    {
        " Unix shell": "unix shell"
    },
    {
        " XOTcl": "xotcl"
    },
    {
        " VBScript": "vbscript"
    },
    {
        "        Many languages are first compiled to ": null
    },
    {
        "bytecode": "bytecode"
    },
    {
        ". Sometimes, bytecode can also be compiled to a native binary using an ": null
    },
    {
        "AOT compiler": "aot compiler"
    },
    {
        " or executed natively, by hardware processor.   ": null
    },
    {
        "AppleScript": "applescript"
    },
    {
        " Erlang": "erlang"
    },
    {
        "   Elixir": "elixir"
    },
    {
        "   Java": "java"
    },
    {
        "    Clojure": "clojure"
    },
    {
        " Groovy": "groovy"
    },
    {
        " Kotlin": "kotlin"
    },
    {
        " ColdFusion": "coldfusion"
    },
    {
        " Scala": "scala"
    },
    {
        " .NET Framework": ".net framework"
    },
    {
        " languages .   ": null
    },
    {
        "C++/CLI": "c++/cli"
    },
    {
        " C": "c sharp"
    },
    {
        " Visual Basic .NET": "visual basic .net"
    },
    {
        " F": "f sharp"
    },
    {
        " Lisp": "lisp"
    },
    {
        " Lua": "lua"
    },
    {
        " Perl": "perl"
    },
    {
        " Pike": "pike"
    },
    {
        " Python": "python"
    },
    {
        "    Squeak Smalltalk": "squeak smalltalk"
    },
    {
        " Visual FoxPro": "visual foxpro"
    }
]