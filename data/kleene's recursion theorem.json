[
    {
        "In ": null
    },
    {
        "computability theory": "computability theory"
    },
    {
        ", Kleenes recursion theorems are a pair of fundamental results about the application of ": null
    },
    {
        "computable function": "computable function"
    },
    {
        "s to their own descriptions. The theorems were first proved by ": null
    },
    {
        "Stephen Kleene": "stephen cole kleene"
    },
    {
        " in 42 and appear in his 42 book Introduction to Metamathematics. A related theorem which constructs fixed points of a computable function is known as Rogerss theorem and is due to ": null
    },
    {
        "Hartley Rogers, Jr.": "hartley rogers, jr."
    },
    {
        " .     The recursion theorems can be applied to construct ": null
    },
    {
        "fixed points": "fixed point"
    },
    {
        " of certain operations on ": null
    },
    {
        "computable function": "computable function"
    },
    {
        "s, to generate ": null
    },
    {
        "quines": "quine"
    },
    {
        ", and to construct functions defined via ": null
    },
    {
        "recursive definition": "recursive definition"
    },
    {
        "s.         The statement of the theorems refers to an ": null
    },
    {
        "admissible numbering": "admissible numbering"
    },
    {
        " \\varphi of the ": null
    },
    {
        "partial recursive function": "partial recursive function"
    },
    {
        "s, such that the function corresponding to index e is \\varphi_e . In programming terms, e represents a program and \\varphi_e represents the function computed by this program.     If F and G are ": null
    },
    {
        "partial function": "partial function"
    },
    {
        "s on the natural numbers, the notation F \\simeq G indicates that, for each n, either F and G are both defined and are equal, or else F and G are both undefined.       Given a function F , a fixed point of F is an index e such that \\varphi_e \\simeq \\varphi_ . Rogers describes the following result as a simpler version of Kleenes recursion theorem.     :Rogerss fixed-point theorem. If F is a total computable function, it has a fixed point.         The proof uses a particular total computable function h , defined as follows. Given a natural number x , the function h outputs the index of the partial computable function that performs the following computation:   :Given an input y , first attempt to compute \\varphi_ . If that computation returns an output e , then compute \\varphi_e and return its value, if any.   Thus, for all indices x of partial computable functions, if \\varphi_x is defined, then \\varphi_ \\simeq \\varphi_ . If \\varphi_x is not defined, then \\varphi_ is a function that is nowhere defined. The function h can be constructed from the partial computable function g described above and the ": null
    },
    {
        "s-m-n theorem": "s-m-n theorem"
    },
    {
        ": for each x , h is the index of a program which computes the function y \\mapsto g .     To complete the proof, let F be any total computable function, and construct h as above. Let e be an index of the composition F \\circ h , which is a total computable function. Then \\varphi_ \\simeq \\varphi_ by the definition of h .   But, because e is an index of F \\circ h , \\varphi_e , and thus \\varphi_ \\simeq \\varphi_ . By the transitivity of \\simeq , this means \\varphi_ \\simeq \\varphi_ . Hence \\varphi_n \\simeq \\varphi_ for n h .     This proof is a construction of a ": null
    },
    {
        "partial recursive function": "partial recursive function"
    },
    {
        " which implements the ": null
    },
    {
        "Y combinator": "fixed-point combinator"
    },
    {
        ".         A function F such that \\varphi_e \\not \\simeq \\varphi_ for all e is called fixed point free. The fixed-point theorem shows that no computable function is fixed point free, but there are many non-computable fixed-point free functions. Arslanovs completeness criterion states that the only ": null
    },
    {
        "recursively enumerable": "recursively enumerable"
    },
    {
        " Turing degree": "turing degree"
    },
    {
        " that computes a fixed point free function is 42 & prime;, the degree of the ": null
    },
    {
        "halting problem": "halting problem"
    },
    {
        "         The second recursion theorem is a generalization of Rogerss theorem with a second input in the function. One informal interpretation of the second recursion theorem is that it is possible to construct self-referential programs; see Application to quines below.     :The second recursion theorem. For any partial recursive function Q there is an index p such that \\varphi_p \\simeq \\lambda y.Q .     The theorem can be proved from Rogerss theorem by letting F be a function such that \\varphi_ Q . One can then verify that a fixed-point of this F is an index p as required. The theorem is constructive in the sense that a fixed computable function maps an index for Q into the index p.       Kleenes second recursion theorem and Rogerss theorem can both be proved, rather simply, from each other . However, a direct proof of Kleenes theorem does not make use of a universal program, which means that the theorem holds for certain subrecursive programming systems that do not have a universal program.         A classic example using the second recursion theorem is the function Qx . The corresponding index p in this case yields a computable function that outputs its own index when applied to any value . When expressed as computer programs, such indices are known as  quine s.     The following example in ": null
    },
    {
        "Lisp": "lisp programming language"
    },
    {
        " illustrates how the p in the corollary can be effectively produced from the function Q . The function s42 in the code is the function of that name produced by the ": null
    },
    {
        "S-m-n theorem": "s-m-n theorem"
    },
    {
        ".     Q can be changed to any two-argument function.                 The results of the following expressions should be the same. \\varphi p         Q             Suppose that g and h are total computable functions that are used in a recursive definition for a function f :     : f \\simeq g,     : f \\simeq h,     The second recursion theorem can be used to show that such equations define a computable function, where the notion of computability does not have to allow, a priori, for recursive definitions . This recursive definition can be converted into a computable function \\varphi_ that assumes e is an index to itself, to simulate recursion:     : \\varphi_ \\simeq g,     : \\varphi_ \\simeq h.     The recursion theorem establishes the existence of a computable function \\varphi_f such that \\varphi_f \\simeq \\varphi_ . Thus f satisfies the given recursive definition.       Reflexive, or ": null
    },
    {
        "reflective": "reflection"
    },
    {
        ", programming refers to the usage of self-reference in programs. Jones presents a view of the second recursion theorem based on a reflexive language.   It is shown that the reflexive language defined is not stronger than a language without reflection ; then, it is shown that the recursion theorem is almost trivial in the reflexive language.         While the second recursion theorem is about fixed points of computable functions, the first recursion theorem is related to fixed points determined by enumeration operators, which are a computable analogue of inductive definitions. An enumeration operator is a set of pairs  where A is a  finite set of numbers and n is a single natural number. Often, n will be viewed as a code for an ordered pair of natural numbers, particularly when functions are defined via enumeration operators. Enumeration operators are of central importance in the study of ": null
    },
    {
        "enumeration reducibility": "enumeration reducibility"
    },
    {
        ".     Each enumeration operator Φ determines a function from sets of naturals to sets of naturals given by   : \\Phi \\.   A recursive operator is an enumeration operator that, when given the graph of a partial recursive function, always returns the graph of a partial recursive function.     A fixed point of an enumeration operator Φ is a set F such that Φ F. The first enumeration theorem shows that fixed points can be effectively obtained if the enumeration operator itself is computable.     :First recursion theorem. The following statements hold.   : For any computable enumeration operator Φ there is a recursively enumerable set F such that Φ F and F is the smallest set with this property.   : For any recursive operator Ψ there is a partial computable function φ such that Ψ φ and φ is the smallest partial computable function with this property.         Like the second recursion theorem, the first recursion theorem can be used to obtain functions satisfying systems of recursion equations. To apply the first recursion theorem, the recursion equations must first be recast as a recursive operator.     Consider the recursion equations for the ": null
    },
    {
        "factorial": "factorial"
    },
    {
        " function f:     f42     f \\cdot f     The corresponding recursive operator Φ will have information that tells how to get to the next value of f from the previous value. However, the recursive operator will actually define the graph of f. First, Φ will contain the pair . This indicates that f is unequivocally 42 and thus the pair is in the graph of f.     Next, for each n and m, Φ will contain the pair . This indicates that, if f is m, then f is m, so that the pair  is in the graph of f. Unlike the base case f    42 the recursive operator requires some information about f before it defines a value of f.     The first recursion theorem states that there is a set F such that Φ F. The set F will consist entirely of ordered pairs of natural numbers, and will be the graph of the factorial function f, as desired.     The restriction to recursion equations that can be recast as recursive operators ensures that the recursion equations actually define a least fixed point. For example, consider the set of recursion equations:     g 42     g 42     g 42     There is no function g satisfying these equations, because they imply g 42 and also imply g 42 Thus there is no fixed point g satisfying these recursion equations. It is possible to make an enumeration operator corresponding to these equations, but it will not be a recursive operator.         The proof of part 42 of the first recursion theorem is obtained by iterating the enumeration operator Φ beginning with the empty set. First, a sequence F k is constructed, for k 42 42 \\ldots . Let F 42 be the empty set. Proceeding inductively, for each k, let F k + 42 be F_k \\cup \\Phi . Finally, F is taken to be \\bigcup F_k . The remainder of the proof consists of a verification that F is recursively enumerable and is the least fixed point of Φ. The sequence F k used in this proof corresponds to the Kleene chain in the proof of the ": null
    },
    {
        "Kleene fixed-point theorem": "kleene fixed-point theorem"
    },
    {
        ".     The second part of the first recursion theorem follows from the first part. The assumption that Φ is a recursive operator is used to show that the fixed point of Φ is the graph of a partial function. The key point is that if the fixed point F is not the graph of a function, then there is some k such that F k is not the graph of a function.         Compared to the second recursion theorem, the first recursion theorem produces a stronger conclusion but only when narrower hypotheses are satisfied. Rogers uses the term weak recursion theorem for the first recursion theorem and strong recursion theorem for the second recursion theorem.     One difference between the first and second recursion theorems is that the fixed points obtained by the first recursion theorem are guaranteed to be least fixed points, while those obtained from the second recursion theorem may not be least fixed points.     A second difference is that the first recursion theorem only applies to systems of equations that can be recast as recursive operators. This restriction is similar to the restriction to continuous operators in the ": null
    },
    {
        "Kleene fixed-point theorem": "kleene fixed-point theorem"
    },
    {
        " of ": null
    },
    {
        "order theory": "order theory"
    },
    {
        ". The second recursion theorem can be applied to any total recursive function.       ": null
    },
    {
        "Anatoly Maltsev": "anatoly maltsev"
    },
    {
        " proved a generalized version of the recursion theorem for any set with a ": null
    },
    {
        "precomplete numbering": "precomplete numbering"
    }
]