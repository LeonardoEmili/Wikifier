[
    {
        "         Machine code is a computer program written in machine language ": null
    },
    {
        "instructions": "instruction set"
    },
    {
        " that can be executed directly by a ": null
    },
    {
        "computers": "computer"
    },
    {
        " central processing unit": "central processing unit"
    },
    {
        " . Each instruction causes the CPU to perform a very specific task, such as a load, a store, a ": null
    },
    {
        "jump": "jump instruction"
    },
    {
        ", or an ": null
    },
    {
        "ALU": "arithmetic logic unit"
    },
    {
        " operation on one or more units of data in ": null
    },
    {
        "CPU registers": "processor register"
    },
    {
        "or memory.     Machine code is a strictly numerical language which is intended to run as fast as possible, and may be regarded as the lowest-level representation of a ": null
    },
    {
        "compiled": "compiler"
    },
    {
        " or ": null
    },
    {
        "assembled": "assembly language"
    },
    {
        " computer program": "computer program"
    },
    {
        " or as a primitive and ": null
    },
    {
        "hardware": "computer hardware"
    },
    {
        "-dependent ": null
    },
    {
        "programming language": "programming language"
    },
    {
        ". While it is possible to write programs directly in machine code, it is tedious and error prone to manage individual bits and calculate numerical addresses and constants manually. For this reason, programs are very rarely written directly in machine code in modern contexts, but may be done for low level ": null
    },
    {
        "debugging": "debugging"
    },
    {
        ", program ": null
    },
    {
        "patching": "patch"
    },
    {
        " and ": null
    },
    {
        "assembly language": "assembly language"
    },
    {
        " disassembly": "disassembly"
    },
    {
        ".     The overwhelming majority of practical programs today are written in ": null
    },
    {
        "higher-level languages": "high-level programming language"
    },
    {
        " or assembly language. The source code is then translated to executable machine code by utilities such as ": null
    },
    {
        "compiler": "compiler"
    },
    {
        "s, ": null
    },
    {
        "assemblers": "assembler"
    },
    {
        ", and ": null
    },
    {
        "linkers": "linker"
    },
    {
        ", with the important exception of ": null
    },
    {
        "interpreted": "interpreted language"
    },
    {
        " programs, Such as many versions of ": null
    },
    {
        "BASIC": "basic"
    },
    {
        ", especially early ones, as well as ": null
    },
    {
        "Smalltalk": "smalltalk"
    },
    {
        ", ": null
    },
    {
        "MATLAB": "matlab"
    },
    {
        ", ": null
    },
    {
        "Perl": "perl"
    },
    {
        ", ": null
    },
    {
        "Python": "python"
    },
    {
        ", ": null
    },
    {
        "Ruby": "ruby"
    },
    {
        " and other special purpose or ": null
    },
    {
        "scripting language": "scripting language"
    },
    {
        "s. which are not translated into machine code. However, the  interpreter  itself, which may be seen as an executor or processor, performing the instructions of the source code, typically consists of directly executable machine code .     Machine code is by definition the lowest level of programming detail visible to the programmer, but internally many processors use ": null
    },
    {
        "microcode": "microcode"
    },
    {
        " or optimise and transform machine code instructions into sequences of ": null
    },
    {
        "micro-ops": "micro-operation"
    },
    {
        ". This is not generally considered to be a machine code.          Every processor or processor family has its own ": null
    },
    {
        "instruction set": "instruction set"
    },
    {
        ". Instructions are patterns of ": null
    },
    {
        "bits": "bit"
    },
    {
        "that by physical design correspond to different commands to the machine. Thus, the instruction set is specific to a class of processors using the same architecture. Successor or derivative processor designs often include all the instructions of a predecessor and may add additional instructions. Occasionally, a successor design will discontinue or alter the meaning of some instruction code , affecting code compatibility to some extent; even nearly completely compatible processors may show slightly different behavior for some instructions, but this is rarely a problem. Systems may also differ in other details, such as memory arrangement, operating systems, or ": null
    },
    {
        "peripheral devices": "peripheral"
    },
    {
        ". Because a program normally relies on such factors, different systems will typically not run the same machine code, even when the same type of processor is used.     A processors instruction set may have all instructions of the same length, or it may have variable-length instructions. How the patterns are organized varies strongly with the particular architecture and often also with the type of instruction. Most instructions have one or more ": null
    },
    {
        "opcode": "opcode"
    },
    {
        " fields which specifies the basic instruction type  and the actual operation and other fields that may give the type of the ": null
    },
    {
        "operand": "operand"
    },
    {
        ", the ": null
    },
    {
        "addressing mode": "addressing mode"
    },
    {
        ", the addressing offset or index, or the actual value itself .      Not all machines or individual instructions have explicit operands. An ": null
    },
    {
        "accumulator machine": "accumulator machine"
    },
    {
        " has a combined left operand and result in an implicit accumulator for most arithmetic instructions. Other architectures have accumulator versions of common instructions, with the accumulator regarded as one of the general registers by longer instructions. A ": null
    },
    {
        "stack machine": "stack machine"
    },
    {
        " has most or all of its operands on an implicit stack. Special purpose instructions also often lack explicit operands . This distinction between explicit and implicit operands is important in code generators, especially in the register allocation and live range tracking parts. A good code optimizer can track implicit as well as explicit operands which may allow more frequent ": null
    },
    {
        "constant propagation": "constant propagation"
    },
    {
        ", ": null
    },
    {
        "constant folding": "constant folding"
    },
    {
        " of registers and other code enhancements.       A computer program is a list of instructions that can be executed by a central processing unit. A programs execution is done in order for the CPU that is executing it to solve a specific problem and thus accomplish a specific result. While simple processors are able to execute instructions one after another, ": null
    },
    {
        "superscalar": "superscalar"
    },
    {
        " processors are capable of executing a variety of different instructions at once.     ": null
    },
    {
        "Program flow": "program flow"
    },
    {
        " may be influenced by special jump instructions that transfer execution to an instruction other than the numerically following one. ": null
    },
    {
        "Conditional jumps": "conditional branch"
    },
    {
        "are taken or not depending on some condition.          A much more readable rendition of machine language, called ": null
    },
    {
        "assembly language": "assembly language"
    },
    {
        ", uses ": null
    },
    {
        "mnemonic codes": "assembly languageopcode mnemonics and extended mnemonics"
    },
    {
        "to refer to machine code instructions, rather than using the instructions numeric values directly. For example, on the ": null
    },
    {
        "Zilog Z80": "zilog z80"
    },
    {
        " processor, the machine code 00000101 , which causes the CPU to decrement the B ": null
    },
    {
        "processor register": "processor register"
    },
    {
        ", would be represented in assembly language as DEC B .       The ": null
    },
    {
        "MIPS architecture": "mips architecture"
    },
    {
        " provides a specific example for a machine code whose instructions are always 32 bits long. The general type of instruction is given by the op field, the highest 6 bits. J-type and I-type instructions are fully specified by op. R-type instructions include an additional field funct to determine the exact operation. The fields used in these types are:     6 5 5 5 5 6 bits   R-type   I-type   J-type     rs, rt, and rd indicate register operands; shamt gives a shift amount; and the address or immediate fields contain an operand directly.     For example, adding the registers 1 and 2 and placing the result in register 6 is encoded:       0 1 2 6 0 32 decimal   000000 00001 00010 00110 00000 100000 binary     Load a value into register 8, taken from the memory cell 68 cells after the location listed in register 3:       35 3 8 68 decimal   100011 00011 01000 00000 00001 000100 binary     Jumping to the address 1024:       2 1024 decimal   000010 00000 00000 00000 10000 000000 binary       In some ": null
    },
    {
        "computer architecture": "computer architecture"
    },
    {
        "s, the machine code is implemented by an even more fundamental underlying layer called ": null
    },
    {
        "microcode": "microcode"
    },
    {
        ", providing a common machine language interface across a line or family of different models of computer with widely different underlying ": null
    },
    {
        "dataflow": "dataflow"
    },
    {
        "s. This is done to facilitate ": null
    },
    {
        "porting": "porting"
    },
    {
        " of machine language programs between different models. An example of this use is the IBM ": null
    },
    {
        "System/360": "system/360"
    },
    {
        " family of computers and their successors. With dataflow path widths of 8  bits to 64  bits and beyond, they nevertheless present a common architecture at the machine language level across the entire line.     Using microcode to implement an ": null
    },
    {
        "emulator": "emulator"
    },
    {
        " enables the computer to present the architecture of an entirely different computer. The System/360 line used this to allow porting programs from earlier IBM machines to the new family of computers, e.g. an ": null
    },
    {
        "IBM 1401/1440/1460": "ibm 1400 series"
    },
    {
        " emulator on the IBM S/360 model 40.       Machine code is generally different from ": null
    },
    {
        "bytecode": "bytecode"
    },
    {
        " , which is either executed by an interpreter or itself compiled into machine code for faster execution. An exception is when a processor is designed to use a particular bytecode directly as its machine code, such as is the case with ": null
    },
    {
        "Java processor": "java processor"
    },
    {
        "s.     Machine code and assembly code are sometimes called  native code when referring to platform-dependent parts of language features or libraries.        The ": null
    },
    {
        "Harvard architecture": "harvard architecture"
    },
    {
        " is a computer architecture with physically separate storage and signal pathways for the code and ": null
    },
    {
        "data": "data"
    },
    {
        ". Today, most processors implement such separate signal pathways for performance reasons but implement a ": null
    },
    {
        "Modified Harvard architecture": "modified harvard architecture"
    },
    {
        ", so they can support tasks like loading an ": null
    },
    {
        "executable": "executable"
    },
    {
        " program from ": null
    },
    {
        "disk storage": "data storage device"
    },
    {
        " as data and then executing it. Harvard architecture is contrasted to the ": null
    },
    {
        "Von Neumann architecture": "von neumann architecture"
    },
    {
        ", where data and code are stored in the same memory which is read by the processor allowing the computer to execute commands.     From the point of view of a ": null
    },
    {
        "process": "process"
    },
    {
        ", the code space is the part of its ": null
    },
    {
        "address space": "virtual address space"
    },
    {
        " where the code in execution is stored. In ": null
    },
    {
        "multitasking": "computer multitasking"
    },
    {
        " systems this comprises the programs ": null
    },
    {
        "code segment": "code segment"
    },
    {
        " and usually ": null
    },
    {
        "shared libraries": "shared libraries"
    },
    {
        ". In ": null
    },
    {
        "multi-threading": "thread"
    },
    {
        " environment, different threads of one process share code space along with data space, which reduces the overhead of ": null
    },
    {
        "context switching": "context switching"
    },
    {
        " considerably as compared to process switching.       Pamela Samuelson wrote that machine code is so unreadable that the ": null
    },
    {
        "United States Copyright Office": "united states copyright office"
    },
    {
        " cannot identify whether a particular encoded program is an original work of authorship;  however, the US Copyright Office does allow for copyright registration of computer programs  and a programs machine code can sometimes be ": null
    },
    {
        "decompiled": "decompiler"
    },
    {
        " in order to make its functioning more easily understandable to humans.      Cognitive science professor ": null
    },
    {
        "Douglas Hofstadter": "douglas hofstadter"
    },
    {
        " has compared machine code to ": null
    },
    {
        "genetic code": "genetic code"
    },
    {
        ", saying that Looking at a program written in machine language is vaguely comparable to looking at a ": null
    },
    {
        "DNA": "dna"
    },
    {
        " molecule atom by atom. ": null
    }
]