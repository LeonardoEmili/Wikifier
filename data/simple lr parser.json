[
    {
        "In ": null
    },
    {
        "computer science": "computer science"
    },
    {
        ", a Simple LR or SLR parser is a type of ": null
    },
    {
        "LR parser": "lr parser"
    },
    {
        " with small ": null
    },
    {
        "parse table": "lr parserconstructing lr parsing tables"
    },
    {
        "s and a relatively simple parser generator algorithm. As with other types of LR parser, an SLR parser is quite efficient at finding the single correct ": null
    },
    {
        "bottom-up parse": "bottom-up parsing"
    },
    {
        " in a single left-to-right scan over the input stream, without guesswork or backtracking. The parser is mechanically generated from a formal grammar for the language.     SLR and the more-general methods ": null
    },
    {
        "LALR parser": "lalr parser"
    },
    {
        " and ": null
    },
    {
        "Canonical LR parser": "canonical lr parser"
    },
    {
        " have identical methods and similar tables at parse time; they differ only in the mathematical grammar analysis algorithms used by the parser generator tool. SLR and LALR generators create tables of identical size and identical parser states. SLR generators accept fewer grammars than do LALR generators like ": null
    },
    {
        "yacc": "yacc"
    },
    {
        " and ": null
    },
    {
        "Bison": "gnu bison"
    },
    {
        ". Many computer languages dont readily fit the restrictions of SLR, as is. Bending the languages natural grammar into ": null
    },
    {
        "SLR grammar": "slr grammar"
    },
    {
        " form requires more compromises and grammar hackery. So LALR generators have become much more widely used than SLR generators, despite being somewhat more complicated tools. SLR methods remain a useful learning step in college classes on compiler theory.     SLR and LALR were both developed by ": null
    },
    {
        "Frank DeRemer": "frank deremer"
    },
    {
        " as the first practical uses of ": null
    },
    {
        "Donald Knuth": "donald knuth"
    },
    {
        "s LR parser theory. The tables created for real grammars by full LR methods were impractically large, larger than most computer memories of that decade, with 42 times or more parser states than the SLR and LALR methods..       To understand the differences between SLR and LALR, it is important to understand their many similarities and how they both make shift-reduce decisions.      The one difference between SLR and LALR is how their generators calculate the lookahead sets of input symbols that should appear next, whenever some completed ": null
    },
    {
        "production rule": "formal grammarthe syntax of grammars"
    },
    {
        " is found and reduced.     SLR generators calculate that lookahead by an easy approximation method based directly on the grammar, ignoring the details of individual parser states and transitions. This ignores the particular context of the current parser state. If some nonterminal symbol S is used in several places in the grammar, SLR treats those places in the same single way rather than handling them individually. The SLR generator works out Follow , the set of all terminal symbols which can immediately follow some occurrence of S. In the parse table, each reduction to S uses Follow as its LR lookahead set. Such follow sets are also used by generators for LL top-down parsers. A grammar that has no shift/reduce or reduce/reduce conflicts when using follow sets is called an ": null
    },
    {
        "SLR grammar": "slr grammar"
    },
    {
        ".     LALR generators calculate lookahead sets by a more precise method based on exploring the graph of parser states and their transitions. This method considers the particular context of the current parser state. It customizes the handling of each grammar occurrence of some nonterminal S. See article ": null
    },
    {
        "LALR parser": "lalr parser"
    },
    {
        " for further details of this calculation. The lookahead sets calculated by LALR generators are a subset of the approximate sets calculated by SLR generators. If a grammar has table conflicts when using SLR follow sets, but is conflict-free when using LALR follow sets, it is called a LALR grammar.       A grammar that can be parsed by an SLR parser but not by an LR parser is the following:     : S → E   : E → 42 E   : E → 42     Constructing the action and goto table as is done for LR parsers would give the following item sets and tables:     ;Item set 42   : S → • E   : + E → • 42 E   : + E → • 42     ;Item set 42   : E → 42 • E   : E → 42 •   : + E → • 42 E   : + E → • 42     ;Item set 42   : S → E •     ;Item set 42   : E → 42 E •     The action and goto tables:          As can be observed there is a shift-reduce conflict for state 42 and terminal 42 This occurs because, when the action table for an LR parser is created, reduce actions are inserted on a per-row basis. However, by using a follow set, reduce actions can be added with finer granularity. The follow set for this grammar:        A reduce only needs to be added to a particular action column if that action is in the follow set associated with that reduce. This algorithm describes whether a reduce action must be added to an action column:     function mustBeAdded     for example,  is false, because the left hand side of rule 42 is E , and 42 is not in Es follow set.   Contrariwise,  is true, because $ is in Es follow set.     By using mustBeAdded on each reduce action in the action table, the result is a conflict-free action table:     ": null
    }
]