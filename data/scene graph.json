[
    {
        "A scene graph is a general ": null
    },
    {
        "data structure": "data structure"
    },
    {
        " commonly used by ": null
    },
    {
        "vector-based graphics editing": "vector graphics"
    },
    {
        " applications and modern computer games, which arranges the logical and often spatial representation of a graphical scene.     A scene graph is a collection of nodes in a ": null
    },
    {
        "graph": "graph"
    },
    {
        " or ": null
    },
    {
        "tree": "tree"
    },
    {
        " structure. A tree node may have many children but only a single parent, with the effect of a parent applied to all its child nodes; an operation performed on a group automatically propagates its effect to all of its members. In many programs, associating a geometrical ": null
    },
    {
        "transformation matrix": "transformation matrix"
    },
    {
        "  at each group level and concatenating such matrices together is an efficient and natural way to process such operations. A common feature, for instance, is the ability to group related shapes and objects into a compound object that can then be moved, transformed, selected, etc. as easily as a single object.       In vector-based graphics editing, each ": null
    },
    {
        "leaf node": "leaf node"
    },
    {
        " in a scene graph represents some atomic unit of the document, usually a shape such as an ": null
    },
    {
        "ellipse": "ellipse"
    },
    {
        " or ": null
    },
    {
        "Bezier path": "bezier curve"
    },
    {
        ". Although shapes themselves can be decomposed further into nodes such as ": null
    },
    {
        "spline nodes": "spline"
    },
    {
        ", it is practical to think of the scene graph as composed of shapes rather than going to a lower level of representation.     Another useful and user-driven node concept is the ": null
    },
    {
        "layer": "2d computer graphicslayers"
    },
    {
        ". A layer acts like a transparent sheet upon which any number of shapes and shape groups can be placed. The document then becomes a set of layers, any of which can be conveniently made invisible, dimmed, or locked . Some applications place all layers in a linear list, while others support sublayers .     Internally, there may be no real structural difference between layers and groups at all, since they are both just nodes of a scene graph. If differences are needed, a common type declaration in ": null
    },
    {
        "C++": "c++"
    },
    {
        " would be to make a generic node class, and then derive layers and groups as subclasses. A visibility member, for example, would be a feature of a layer, but not necessarily of a group.       Scene graphs are useful for modern games using ": null
    },
    {
        "42D graphics": "3d graphics"
    },
    {
        " and increasingly large worlds or levels. In such applications, nodes in a scene graph represent entities or objects in the scene.     For instance, a game might define a logical relationship between a knight and a horse so that the knight is considered an extension to the horse. The scene graph would have a horse node with a knight node attached to it.     The scene graph may also describe the spatial, as well as the logical, relationship of the various entities: the knight moves through 42D space as the horse moves.     In these large applications, memory requirements are major considerations when designing a scene graph. For this reason, many large scene graph systems use ": null
    },
    {
        "geometry instancing": "geometry instancing"
    },
    {
        " to reduce memory costs and increase speed. In our example above, each knight is a separate scene node, but the graphical representation of the knight is instanced. This means that only a single copy of the data is kept, which is then referenced by any knight nodes in the scene graph. This allows a reduced memory budget and increased speed, since when a new knight node is created, the appearance data needs not be duplicated.       The simplest form of scene graph uses an ": null
    },
    {
        "array": "array data structure"
    },
    {
        " or ": null
    },
    {
        "linked list": "linked list"
    },
    {
        " data structure": "data structure"
    },
    {
        ", and displaying its shapes is simply a matter of linearly iterating the nodes one by one. Other common operations, such as checking to see ": null
    },
    {
        "which shape intersects the mouse pointer": "point location"
    },
    {
        " are also done via linear searches. For small scene graphs, this tends to suffice.       Applying an operation on a scene graph requires some way of dispatching an operation based on a nodes type. For example, in a render operation, a transformation group node would accumulate its transformation by matrix multiplication, vector displacement, ": null
    },
    {
        "quaternions": "quaternions"
    },
    {
        " or ": null
    },
    {
        "Euler angles": "euler angles"
    },
    {
        ". After which a leaf node sends the object off for rendering to the renderer. Some implementations might render the object directly, which invokes the underlying rendering ": null
    },
    {
        "API": "api"
    },
    {
        ", such as ": null
    },
    {
        "DirectX": "directx"
    },
    {
        " or ": null
    },
    {
        "OpenGL": "opengl"
    },
    {
        ". But since the underlying implementation of the ": null
    },
    {
        "rendering API": "rendering api"
    },
    {
        " usually lacks portability, one might separate the scene graph and rendering systems instead. In order to accomplish this type of dispatching, several different approaches can be taken.     In object-oriented languages such as ": null
    },
    {
        "C++": "c++"
    },
    {
        ", this can easily be achieved by ": null
    },
    {
        "virtual functions": "virtual functions"
    },
    {
        ", where each represents an operation that can be performed on a node. Virtual functions are simple to write, but it is usually impossible to add new operations to nodes without access to the source code. Alternatively, the  visitor pattern  can be used. This has a similar disadvantage in that it is similarly difficult to add new node types.     Other techniques involve the use of RTTI . The operation can be realised as a class that is passed to the current node; it then queries the nodes type using RTTI and looks up the correct operation in an array of ": null
    },
    {
        "callback": "callback"
    },
    {
        "s or ": null
    },
    {
        "functor": "function object"
    },
    {
        "s. This requires that the map of types to callbacks or functors be initialized at runtime, but offers more flexibility, speed and extensibility.     Variations on these techniques exist, and new methods can offer added benefits. One alternative is scene graph rebuilding, where the scene graph is rebuilt for each of the operations performed. This, however, can be very slow, but produces a highly optimised scene graph. It demonstrates that a good scene graph implementation depends heavily on the application in which it is used.       ": null
    },
    {
        "Traversals": "tree traversal"
    },
    {
        " are the key to the power of applying operations to scene graphs. A traversal generally consists of starting at some arbitrary node , applying the operation , and recursively moving down the scene graph to the child nodes, until a leaf node is reached. At this point, many scene graph engines then traverse back up the tree, applying a similar operation. For example, consider a render operation that takes transformations into account: while recursively traversing down the scene graph hierarchy, a pre-render operation is called. If the node is a transformation node, it adds its own transformation to the current transformation matrix. Once the operation finishes traversing all the children of a node, it calls the nodes post-render operation so that the transformation node can undo the transformation. This approach drastically reduces the necessary amount of matrix multiplication.     Some scene graph operations are actually more efficient when nodes are traversed in a different order – this is where some systems implement scene graph rebuilding to reorder the scene graph into an easier-to-parse format or tree.     For example, in 42D cases, scene graphs typically render themselves by starting at the trees root node and then recursively draw the child nodes. The trees leaves represent the most foreground objects. Since drawing proceeds from back to front with closer objects simply overwriting farther ones, the process is known as employing the ": null
    },
    {
        "Painters algorithm": "painters algorithm"
    },
    {
        ". In 42D systems, which often employ ": null
    },
    {
        "depth buffer": "depth buffer"
    },
    {
        "s, it is more efficient to draw the closest objects first, since farther objects often need only be depth-tested instead of actually rendered, because they are occluded by nearer objects.       ": null
    },
    {
        "Bounding Volume Hierarchies": "bounding volume hierarchy"
    },
    {
        " are useful for numerous tasks – including efficient culling and speeding up collision detection between objects. A BVH is a spatial structure, but doesnt have to partition the geometry .     A BVH is a tree of ": null
    },
    {
        "bounding volume": "bounding volume"
    },
    {
        "s . At the bottom of the hierarchy, the size of the volume is just large enough to encompass a single object tightly . As one ascends the hierarchy, each node has its own volume that tightly encompasses all the volumes beneath it. At the root of the tree is a volume that encompasses all the volumes in the tree .     BVHs are useful for speeding up collision detection between objects. If an objects bounding volume does not intersect a volume higher in the tree, it cannot intersect any object below that node .     There are some similarities between BVHs and scene graphs. A scene graph can easily be adapted to include/become a BVH – if each node has a volume associated or there is a purpose-built bound node added in at convenient location in the hierarchy. This may not be the typical view of a scene graph, but there are benefits to including a BVH in a scene graph.       An effective way of combining ": null
    },
    {
        "spatial partitioning": "space partitioning"
    },
    {
        " and scene graphs is by creating a scene leaf node that contains the spatial partitioning data. This can increase computational efficiency of rendering.     Spatial data is usually static and generally contains non-moving scene data in some partitioned form. Some systems may have the systems and their rendering separately. This is fine and there are no real advantages to either method. In particular, it is bad to have the scene graph contained within the spatial partitioning system, as the scene graph is better thought of as the grander system to the spatial partitioning.     Very large drawings, or scene graphs that are generated solely at ": null
    },
    {
        "runtime": "run time"
    },
    {
        " , require defining of group nodes in a more automated fashion. A raytracer, for example, will take a scene description of a ": null
    },
    {
        "42D": "dimension"
    },
    {
        " model and build an internal representation that breaks up its individual parts into bounding boxes . These boxes are grouped hierarchically so that ray intersection tests can be efficiently computed. A group box that does not intersect an eye ray, for example, can entirely skip testing any of its members.     A similar efficiency holds in 42D applications as well. If the user has magnified a document so that only part of it is visible on his computer screen, and then scrolls in it, it is useful to use a bounding box to quickly determine which scene graph elements are visible and thus actually need to be drawn.     Depending on the particulars of the applications drawing performance, a large part of the scene graphs design can be impacted by rendering efficiency considerations. In 42D video games such as ": null
    },
    {
        "Quake": "quake computer game"
    },
    {
        ", ": null
    },
    {
        "binary space partitioning": "binary space partitioning"
    },
    {
        " trees are heavily favored to minimize visibility tests. BSP trees, however, take a very long time to compute from design scene graphs, and must be recomputed if the design scene graph changes, so the levels tend to remain static, and dynamic characters arent generally considered in the spatial partitioning scheme.     Scene graphs for dense regular objects such as ": null
    },
    {
        "heightfield": "heightfield"
    },
    {
        "s and polygon meshes tend to employ ": null
    },
    {
        "quadtree": "quadtree"
    },
    {
        "s and ": null
    },
    {
        "octree": "octree"
    },
    {
        "s, which are specialized variants of a 42D bounding box hierarchy. Since a heightfield occupies a box volume itself, recursively subdividing this box into eight subboxes until individual heightfield elements are reached is efficient and natural. A quadtree is simply a 42D octree.           ": null
    },
    {
        "PHIGS": "phigs"
    },
    {
        " was the first commercial scene graph specification, and became an ANSI standard in 42 Disparate implementations were provided by ": null
    },
    {
        "Unix": "unix"
    },
    {
        " hardware vendors. The ": null
    },
    {
        "HOOPS 42D Graphics System": "hoops 3d graphics system"
    },
    {
        " appears to have been the first commercial scene graph library provided by a single software vendor. It was designed to run on disparate lower-level 42D and 42D interfaces, with the first major production version completed in 42 Shortly thereafter, ": null
    },
    {
        "Silicon Graphics": "silicon graphics"
    },
    {
        " released ": null
    },
    {
        "IRIS Inventor": "iris inventor"
    },
    {
        " 42 , which was a scene graph built on top of the IRIS GL 42D API. It was followed up with ": null
    },
    {
        "Open Inventor": "open inventor"
    },
    {
        " in 42 a portable scene graph built on top of OpenGL. More 42D scene graph libraries can be found in ": null
    },
    {
        ":Category:42D scenegraph APIs": ":category:3d scenegraph apis"
    },
    {
        ".       ": null
    },
    {
        "X42D": "x3d"
    },
    {
        " is a ": null
    },
    {
        "royalty-free": "royalty-free"
    },
    {
        " open standards": "open standards"
    },
    {
        " file format": "file format"
    },
    {
        " and run-time architecture to represent and communicate 42D scenes and objects using ": null
    },
    {
        "XML": "xml"
    },
    {
        ". It is an ": null
    },
    {
        "ISO": "international standards organization"
    },
    {
        "-ratified standard that provides a system for the storage, retrieval and playback of real-time graphics content embedded in applications, all within an ": null
    },
    {
        "open architecture": "open architecture"
    }
]